namespace Skew.Tests {
  def testJavaScript {

# Check special cases for keyword operators
test("
@entry
def main {
  dynamic.foo(dynamic.void(0))
  dynamic.foo(dynamic.typeof(0))
  dynamic.foo(dynamic.typeof(0).length)
  dynamic.foo(dynamic.delete(dynamic.foo.bar))
}
", "
(function() {
  function main() {
    foo(void 0);
    foo(typeof 0);
    foo((typeof 0).length);
    foo(delete foo.bar);
  }

  main();
})();
").js

# Dynamic base classes should still work
test("
@export
class DerivedClass : dynamic.BaseClass {}
", "
(function() {
  function __extends(derived, base) {
    derived.prototype = Object.create(base.prototype);
    derived.prototype.constructor = derived;
  }

  DerivedClass = function() {
  };

  __extends(DerivedClass, BaseClass);
})();
").js

# Make sure classes with unused constructors are still emitted
test("
class A.B.C {}

namespace A.B.C {
  def foo {}
}

namespace D.E.F {
  def foo {}
}

@entry
def main {
  A.B.C.foo
  D.E.F.foo
}
", "
(function() {
  function main() {
    A.B.C.foo();
    D.E.F.foo();
  }

  var A = {};
  A.B = {};
  A.B.C = {};

  A.B.C.foo = function() {
  };

  var D = {};
  D.E = {};
  D.E.F = {};

  D.E.F.foo = function() {
  };

  main();
})();
").js

# Check renaming across inherited scopes
test("
class Foo {
  def foo(x int) {} # Foo.foo(x int)
  def foo(x bool) {} # Foo.foo(x bool)
}

class Bar : Foo {
  def foo1(x string) {} # Bar.foo1(x string)
  over foo(x int) {} # Bar.foo(x int)
}

@entry
def main {
  var foo = Foo.new
  var bar = Bar.new
  foo.foo(0)
  foo.foo(false)
  bar.foo(0)
  bar.foo1(null)
}
", "
(function() {
  function __extends(derived, base) {
    derived.prototype = Object.create(base.prototype);
    derived.prototype.constructor = derived;
  }

  function main() {
    var foo = new Foo();
    var bar = new Bar();
    foo.foo2(0);
    foo.foo1(false);
    bar.foo2(0);
    bar.foo1(null);
  }

  function Foo() {
  }

  // Foo.foo(x int)
  Foo.prototype.foo2 = function(x) {
  };

  // Foo.foo(x bool)
  Foo.prototype.foo1 = function(x) {
  };

  function Bar() {
    Foo.call(this);
  }

  __extends(Bar, Foo);

  // Bar.foo1(x string)
  Bar.prototype.foo1 = function(x) {
  };

  // Bar.foo(x int)
  Bar.prototype.foo2 = function(x) {
  };

  main();
})();
").js

# Check overloaded functions with identical names across types
test("
class Foo {
  def foo(x int) {} # Foo.foo(x int)
  def foo(x bool) {} # Foo.foo(x bool)
}

class Bar {
  def foo(x string) {} # Bar.foo(x string)
  def foo(x int) {} # Bar.foo(x int)
  def foo(x bool) {} # Bar.foo(x bool)
}

@entry
def main {
  var foo = Foo.new
  var bar = Bar.new
  foo.foo(0)
  foo.foo(false)
  bar.foo(0)
  bar.foo(false)
}
", "
(function() {
  function main() {
    var foo = new Foo();
    var bar = new Bar();
    foo.foo1(0);
    foo.foo2(false);
    bar.foo2(0);
    bar.foo3(false);
  }

  function Foo() {
  }

  // Foo.foo(x int)
  Foo.prototype.foo1 = function(x) {
  };

  // Foo.foo(x bool)
  Foo.prototype.foo2 = function(x) {
  };

  function Bar() {
  }

  // Bar.foo(x int)
  Bar.prototype.foo2 = function(x) {
  };

  // Bar.foo(x bool)
  Bar.prototype.foo3 = function(x) {
  };

  main();
})();
").js

# Check overloaded functions when an interface is present
test("
interface I {
  def foo(x int) # I.foo(x int)
  def foo(x bool) # I.foo(x bool)
}

class Foo :: I {
  def foo(x int) {} # Foo.foo(x int)
  def foo(x bool) {} # Foo.foo(x bool)
}

class Bar :: I {
  def foo(x string) {} # Bar.foo(x string)
  def foo(x int) {} # Bar.foo(x int)
  def foo(x bool) {} # Bar.foo(x bool)
}

@entry
def main {
  var foo = Foo.new
  var bar = Bar.new
  foo.foo(0)
  foo.foo(false)
  bar.foo(0)
  bar.foo(false)
}
", "
(function() {
  function main() {
    var foo = new Foo();
    var bar = new Bar();
    foo.foo2(0);
    foo.foo3(false);
    bar.foo2(0);
    bar.foo3(false);
  }

  function Foo() {
  }

  // Foo.foo(x int)
  Foo.prototype.foo2 = function(x) {
  };

  // Foo.foo(x bool)
  Foo.prototype.foo3 = function(x) {
  };

  function Bar() {
  }

  // Bar.foo(x int)
  Bar.prototype.foo2 = function(x) {
  };

  // Bar.foo(x bool)
  Bar.prototype.foo3 = function(x) {
  };

  main();
})();
").js.globalizeAllFunctions

# Interface removal with globalization
test("
interface IFoo {
  def foo
}

namespace IFoo {
  const FOO = 0
}

class Foo :: IFoo {
  def foo {}
}

@entry
def main int {
  var foo = Foo.new
  var ifoo = foo as IFoo
  foo.foo
  ifoo.foo
  return IFoo.FOO
}
", "
(function() {
  function main() {
    var foo = new Foo();
    var ifoo = foo;
    Foo.foo(foo);
    Foo.foo(ifoo);
    return Foo.FOO;
  }

  function Foo() {
  }

  Foo.foo = function(self) {
  };

  Foo.FOO = 0;

  process.exit(main());
})();
").js.globalizeAllFunctions

# Interface removal should not trigger even with globalization
test("
interface IFoo {
  def foo
}

namespace IFoo {
  const FOO = 0
}

class Foo :: IFoo {
  def foo {}
}

class Bar :: IFoo {
  def foo {}
}

@entry
def main int {
  var foo = Foo.new
  var bar = Bar.new
  var ifoo = foo as IFoo
  foo.foo
  bar.foo
  ifoo.foo
  ifoo = bar
  ifoo.foo
  return IFoo.FOO
}
", "
(function() {
  function main() {
    var foo = new Foo();
    var bar = new Bar();
    var ifoo = foo;
    foo.foo();
    bar.foo();
    ifoo.foo();
    ifoo = bar;
    ifoo.foo();
    return in_IFoo.FOO;
  }

  function Foo() {
  }

  Foo.prototype.foo = function() {
  };

  function Bar() {
  }

  Bar.prototype.foo = function() {
  };

  var in_IFoo = {};

  in_IFoo.FOO = 0;

  process.exit(main());
})();
").js.globalizeAllFunctions

# Check interface removal with an inlineable function
test("
@entry
def main int {
  var ifoo IFoo = Foo.new(0)
  return ifoo.x
}

class Foo :: IFoo {
  var _x int
  def x int { return _x }
}

interface IFoo {
  def x int
}
", "
(function() {
  function main() {
    var ifoo = new Foo(0);
    return ifoo.x();
  }

  function Foo(_x) {
    this._x = _x;
  }

  Foo.prototype.x = function() {
    return this._x;
  };

  process.exit(main());
})();
").js

# Check interface removal with an inlineable function
test("
@entry
def main int {
  var ifoo IFoo = Foo.new(0)
  return ifoo.x
}

class Foo :: IFoo {
  var _x int
  def x int { return _x }
}

interface IFoo {
  def x int
}
", "
(function() {
  function main() {
    var ifoo = new Foo(0);
    return Foo.x(ifoo);
  }

  function Foo(_x) {
    this._x = _x;
  }

  Foo.x = function(self) {
    return self._x;
  };

  process.exit(main());
})();
").js.globalizeAllFunctions

# Check interface removal with an inlineable function
test("
@entry
def main int {
  var ifoo IFoo = Foo.new(0)
  return ifoo.x
}

class Foo :: IFoo {
  var _x int
  def x int { return _x }
}

interface IFoo {
  def x int
}
", "
(function() {
  function main() {
    var ifoo = new Foo(0);
    return ifoo._x;
  }

  function Foo(_x) {
    this._x = _x;
  }

  process.exit(main());
})();
").js.globalizeAllFunctions.inlineAllFunctions

# Conflicting rename annotations should be an error
test("
class Foo {
  @rename(\"a\")
  def foo
}

class Bar : Foo {
  @rename(\"b\")
  over foo
}
", "
<stdin>:8:8: error: Cannot rename \"foo\" to both \"a\" and \"b\"
  over foo
       ~~~
").js

# Check map literal inlining
test("
@export
def main {
  dynamic.bar(foo(foo([], 1, 2), \"3\", \"4\"))
}

def foo(map dynamic, key dynamic, value dynamic) dynamic {
  map[key] = value
  return map
}
", "
(function() {
  main = function() {
    bar(foo(foo([], 1, 2), '3', '4'));
  };

  function foo(map, key, value) {
    map[key] = value;
    return map;
  }
})();
").js.inlineAllFunctions

# Check map literal inlining
test("
@export
def main {
  dynamic.bar(foo(foo({}, 1, 2), \"3\", \"4\"))
}

def foo(map dynamic, key dynamic, value dynamic) dynamic {
  map[key] = value
  return map
}
", "
(function() {
  main = function() {
    bar({1: 2, '3': '4'});
  };
})();
").js.inlineAllFunctions

# Check map literal inlining
test("
def foo<T>(map IntMap<T>, key int, value T) IntMap<T> {
  map[key] = value
  return map
}

@export
def main {
  dynamic.bar(foo<int>(foo<int>({}, 1, 2), 3, 4))
}
", "
(function() {
  main = function() {
    bar({1: 2, 3: 4});
  };
})();
").js.inlineAllFunctions

# Check map literal inlining
test("
@export
def main(x int) {
  dynamic.bar(foo(foo(foo(foo({}, 1, 2), 3, 4), x, 5), 6, 7))
}

def foo(map dynamic, key int, value int) dynamic {
  map[key] = value
  return map
}
", "
(function() {
  main = function(x) {
    bar(foo(foo({1: 2, 3: 4}, x, 5), 6, 7));
  };

  function foo(map, key, value) {
    map[key] = value;
    return map;
  }
})();
").js.inlineAllFunctions

# Check map literal inlining
test("
@export
def main(x int) {
  dynamic.bar({1: 2, 3: 4, x: 5, 6: 7} as Foo)
}

@import
class Foo {
  def []=(key int, value int) {
    (self as dynamic)[key] = value
  }

  def {...}(key int, value int) Foo {
    self[key] = value
    return self
  }
}

namespace Foo {
  def new Foo {
    return {} as dynamic
  }
}
", "
(function() {
  main = function(x) {
    bar(in_Foo.insert(in_Foo.insert({1: 2, 3: 4}, x, 5), 6, 7));
  };

  var in_Foo = {};

  in_Foo.insert = function(self, key, value) {
    self[key] = value;
    return self;
  };
})();
").js.inlineAllFunctions

# Check list literal inlining
test("
@export
def main {
  dynamic.bar(foo(foo([], 1), 2))
}

def foo(list dynamic, value dynamic) dynamic {
  list.push(value)
  return list
}
", "
(function() {
  main = function() {
    bar([1, 2]);
  };
})();
").js.inlineAllFunctions

# Check list literal inlining
test("
@export
def main {
  dynamic.bar(foo(foo([], 1), 2))
}

def foo(list dynamic, value dynamic) dynamic {
  list.unshift(value)
  return list
}
", "
(function() {
  main = function() {
    bar(foo(foo([], 1), 2));
  };

  function foo(list, value) {
    list.unshift(value);
    return list;
  }
})();
").js.inlineAllFunctions

# Check list literal inlining
test("
@export
def main {
  dynamic.bar(foo(foo({}, 1), 2))
}

def foo(list dynamic, value dynamic) dynamic {
  list.push(value)
  return list
}
", "
(function() {
  main = function() {
    bar(foo(foo({}, 1), 2));
  };

  function foo(list, value) {
    list.push(value);
    return list;
  }
})();
").js.inlineAllFunctions

# Check list literal inlining
test("
@export
def main(x int) {
  dynamic.bar([1, \"2\", x, false] as Foo)
}

@import
class Foo {
  def append(value dynamic) {
    (self as dynamic).push(value)
  }

  def [...](value dynamic) Foo {
    append(value)
    return self
  }
}

namespace Foo {
  def new Foo {
    return [] as dynamic
  }
}
", "
(function() {
  main = function(x) {
    bar([1, '2', x, false]);
  };
})();
").js.inlineAllFunctions

# Check that order doesn't matter when inlining list literals
test("
@import
class Foo {
  def [...](value int) Foo {
    (self as dynamic).push(value)
    return self
  }

  def [...](value bool) Foo {
    (self as dynamic).push(value)
    return self
  }
}

namespace Foo {
  def [new] Foo {
    return [] as dynamic
  }
}

@export
def main {
  [1, false] as Foo
}
", "
(function() {
  main = function() {
    [1, false];
  };
})();
").js.inlineAllFunctions

# Check that order doesn't matter when inlining list literals
test("
@import
class Foo {
  def [...](value bool) Foo {
    (self as dynamic).push(value)
    return self
  }

  def [...](value int) Foo {
    (self as dynamic).push(value)
    return self
  }
}

namespace Foo {
  def [new] Foo {
    return [] as dynamic
  }
}

@export
def main {
  [1, false] as Foo
}
", "
(function() {
  main = function() {
    [1, false];
  };
})();
").js.inlineAllFunctions

# Check for a bug where merged functions weren't emitted sometimes
test("
class Bar : Foo {
}

class Foo {
  def foo
  def foo {}
}

@entry
def main {
  Foo.new.foo
}
", "
(function() {
  function main() {
    new Foo().foo();
  }

  function Foo() {
  }

  Foo.prototype.foo = function() {
  };

  main();
})();
").js

# Check for a bug where merged functions weren't emitted sometimes
test("
class Foo {
  def foo
  def foo {}
}

class Bar : Foo {
}

@entry
def main {
  Foo.new.foo
}
", "
(function() {
  function main() {
    new Foo().foo();
  }

  function Foo() {
  }

  Foo.prototype.foo = function() {
  };

  main();
})();
").js

# Implemented instance functions should be pulled off of interfaces
test("
class Foo :: IFoo {
  def foo {}
}

interface IFoo {
  def bar {}
}

@export
def main {
  var foo = Foo.new
  var ifoo = foo as IFoo
  foo.foo
  ifoo.bar
}
", "
(function() {
  main = function() {
    var foo = new Foo();
    var ifoo = foo;
    foo.foo();
    in_IFoo.bar(ifoo);
  };

  function Foo() {
  }

  Foo.prototype.foo = function() {
  };

  var in_IFoo = {};

  in_IFoo.bar = function(self) {
  };
})();
").js

# Check folding of the "**" operator
test("
@export
def main dynamic {
  return [
    2 ** 2,
    2 ** 3,
    3 ** 2,
    2 ** 0,
    2 ** -2,
    0.25 ** 0.5,
    Math.pow(0.25, 0.5),
  ]
}
", "
(function() {
  main = function() {
    return [4, 8, 9, 1, 0, 0.5, 0.5];
  };
})();
").js.foldAllConstants

# Make sure variable initialization works with multiple user-defined constructors
test("
class Foo {
  var foo = \"\"
  var bar = [1, 2, 3]
  def new {}
  def new(x int) {}
}

@export
def main{
  Foo.new
  Foo.new(1)
}
", "
(function() {
  main = function() {
    new Foo();
    new Foo.new2(1);
  };

  function Foo() {
    this.foo = '';
    this.bar = [1, 2, 3];
  }

  Foo.new2 = function(x) {
    this.foo = '';
    this.bar = [1, 2, 3];
  };

  Foo.new2.prototype = Foo.prototype;
})();
").js

# Make sure constant folding of compile-time guards doesn't change code emission of the variables involved
test("
enum Foo { FOO }
if BAR == 0 {
  @export
  def main {}
}
@export
const BAR = Foo.FOO
", "
(function() {
  main = function() {
  };

  var Foo = {
    FOO: 0
  };

  BAR = Foo.FOO;
})();
").js

# Check for integer casting
test("
@export
def main(x int) {
  dynamic.foo(x + 1)
  dynamic.foo(x - 1)
  dynamic.foo(x * 2)
  dynamic.foo(x / 2)
  dynamic.foo(x % 2)
  dynamic.foo(x % 0)
  dynamic.foo(x % x)
  dynamic.foo(x << 1)
  dynamic.foo(x >> 1)
  dynamic.foo(x >>> 1)
  dynamic.foo(x >>> 0)
  dynamic.foo(x >>> x)
}
", "
(function() {
  var __imul = Math.imul ? Math.imul : function(a, b) {
    var ah = a >> 16 & 65535;
    var bh = b >> 16 & 65535;
    var al = a & 65535;
    var bl = b & 65535;
    return al * bl + (ah * bl + al * bh << 16) | 0;
  };

  main = function(x) {
    foo(x + 1 | 0);
    foo(x - 1 | 0);
    foo(__imul(x, 2));
    foo(x / 2 | 0);
    foo(x % 2);
    foo(x % 0 | 0);
    foo(x % x | 0);
    foo(x << 1);
    foo(x >> 1);
    foo(x >>> 1);
    foo(x >>> 0 | 0);
    foo(x >>> x | 0);
  };
})();
").js

# This caused an assert to fail during inlining
test("
interface Foo {
  def foo int
}

class Bar :: Foo {
  def foo int { return 0 }
}

class Baz {
  def foo(foo Foo) int {
    return false ? 0 : foo.foo
  }
}

@export
def main {
  Baz.new.foo(null)
}
", "
(function() {
  main = function() {
    Baz.foo(new Baz(), null);
  };
  var Bar = {};

  Bar.foo = function(self) {
    return 0;
  };

  function Baz() {
  }

  Baz.foo = function(self, foo) {
    return Bar.foo(foo);
  };
})();
").js.inlineAllFunctions.foldAllConstants.globalizeAllFunctions

# Check a case of assignment folding
test("
@export
def main(x int, y int) int {
  x = 0
  x = 1
  return x + y
}
", "
(function() {
  main = function(x, y) {
    x = 1;
    return x + y | 0;
  };
})();
").js.foldAllConstants

# Check a case of assignment folding
test("
@export
def main(x int, y int) int {
  x = 0
  x = x + 1
  return x + y
}
", "
(function() {
  main = function(x, y) {
    x = 0;
    x = x + 1 | 0;
    return x + y | 0;
  };
})();
").js.foldAllConstants

# Check a case of assignment folding
test("
@export
def main(x int, y int) int {
  x = 0
  y = 0
  x = 1
  return x + y
}
", "
(function() {
  main = function(x, y) {
    y = 0;
    x = 1;
    return x + y | 0;
  };
})();
").js.foldAllConstants

# Check a case of assignment folding
test("
@export
def main(x int, y int) int {
  x = 0
  dynamic.foo()
  x = 1
  return x + y
}
", "
(function() {
  main = function(x, y) {
    x = 0;
    foo();
    x = 1;
    return x + y | 0;
  };
})();
").js.foldAllConstants

# Check a case of assignment folding
test("
@export
def main(x int, y int) int {
  x = 0
  y = x
  x = 1
  return x + y
}
", "
(function() {
  main = function(x, y) {
    x = 0;
    y = x;
    x = 1;
    return x + y | 0;
  };
})();
").js.foldAllConstants

# Check a case of assignment folding
test("
@export
def main(x int, y int) int {
  x = 0
  y = dynamic.foo ? x : x + 1
  x = 1
  return x + y
}
", "
(function() {
  main = function(x, y) {
    x = 0;
    y = foo ? x : x + 1 | 0;
    x = 1;
    return x + y | 0;
  };
})();
").js.foldAllConstants

# Check a case of assignment folding
test("
class Foo {
  var x = 0
}

@export
def main int {
  var foo = Foo.new
  foo.x = 1
  foo.x = 2
  return foo.x
}
", "
(function() {
  main = function() {
    var foo = new Foo();
    foo.x = 2;
    return foo.x;
  };

  function Foo() {
    this.x = 0;
  }
})();
").js.foldAllConstants

# Check a case of assignment folding
test("
class Foo {
  var x = 0
  def foo {}
}

@export
def main int {
  var foo = Foo.new
  var y Foo = null
  var z = 0
  foo.x = 1
  y = foo
  z = y.x
  foo.x = 2
  return foo.x
}
", "
(function() {
  main = function() {
    var foo = new Foo();
    var y = null;
    var z = 0;
    foo.x = 1;
    y = foo;
    z = y.x;
    foo.x = 2;
    return foo.x;
  };

  function Foo() {
    this.x = 0;
  }
})();
").js.foldAllConstants

# Check a case of assignment folding
test("
class Foo {
  var x = 0
  def foo int { return x }
}

@export
def main int {
  var foo = Foo.new
  foo.x = foo.foo + 1
  foo.x = foo.foo + 2
  return foo.x
}
", "
(function() {
  main = function() {
    var foo = new Foo();
    foo.x = foo.foo() + 1 | 0;
    foo.x = foo.foo() + 2 | 0;
    return foo.x;
  };

  function Foo() {
    this.x = 0;
  }

  Foo.prototype.foo = function() {
    return this.x;
  };
})();
").js.foldAllConstants

# Check a case of assignment folding
test("
class Foo {
  var x = 0
  def foo {}
}

@export
def main int {
  var foo = Foo.new
  var bar = Foo.new
  foo.x = 1
  bar.x = 2
  foo.x = 3
  return foo.x
}
", "
(function() {
  main = function() {
    var foo = new Foo();
    var bar = new Foo();
    bar.x = 2;
    foo.x = 3;
    return foo.x;
  };

  function Foo() {
    this.x = 0;
  }
})();
").js.foldAllConstants

# Check constant folding of switch statements
test("
@export
def main string {
  switch 0 {
    case 0 { return \"0\" }
    case 1 { return \"1\" }
    default { return null }
  }
}
", "
(function() {
  main = function() {
    return '0';
  };
})();
").js.foldAllConstants

# Check constant folding of switch statements
test("
@export
def main string {
  switch 2 {
    case 0 { return \"0\" }
    case 1 { return \"1\" }
    default { return null }
  }
}
", "
(function() {
  main = function() {
    return null;
  };
})();
").js.foldAllConstants

# Check constant folding of switch statements
test("
@export
def main(x int) string {
  switch 0 {
    case 0 { return \"0\" }
    case x { return \"1\" }
    default { return null }
  }
}
", "
(function() {
  main = function(x) {
    return '0';
  };
})();
").js.foldAllConstants

# Check constant folding of switch statements
test("
@export
def main(x int) string {
  switch 1 {
    case x { return \"0\" }
    case 1 { return \"1\" }
    case 2 { return \"2\" }
    default { return null }
  }
}
", "
(function() {
  main = function(x) {
    switch (1) {
      case x: {
        return '0';
      }

      case 1: {
        return '1';
      }

      default: {
        return null;
      }
    }
  };
})();
").js.foldAllConstants

# Check IIFE parentheses
test("
@entry
def main {
  (=> dynamic.this)().foo[\"bar\"] = (=> dynamic.this)().foo[\"bar\"]
}
", "
(function() {
  function main() {
    (function() {
      return this;
    })().foo['bar'] = function() {
      return this;
    }().foo['bar'];
  }

  main();
})();
").js.foldAllConstants

# Check constant folding of a bitwise "and" nested between two shifts
test("
@export
def main(x int) int {
  x = (((x >> 8) & 255) << 8) + (((x >>> 8) & 255) << 8)
  x = (((x >> 7) & 255) << 8) + (((x >>> 7) & 255) << 8)
  x = (((x >> 8) & 255) << 7) + (((x >>> 8) & 255) << 7)
  return x
}
", "
(function() {
  main = function(x) {
    x = (x & 65280) + (x & 65280) | 0;
    x = (x << 1 & 65280) + (x << 1 & 65280) | 0;
    x = (x >> 1 & 32640) + (x >>> 1 & 32640) | 0;
    return x;
  };
})();
").js.foldAllConstants

# Check constant folding of two adjacent bitwise "and" operations inside a bitwise "or"
test("
@export
def main(x int) int {
  return x & 17 | 257 & x
}
", "
(function() {
  main = function(x) {
    return x & 273;
  };
})();
").js.foldAllConstants

# Check constant folding of a single "and" inside a bitwise "or"
test("
@export
def main(x int) int {
  x = (x & 0xFF000000) | 0xFFFFFF
  x = (x & 0x7F000000) | 0xFFFFFF
  x = 0xFFFFFF | (0xFF0000FF & x)
  x = 0xFFFFFF | (0x7F0000FF & x)
  return x
}
", "
(function() {
  main = function(x) {
    x = x | 16777215;
    x = x & 2130706432 | 16777215;
    x = x | 16777215;
    x = x & 2130706687 | 16777215;
    return x;
  };
})();
").js.foldAllConstants

# Check constant folding of identity operations
test("
@export
def main(x int, y fn() int) {
  # Multiplication (be careful about expressions with side effects and about NaN for dynamic values)
  dynamic.foo(x * 0)
  dynamic.foo(x * 1)
  dynamic.foo(x * 2)
  dynamic.foo(y() * 0)
  dynamic.foo(y() * 1)
  dynamic.foo(y() * 2)
  dynamic.foo(dynamic.z * 0)
  dynamic.foo(dynamic.z * 1)
  dynamic.foo(dynamic.z * 2)

  # Bitwise operations with an integer reference
  dynamic.foo(x & 0)
  dynamic.foo(x | 0)
  dynamic.foo(x & ~0)
  dynamic.foo(x | ~0)
  dynamic.foo(x << 0)
  dynamic.foo(x >> 0)
  dynamic.foo(x >>> 0)

  # Bitwise operations with an integer expression with side effects
  dynamic.foo(y() & 0)
  dynamic.foo(y() | 0)
  dynamic.foo(y() & ~0)
  dynamic.foo(y() | ~0)

  # Bitwise operations with a dynamically typed expression with side effects, may be a non-integer
  dynamic.foo(dynamic.z() & 0)
  dynamic.foo(dynamic.z() | 0)
  dynamic.foo(dynamic.z() & ~0)
  dynamic.foo(dynamic.z() | ~0)
  dynamic.foo(dynamic.z() << 0)
  dynamic.foo(dynamic.z() >> 0)
  dynamic.foo(dynamic.z() >>> 0)
}
", "
(function() {
  var __imul = Math.imul ? Math.imul : function(a, b) {
    var ah = a >> 16 & 65535;
    var bh = b >> 16 & 65535;
    var al = a & 65535;
    var bl = b & 65535;
    return al * bl + (ah * bl + al * bh << 16) | 0;
  };

  main = function(x, y) {
    // Multiplication (be careful about expressions with side effects and about NaN for dynamic values)
    foo(0);
    foo(x);
    foo(x << 1);
    foo(__imul(y(), 0));
    foo(y());
    foo(y() << 1);
    foo(z * 0);
    foo(z);
    foo(z * 2);

    // Bitwise operations with an integer reference
    foo(0);
    foo(x);
    foo(x);
    foo(-1);
    foo(x);
    foo(x);
    foo(x);

    // Bitwise operations with an integer expression with side effects
    foo(y() & 0);
    foo(y());
    foo(y());
    foo(y() | -1);

    // Bitwise operations with a dynamically typed expression with side effects, may be a non-integer
    foo(z() & 0);
    foo(z() | 0);
    foo(z() & -1);
    foo(z() | -1);
    foo(z() << 0);
    foo(z() >> 0);
    foo(z() >>> 0);
  };
})();
").js.foldAllConstants.inlineAllFunctions

# Check constant folding of bitwise operations and inlining
test("
type Color : int {
  def r int { return (self as int) & 255 }
  def g int { return ((self as int) >> 8) & 255 }
  def b int { return ((self as int) >> 16) & 255 }
  def a int { return (self as int) >>> 24 }

  def opaque Color {
    return new(r, g, b, 255)
  }
}

namespace Color {
  def new(r int, g int, b int, a int) Color {
    return (r | g << 8 | b << 16 | a << 24) as Color
  }
}

@export
def isOrange(color Color) bool {
  return color.opaque == Color.new(255, 127, 0, 255)
}
", "
(function() {
  isOrange = function(color) {
    return Color.opaque(color) == -16744449;
  };

  var Color = {};

  Color.opaque = function(self) {
    return self | -16777216;
  };
})();
").js.foldAllConstants.inlineAllFunctions

# Check that compile-time if statements work
test("
@export {
  if FOO == .FOO {
    const FOO_YES = true
  } else {
    const FOO_NO = false
  }

  if FOO == .BAR {
    const BAR_YES = true
  } else {
    const BAR_NO = false
  }
}

const FOO = Foo.FOO

enum Foo {
  FOO
  BAR
}
", "
(function() {
  FOO_YES = true;
  BAR_NO = false;
})();
").js

# Check that nested compile-time if statements work
test("
if true {
  @export {
    if FOO == .FOO {
      const FOO_YES = true
    } else {
      const FOO_NO = false
    }

    if FOO == .BAR {
      const BAR_YES = true
    } else {
      const BAR_NO = false
    }
  }
}

const FOO = Foo.FOO

enum Foo {
  FOO
  BAR
}
", "
(function() {
  FOO_YES = true;
  BAR_NO = false;
})();
").js

# Check constant folding of unicode string factory functions
test("
@export
def main string {
  return
    string.fromCodePoint('ðŸ˜„') +
    string.fromCodeUnit('x') +
    string.fromCodePoints(['ðŸ’¾', 'ðŸ’¿']) +
    string.fromCodeUnits(['y', 'z'])
}
", "
(function() {
  main = function() {
    return 'ðŸ˜„xðŸ’¾ðŸ’¿yz';
  };
})();
").js.foldAllConstants

# Check constant folding of unicode string factory functions
test("
@export
def main(x int) string {
  return
    string.fromCodePoint(x) +
    string.fromCodeUnit(x) +
    string.fromCodePoints(['x', x]) +
    string.fromCodeUnits([x, x])
}
", "
(function() {
  main = function(x) {
    return in_string.fromCodePoint(x) + String.fromCharCode(x) + in_string.fromCodePoints([120, x]) + in_string.fromCodeUnits([x, x]);
  };

  function StringBuilder() {
    this.buffer = '';
  }

  StringBuilder.prototype.append = function(x) {
    this.buffer += x;
  };

  StringBuilder.prototype.toString = function() {
    return this.buffer;
  };

  var in_string = {};

  in_string.fromCodePoints = function(codePoints) {
    var builder = new StringBuilder();

    for (var i = 0, count1 = codePoints.length; i < count1; i = i + 1 | 0) {
      var codePoint = codePoints[i];
      builder.append(in_string.fromCodePoint(codePoint));
    }

    return builder.toString();
  };

  in_string.fromCodeUnits = function(codeUnits) {
    var result = '';

    for (var i = 0, count1 = codeUnits.length; i < count1; i = i + 1 | 0) {
      var codeUnit = codeUnits[i];
      result += String.fromCharCode(codeUnit);
    }

    return result;
  };

  in_string.fromCodePoint = function(codePoint) {
    return codePoint < 65536 ? String.fromCharCode(codePoint) : String.fromCharCode((codePoint - 65536 >> 10) + 55296 | 0) + String.fromCharCode((codePoint - 65536 & 1023) + 56320 | 0);
  };
})();
").js.foldAllConstants.inlineAllFunctions

# Check that iterating over a local constant doesn't generate an extra variable
test("
@export
def main {
  var foo = [0, 1, 2]
  var bar = [0, 1, 2]
  bar = []

  for i in foo {}
  for i in bar {}
}
", "
(function() {
  main = function() {
    var foo = [0, 1, 2];
    var bar = [0, 1, 2];
    bar = [];

    for (var i2 = 0, count = foo.length; i2 < count; i2 = i2 + 1 | 0) {
      var i = foo[i2];
    }

    for (var i3 = 0, list = bar, count1 = list.length; i3 < count1; i3 = i3 + 1 | 0) {
      var i1 = list[i3];
    }
  };
})();
").js.foldAllConstants.inlineAllFunctions

# Check for a bug with bounded for loops
test("
@export
def main {
  var foo = 0
  var bar = 5
  for i in foo..bar {}
}
", "
(function() {
  main = function() {
    for (var i = 0; i < 5; i = i + 1 | 0) {
    }
  };
})();
").js.foldAllConstants

# Test @neverinline
test("
def foo {
  dynamic.Foo()
}

@neverinline
def bar {
  dynamic.Bar()
}

@entry
def main {
  foo
  bar
}
", "
(function() {
  function bar() {
    Bar();
  }

  function main() {
    Foo();
    bar();
  }

  main();
})();
").js.inlineAllFunctions

# Test @alwaysinline
test("
def foo {
  dynamic.Foo()
}

@alwaysinline
def bar {
  dynamic.Bar()
}

class Foo {
  def foo { dynamic.Foo(self) }

  @alwaysinline
  def bar { dynamic.Bar(self) }
}

@entry
def main {
  foo
  bar

  Foo.new.foo
  Foo.new.bar
}
", "
(function() {
  function foo() {
    Foo();
  }

  function main() {
    foo();
    Bar();
    new Foo().foo();
    Bar(new Foo());
  }

  function Foo() {
  }

  Foo.prototype.foo = function() {
    Foo(this);
  };

  main();
})();
").js

# Test obscure bug with super class calls
test("
class Baz : Bar {
}

@entry
def main {
  Baz2.new.foo(0)
}

class Bar : Foo {
  over foo(bar int) {}
}

class Foo {
  def foo(bar int) {}
}

class Baz2 : Bar {
  over foo(bar int) {
    super(bar)
  }
}
", "
(function() {
  function __extends(derived, base) {
    derived.prototype = Object.create(base.prototype);
    derived.prototype.constructor = derived;
  }

  function main() {
    new Baz2().foo(0);
  }

  function Foo() {
  }

  Foo.prototype.foo = function(bar) {
  };

  function Bar() {
    Foo.call(this);
  }

  __extends(Bar, Foo);

  Bar.prototype.foo = function(bar) {
  };

  function Baz2() {
    Bar.call(this);
  }

  __extends(Baz2, Bar);

  Baz2.prototype.foo = function(bar) {
    Bar.prototype.foo.call(this, bar);
  };

  main();
})();
").js

# Test obscure bug with super class calls
test("
@entry
def main {
  Baz2.new.foo(0)
}

class Foo {
  def foo(bar int) {}
}

class Bar : Foo {
  over foo(bar int) {}
}

class Baz : Bar {
}

class Baz2 : Bar {
  over foo(bar int) {
    super(bar)
  }
}
", "
(function() {
  function __extends(derived, base) {
    derived.prototype = Object.create(base.prototype);
    derived.prototype.constructor = derived;
  }

  function main() {
    new Baz2().foo(0);
  }

  function Foo() {
  }

  Foo.prototype.foo = function(bar) {
  };

  function Bar() {
    Foo.call(this);
  }

  __extends(Bar, Foo);

  Bar.prototype.foo = function(bar) {
  };

  function Baz2() {
    Bar.call(this);
  }

  __extends(Baz2, Bar);

  Baz2.prototype.foo = function(bar) {
    Bar.prototype.foo.call(this, bar);
  };

  main();
})();
").js

# Test math constants
test("
@export
def main {
  dynamic.foo(Math.NAN, Math.INFINITY, -Math.INFINITY)
  dynamic.foo(Math.NAN.toString, Math.INFINITY.toString, (-Math.INFINITY).toString)
}
", "
(function() {
  main = function() {
    foo(0 / 0, 1 / 0, -(1 / 0));
    foo((0 / 0).toString(), (1 / 0).toString(), (-(1 / 0)).toString());
  };
})();
").js.inlineAllFunctions

# Test math constants
test("
@export
def main {
  dynamic.foo(Math.NAN, Math.INFINITY, -Math.INFINITY)
  dynamic.foo(Math.NAN.toString, Math.INFINITY.toString, (-Math.INFINITY).toString)
}
", "
(function() {
  main = function() {
    foo(NaN, Infinity, -Infinity);
    foo(NaN.toString(), Infinity.toString(), (-Infinity).toString());
  };
})();
").js.inlineAllFunctions.foldAllConstants

# Test math toString
test("
@export
def main {
  dynamic.foo(0.toString, 1.0.toString, (-1.0).toString, 0.5.toString, (-0.5).toString)
}
", "
(function() {
  main = function() {
    foo((0).toString(), (1).toString(), (-1).toString(), (0.5).toString(), (-0.5).toString());
  };
})();
").js

# Test math toString
test("
@export
def main {
  dynamic.foo(0.toString, 1.0.toString, (-1.0).toString, 0.5.toString, (-0.5).toString)
}
", "
(function() {
  main = function() {
    foo('0', (1).toString(), (-1).toString(), (0.5).toString(), (-0.5).toString());
  };
})();
").js.foldAllConstants

# Double literals must be emitted with the right format
test("
@export
def main(x double) {
  x = 1.0 / 2.0
  x = 1e100 / 2e100
  x = 1e-100 / 2e-100
  x = 1.5 / 2.5
  x = 1.5e100 / 2.5e100
  x = 1.5e-100 / 2.5e-100
}
", "
(function() {
  main = function(x) {
    x = 1 / 2;
    x = 1e+100 / 2e+100;
    x = 1e-100 / 2e-100;
    x = 1.5 / 2.5;
    x = 1.5e+100 / 2.5e+100;
    x = 1.5e-100 / 2.5e-100;
  };
})();
").js

# Test folding of nested shifts
test("
@export
def main(x int) {
  dynamic.foo(x * 32 * 64)
  dynamic.foo(x * 32.0 * 64)
  dynamic.foo(x * 32 * 64.0)
  dynamic.foo(x << 5 << 6)
  dynamic.foo(x >> 5 >> 6)
  dynamic.foo(x >>> 5 >>> 6)
  dynamic.foo(x << 5 >> 6)
  dynamic.foo(x << 5 >>> 6)
  dynamic.foo(x >> 5 >>> 6)
  dynamic.foo(x >>> 5 >> 6)
}
", "
(function() {
  main = function(x) {
    foo(x << 11);
    foo(x * 32 * 64);
    foo((x << 5) * 64);
    foo(x << 11);
    foo(x >> 11);
    foo(x >>> 11);
    foo(x << 5 >> 6);
    foo(x << 5 >>> 6);
    foo(x >> 5 >>> 6);
    foo(x >>> 5 >> 6);
  };
})();
").js.foldAllConstants

# Test renaming with symbol merging
test("
@import
class Foo {
  def new
  def foo(x int)
}

class Foo {
  @rename(\"bar\")
  def foo(x int)
}

@export
def main {
  Foo.new.foo(0)
}
", "
(function() {
  main = function() {
    new Foo().bar(0);
  };
})();
").js

# Test renaming with symbol merging
test("
@import
class Foo {
  def new
  @rename(\"bar\")
  def foo(x int)
}

class Foo {
  def foo(x int)
}

@export
def main {
  Foo.new.foo(0)
}
", "
(function() {
  main = function() {
    new Foo().bar(0);
  };
})();
").js

# Test renaming with symbol merging and generics
test("
@import
class Foo<X> {
  def new

  @rename(\"baz\")
  def foo<Y>(x Y)
  def foo<Z>(x Z)

  def bar<Y>(x Y)
  @rename(\"baz\")
  def bar<Z>(x Z)
}

@export
def main {
  Foo<int>.new.foo<int>(0)
  Foo<int>.new.bar<int>(0)
}
", "
(function() {
  main = function() {
    new Foo().baz(0);
    new Foo().baz(0);
  };
})();
").js

# Test imported auto-implemented operators
test("
@import
class Foo {
  def *(x int) Foo
}

@export
def main(foo Foo) {
  foo *= 2
}
", "
(function() {
  main = function(foo) {
    foo = foo * 2;
  };
})();
").js.inlineAllFunctions

# Test side-effect preservation for auto-implemented operators
test("
class Foo {
  var x = 0.0
  var y = 0
  var z = [0.0]
}

def bar Foo {
  return Foo.new
}

@export
def main(foo Foo) {
  foo.x **= 2
  foo.z[0] **= 2
  foo.z[foo.y] **= 2

  bar.x **= 2
  bar.z[0] **= 2
  bar.z[bar.y] **= 2
}
", "
(function() {
  main = function(foo) {
    var ref6;
    var ref5;
    var ref4;
    var ref3;
    var ref2;
    var ref1;
    var ref;
    foo.x = Math.pow(foo.x, 2);
    (ref = foo.z)[0] = Math.pow(ref[0], 2);
    (ref1 = foo.z)[ref2 = foo.y] = Math.pow(ref1[ref2], 2);
    (ref3 = new Foo()).x = Math.pow(ref3.x, 2);
    (ref4 = new Foo().z)[0] = Math.pow(ref4[0], 2);
    (ref5 = new Foo().z)[ref6 = new Foo().y] = Math.pow(ref5[ref6], 2);
  };

  function Foo() {
    this.x = 0;
    this.y = 0;
    this.z = [0];
  }
})();
").js.inlineAllFunctions

# Test the null join operator
test("
class Foo {
  var x Foo = null
}

def bar Foo {
  return Foo.new
}

@export
def main(foo Foo) {
  foo ?? bar
  foo.x ?? foo.x
  bar.x ?? bar.x
  bar.x ?? bar ?? foo.x ?? foo
}
", "
(function() {
  function bar() {
    return new Foo();
  }

  main = function(foo) {
    var ref2;
    var ref1;
    var ref;
    foo != null ? foo : bar();
    foo.x != null ? foo.x : foo.x;
    (ref = bar()).x != null ? ref.x : bar().x;
    (ref1 = bar()).x != null ? ref1.x : (ref2 = bar()) != null ? ref2 : foo.x != null ? foo.x : foo;
  };

  function Foo() {
    this.x = null;
  }
})();
").js

# Test the null dot operator
test("
class Foo {
  var a Foo = null
  def b Foo { return self }
  var c fn() Foo = => null
  def d(x int) Foo { return self }
}

def bar Foo {
  return Foo.new
}

@export
def main(foo Foo) {
  dynamic.use(foo?.a.a)
  dynamic.use(foo?.b.b)
  dynamic.use(foo?.c().c())
  dynamic.use(foo?.d(0).d(0))

  dynamic.use(foo?.a?.a)
  dynamic.use(foo?.b?.b)
  dynamic.use(foo?.c()?.c())
  dynamic.use(foo?.d(0)?.d(0))

  dynamic.use(bar?.a.a)
  dynamic.use(bar?.b.b)
  dynamic.use(bar?.c().c())
  dynamic.use(bar?.d(0).d(0))

  dynamic.use(bar?.a?.a)
  dynamic.use(bar?.b?.b)
  dynamic.use(bar?.c()?.c())
  dynamic.use(bar?.d(0)?.d(0))
}
", "
(function() {
  function bar() {
    return new Foo();
  }

  main = function(foo) {
    var ref15;
    var ref14;
    var ref13;
    var ref12;
    var ref11;
    var ref10;
    var ref9;
    var ref8;
    var ref7;
    var ref6;
    var ref5;
    var ref4;
    var ref3;
    var ref2;
    var ref1;
    var ref;
    use(foo != null ? foo.a.a : null);
    use(foo != null ? foo.b().b() : null);
    use(foo != null ? foo.c().c() : null);
    use(foo != null ? foo.d(0).d(0) : null);
    use((ref = foo != null ? foo.a : null) != null ? ref.a : null);
    use((ref1 = foo != null ? foo.b() : null) != null ? ref1.b() : null);
    use((ref2 = foo != null ? foo.c() : null) != null ? ref2.c() : null);
    use((ref3 = foo != null ? foo.d(0) : null) != null ? ref3.d(0) : null);
    use((ref4 = bar()) != null ? ref4.a.a : null);
    use((ref5 = bar()) != null ? ref5.b().b() : null);
    use((ref6 = bar()) != null ? ref6.c().c() : null);
    use((ref7 = bar()) != null ? ref7.d(0).d(0) : null);
    use((ref9 = (ref8 = bar()) != null ? ref8.a : null) != null ? ref9.a : null);
    use((ref11 = (ref10 = bar()) != null ? ref10.b() : null) != null ? ref11.b() : null);
    use((ref13 = (ref12 = bar()) != null ? ref12.c() : null) != null ? ref13.c() : null);
    use((ref15 = (ref14 = bar()) != null ? ref14.d(0) : null) != null ? ref15.d(0) : null);
  };

  function Foo() {
    this.a = null;
    this.c = function() {
      return null;
    };
  }

  Foo.prototype.b = function() {
    return this;
  };

  Foo.prototype.d = function(x) {
    return this;
  };
})();
").js

# Test top-level use of the null dot operator
test("
class Foo {
  var a Foo = null
  def b Foo { return self }
  var c fn() Foo = => null
  def d(x int) Foo { return self }
}

def bar Foo {
  return Foo.new
}

@export
def main(foo Foo) {
  foo?.a.a
  foo?.b.b
  foo?.c().c()
  foo?.d(0).d(0)

  foo?.a?.a
  foo?.b?.b
  foo?.c()?.c()
  foo?.d(0)?.d(0)

  bar?.a.a
  bar?.b.b
  bar?.c().c()
  bar?.d(0).d(0)

  bar?.a?.a
  bar?.b?.b
  bar?.c()?.c()
  bar?.d(0)?.d(0)
}
", "
(function() {
  function bar() {
    return new Foo();
  }

  main = function(foo) {
    var ref15;
    var ref14;
    var ref13;
    var ref12;
    var ref11;
    var ref10;
    var ref9;
    var ref8;
    var ref7;
    var ref6;
    var ref5;
    var ref4;
    var ref3;
    var ref2;
    var ref1;
    var ref;

    if (foo != null) {
      foo.a.a;
    }

    if (foo != null) {
      foo.b().b();
    }

    if (foo != null) {
      foo.c().c();
    }

    if (foo != null) {
      foo.d(0).d(0);
    }

    if ((ref = foo != null ? foo.a : null) != null) {
      ref.a;
    }

    if ((ref1 = foo != null ? foo.b() : null) != null) {
      ref1.b();
    }

    if ((ref2 = foo != null ? foo.c() : null) != null) {
      ref2.c();
    }

    if ((ref3 = foo != null ? foo.d(0) : null) != null) {
      ref3.d(0);
    }

    if ((ref4 = bar()) != null) {
      ref4.a.a;
    }

    if ((ref5 = bar()) != null) {
      ref5.b().b();
    }

    if ((ref6 = bar()) != null) {
      ref6.c().c();
    }

    if ((ref7 = bar()) != null) {
      ref7.d(0).d(0);
    }

    if ((ref9 = (ref8 = bar()) != null ? ref8.a : null) != null) {
      ref9.a;
    }

    if ((ref11 = (ref10 = bar()) != null ? ref10.b() : null) != null) {
      ref11.b();
    }

    if ((ref13 = (ref12 = bar()) != null ? ref12.c() : null) != null) {
      ref13.c();
    }

    if ((ref15 = (ref14 = bar()) != null ? ref14.d(0) : null) != null) {
      ref15.d(0);
    }
  };

  function Foo() {
    this.a = null;
    this.c = function() {
      return null;
    };
  }

  Foo.prototype.b = function() {
    return this;
  };

  Foo.prototype.d = function(x) {
    return this;
  };
})();
").js

# Test unary assignment operators
test("
class Foo {
  var x = 0
}

def foo Foo {
  return Foo.new
}

@export
def main {
  var x = 0
  var y = 0.0

  x++
  ++x
  x--
  --x

  y++
  ++y
  y--
  --y

  foo.x++
  ++foo.x
  foo.x--
  --foo.x

  dynamic.use(x++)
  dynamic.use(++x)
  dynamic.use(x--)
  dynamic.use(--x)

  dynamic.use(y++)
  dynamic.use(++y)
  dynamic.use(y--)
  dynamic.use(--y)

  dynamic.use(foo.x++)
  dynamic.use(++foo.x)
  dynamic.use(foo.x--)
  dynamic.use(--foo.x)
}
", "
(function() {
  function foo() {
    return new Foo();
  }

  main = function() {
    var ref7;
    var ref6;
    var ref5;
    var ref4;
    var ref3;
    var ref2;
    var ref1;
    var ref;
    var x = 0;
    var y = 0;
    x = x + 1 | 0;
    x = x + 1 | 0;
    x = x - 1 | 0;
    x = x - 1 | 0;
    y++;
    ++y;
    y--;
    --y;
    (ref = foo()).x = ref.x + 1 | 0;
    (ref1 = foo()).x = ref1.x + 1 | 0;
    (ref2 = foo()).x = ref2.x - 1 | 0;
    (ref3 = foo()).x = ref3.x - 1 | 0;
    use((x = x + 1 | 0) - 1 | 0);
    use(x = x + 1 | 0);
    use((x = x - 1 | 0) + 1 | 0);
    use(x = x - 1 | 0);
    use(y++);
    use(++y);
    use(y--);
    use(--y);
    use(((ref4 = foo()).x = ref4.x + 1 | 0) - 1 | 0);
    use((ref5 = foo()).x = ref5.x + 1 | 0);
    use(((ref6 = foo()).x = ref6.x - 1 | 0) + 1 | 0);
    use((ref7 = foo()).x = ref7.x - 1 | 0);
  };

  function Foo() {
    this.x = 0;
  }
})();
").js.foldAllConstants

# Test custom unary assignment operators
test("
class Foo {
  var foo Foo = null
  var bar List<Foo> = []
  def ++ Foo { return self }
}

def bar Foo {
  return Foo.new
}

def baz int {
  return 0
}

@export
def main {
  var foo = Foo.new

  foo++
  ++foo
  bar.foo++
  ++bar.foo
  bar.bar[baz]++
  ++bar.bar[baz]

  dynamic.use(foo++)
  dynamic.use(++foo)
  dynamic.use(bar.foo++)
  dynamic.use(++bar.foo)
  dynamic.use(bar.bar[baz]++)
  dynamic.use(++bar.bar[baz])
}
", "
(function() {
  function bar() {
    return new Foo();
  }

  function baz() {
    return 0;
  }

  main = function() {
    var ref14;
    var ref13;
    var ref12;
    var ref11;
    var ref10;
    var ref9;
    var ref8;
    var ref7;
    var ref6;
    var ref5;
    var ref4;
    var ref3;
    var ref2;
    var ref1;
    var ref;
    var foo = new Foo();
    foo = foo.increment();
    foo = foo.increment();
    (ref = bar()).foo = ref.foo.increment();
    (ref1 = bar()).foo = ref1.foo.increment();
    (ref2 = bar().bar)[ref3 = baz()] = ref2[ref3].increment();
    (ref4 = bar().bar)[ref5 = baz()] = ref4[ref5].increment();
    use((ref6 = foo, foo = ref6.increment(), ref6));
    use(foo = foo.increment());
    use((ref7 = (ref8 = bar()).foo, ref8.foo = ref7.increment(), ref7));
    use((ref9 = bar()).foo = ref9.foo.increment());
    use((ref10 = (ref11 = bar().bar)[ref12 = baz()], ref11[ref12] = ref10.increment(), ref10));
    use((ref13 = bar().bar)[ref14 = baz()] = ref13[ref14].increment());
  };

  function Foo() {
    this.foo = null;
    this.bar = [];
  }

  Foo.prototype.increment = function() {
    return this;
  };
})();
").js

# Test null assignment operator
test("
class Foo {
  var x Foo = null
}

def foo Foo {
  return Foo.new
}

def bar(foo Foo) {
}

@export
def main(baz Foo) {
  baz ?? foo
  baz ?= foo
  baz.x ?? foo
  baz.x ?= foo
  foo.x ?? foo
  foo.x ?= foo

  bar(baz ?? foo)
  bar(baz ?= foo)
  bar(baz.x ?? foo)
  bar(baz.x ?= foo)
  bar(foo.x ?? foo)
  bar(foo.x ?= foo)
}
", "
(function() {
  function foo() {
    return new Foo();
  }

  function bar(foo) {
  }

  main = function(baz) {
    var ref3;
    var ref2;
    var ref1;
    var ref;
    baz != null ? baz : foo();

    if (baz == null) {
      baz = foo();
    }

    baz.x != null ? baz.x : foo();

    if (baz.x == null) {
      baz.x = foo();
    }

    (ref = foo()).x != null ? ref.x : foo();

    if ((ref1 = foo()).x == null) {
      ref1.x = foo();
    }

    bar(baz != null ? baz : foo());
    bar(baz != null ? baz : baz = foo());
    bar(baz.x != null ? baz.x : foo());
    bar(baz.x != null ? baz.x : baz.x = foo());
    bar((ref2 = foo()).x != null ? ref2.x : foo());
    bar((ref3 = foo()).x != null ? ref3.x : ref3.x = foo());
  };

  function Foo() {
    this.x = null;
  }
})();
").js

# Test null assignment operator with dynamic values
test("
@export
def main {
  dynamic.use(dynamic.foo[dynamic.bar] ?? \"1\")
  dynamic.use(dynamic.foo[dynamic.bar] ?= \"2\")
  dynamic.use(dynamic.foo()[dynamic.bar()] ?? \"3\")
  dynamic.use(dynamic.foo()[dynamic.bar()] ?= \"4\")
}
", "
(function() {
  main = function() {
    var ref3;
    var ref2;
    var ref1;
    var ref;
    use(foo[bar] !== null ? foo[bar] : '1');
    use(foo[bar] !== null ? foo[bar] : foo[bar] = '2');
    use((ref = foo())[ref1 = bar()] !== null ? ref[ref1] : '3');
    use((ref2 = foo())[ref3 = bar()] !== null ? ref2[ref3] : ref2[ref3] = '4');
  };
})();
").js

# Test "?=" and "?." with comments when converted to if statements
test("
class Foo {
  var foo Foo
}

@export
def main(foo Foo) {
  foo ?= foo # This comment should be kept
  foo?.foo # This comment should be kept too
}
", "
(function() {
  main = function(foo) {
    // This comment should be kept
    if (foo == null) {
      foo = foo;
    }

    // This comment should be kept too
    if (foo != null) {
      foo.foo;
    }
  };
  var Foo = {};
})();
").js

# Test string interpolation empty string omission
test("
@export {
  var a = \"\\(1)\"
  var b = \"a\\(1)\"
  var c = \"\\(1)b\"
  var d = \"a\\(1)b\"
  var e = \"\\(\"\")\\(\"\")\"
  var f = \"\\(\"\")\\(\"\")\\(1)\\(\"\")\\(\"\")\"
}
", "
(function() {
  a = (1).toString();
  b = 'a' + (1).toString();
  c = (1).toString() + 'b';
  d = 'a' + (1).toString() + 'b';
  e = '';
  f = (1).toString();
})();
").js

# Test string interpolation toString insertion
test("
@import {
  def x int
  def y dynamic
}

@export
var z = \"\\(x)\\(y)\"
", "
(function() {
  z = x().toString() + y();
})();
").js

# Test nested string interpolation
test("
var x = => \"\"

@export
var y =
  \"\\(1)\\(\"a\")\\(
    \"\\(x())\\((x()))\\(
      \"\\(\"b\" + x() + \"c\")\\((x() + \"d\" + x()))\"
    )\"
  )\"
", "
(function() {
  var x = function() {
    return '';
  };
  y = (1).toString() + 'a' + (x() + x() + ('b' + x() + 'c' + (x() + 'd' + x())));
})();
").js

# Test string interpolation order without constant folding
test("
@import
def x string

@export {
  var y = x + \"\\(x)\\(x)\"
  var z = \"a\\(x)b\" + \"c\\(x)d\"
}
", "
(function() {
  y = x() + (x() + x());
  z = 'a' + x() + 'b' + ('c' + x() + 'd');
})();
").js

# Test string interpolation order with constant folding
test("
@import
def x string

@export {
  var y = x + \"\\(x)\\(x)\"
  var z = \"a\\(x)b\" + \"c\\(x)d\"
}
", "
(function() {
  y = x() + x() + x();
  z = 'a' + x() + 'bc' + x() + 'd';
})();
").js.foldAllConstants

# Check assignment operators inside global variable initializers
test("
class Foo {
  var y Foo = null
  var z = 0
}

var x = Foo.new

@export
var y = x.y.z += 2
", "
(function() {
  function Foo() {
    this.y = null;
    this.z = 0;
  }

  var ref;
  var x = new Foo();
  y = (ref = x.y).z = ref.z + 2 | 0;
})();
").js

  }
}
