namespace Skew.Tests {
  def testSimple {

test("
var foo Foo<dynamic> = null
", "
<stdin>:1:9: error: \"Foo\" is not declared
var foo Foo<dynamic> = null
        ~~~
")

test("
var x = 0b2
", "
<stdin>:1:10: error: Expected NEWLINE but found IDENTIFIER
var x = 0b2
         ~~
")

test("
var x = 0b02
", "
<stdin>:1:12: error: Expected NEWLINE but found INT
var x = 0b02
           ^
")

test("
var x = 0o8
", "
<stdin>:1:10: error: Expected NEWLINE but found IDENTIFIER
var x = 0o8
         ~~
")

test("
var x = 0o08
", "
<stdin>:1:12: error: Expected NEWLINE but found INT
var x = 0o08
           ^
")

test("
var x = 0xG
", "
<stdin>:1:10: error: Expected NEWLINE but found IDENTIFIER
var x = 0xG
         ~~
")

test("
var x = 0x0G
", "
<stdin>:1:12: error: Expected NEWLINE but found IDENTIFIER
var x = 0x0G
           ^
")

test("
def main List<double> {
  return [
    0,
    0b10,
    0o76543210,
    0xFEDBCA98,
    0.5,
    1e100,
    1e+100,
    1e-100,
    0.5e100,
    0.5e+100,
    0.5e-100,
    0.toString,
    0.5.toString,
    1e100.toString,
    1e+100.toString,
    1e-100.toString,
    0.5e100.toString,
    0.5e+100.toString,
    0.5e-100.toString,
    01,
  ]
}
", "
<stdin>:22:5: warning: Number interpreted as decimal (use the prefix \"0o\" for octal numbers)
    01,
    ~~
<stdin>:14:5: error: Cannot convert from type \"string\" to type \"double\"
    0.toString,
    ~~~~~~~~~~
<stdin>:15:5: error: Cannot convert from type \"string\" to type \"double\"
    0.5.toString,
    ~~~~~~~~~~~~
<stdin>:16:5: error: Cannot convert from type \"string\" to type \"double\"
    1e100.toString,
    ~~~~~~~~~~~~~~
<stdin>:17:5: error: Cannot convert from type \"string\" to type \"double\"
    1e+100.toString,
    ~~~~~~~~~~~~~~~
<stdin>:18:5: error: Cannot convert from type \"string\" to type \"double\"
    1e-100.toString,
    ~~~~~~~~~~~~~~~
<stdin>:19:5: error: Cannot convert from type \"string\" to type \"double\"
    0.5e100.toString,
    ~~~~~~~~~~~~~~~~
<stdin>:20:5: error: Cannot convert from type \"string\" to type \"double\"
    0.5e+100.toString,
    ~~~~~~~~~~~~~~~~~
<stdin>:21:5: error: Cannot convert from type \"string\" to type \"double\"
    0.5e-100.toString,
    ~~~~~~~~~~~~~~~~~
")

test("
class Foo<T> {
  def foo T
}

class Bar<T> {
  def bar T
}

def main {
  var x Foo<Bar<Foo<int>>>
  var a bool = x
  var b bool = x.foo
  var c bool = x.foo.bar
  var d bool = x.foo.bar.foo
}
", "
<stdin>:11:16: error: Cannot convert from type \"Foo<Bar<Foo<int>>>\" to type \"bool\"
  var a bool = x
               ^
<stdin>:12:16: error: Cannot convert from type \"Bar<Foo<int>>\" to type \"bool\"
  var b bool = x.foo
               ~~~~~
<stdin>:13:16: error: Cannot convert from type \"Foo<int>\" to type \"bool\"
  var c bool = x.foo.bar
               ~~~~~~~~~
<stdin>:14:16: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  var d bool = x.foo.bar.foo
               ~~~~~~~~~~~~~
<stdin>:11:7: warning: Local variable \"a\" is never read
  var a bool = x
      ^
<stdin>:12:7: warning: Local variable \"b\" is never read
  var b bool = x.foo
      ^
<stdin>:13:7: warning: Local variable \"c\" is never read
  var c bool = x.foo.bar
      ^
<stdin>:14:7: warning: Local variable \"d\" is never read
  var d bool = x.foo.bar.foo
      ^
")

test("
class Foo {
  def new {}
}

namespace Foo {
  def new(x int) Foo {
    return new
  }
}
", "
")

test("
class Foo<T> {
  def size int
  def pop T
  def shift T
  def push(value T)
  def unshift(value T)
  def map<R>(callback fn(T) R) Foo<R>
  def filter(callback fn(T) bool) Foo<T>
}

def main {
  var x Foo<int>
  x.push(x.size)
  x.filter(1.0)
  x.map(1.0)
  x.map<string>(1.0)
  x.filter(x => x + 100)
  x.map(x => x + 100)
  var y int = x.map<string>(1.0)
}
", "
<stdin>:14:12: error: Cannot convert from type \"double\" to type \"fn(int) bool\"
  x.filter(1.0)
           ~~~
<stdin>:15:3: error: Cannot use unparameterized type \"Foo.map\" here
  x.map(1.0)
  ~~~~~
<stdin>:16:17: error: Cannot convert from type \"double\" to type \"fn(int) string\"
  x.map<string>(1.0)
                ~~~
<stdin>:17:17: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  x.filter(x => x + 100)
                ~~~~~~~
<stdin>:18:3: error: Cannot use unparameterized type \"Foo.map\" here
  x.map(x => x + 100)
  ~~~~~
<stdin>:18:9: error: Unable to determine the type of \"x\"
  x.map(x => x + 100)
        ^
<stdin>:19:29: error: Cannot convert from type \"double\" to type \"fn(int) string\"
  var y int = x.map<string>(1.0)
                            ~~~
<stdin>:19:15: error: Cannot convert from type \"Foo<string>\" to type \"int\"
  var y int = x.map<string>(1.0)
              ~~~~~~~~~~~~~~~~~~
<stdin>:19:7: warning: Local variable \"y\" is never read
  var y int = x.map<string>(1.0)
      ^
")

test("
class Foo {
  def new {}
  def foo<T>(t T) Foo { return self }
}

def main {
  Foo.new.foo(0).foo(0.0)
  Foo.new.foo<bool>(0).foo<int>(0.0)
}
", "
<stdin>:7:3: error: Cannot use unparameterized type \"Foo.foo\" here
  Foo.new.foo(0).foo(0.0)
  ~~~~~~~~~~~
<stdin>:8:21: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  Foo.new.foo<bool>(0).foo<int>(0.0)
                    ^
<stdin>:8:33: error: Cannot convert from type \"double\" to type \"int\" without a cast
  Foo.new.foo<bool>(0).foo<int>(0.0)
                                ~~~
")

test("
class Foo {
  def new {}
  def foo Foo { return self }
  def bar {}
}

def main {
  var x int = => Foo.new
  var y int = => Foo.new.foo
  var z int = => Foo.new.bar
}
", "
<stdin>:8:15: error: Cannot convert from type \"fn() Foo\" to type \"int\"
  var x int = => Foo.new
              ~~~~~~~~~~
<stdin>:9:15: error: Cannot convert from type \"fn() Foo\" to type \"int\"
  var y int = => Foo.new.foo
              ~~~~~~~~~~~~~~
<stdin>:10:15: error: Cannot convert from type \"fn()\" to type \"int\"
  var z int = => Foo.new.bar
              ~~~~~~~~~~~~~~
<stdin>:8:7: warning: Local variable \"x\" is never read
  var x int = => Foo.new
      ^
<stdin>:9:7: warning: Local variable \"y\" is never read
  var y int = => Foo.new.foo
      ^
<stdin>:10:7: warning: Local variable \"z\" is never read
  var z int = => Foo.new.bar
      ^
")

test("
def main(x int) {
  main
  x
  x + 1
  x ? x : x
}
", "
<stdin>:2:3: error: The function \"main\" must be called
  main
  ~~~~
<stdin>:3:3: warning: Unused expression
  x
  ^
<stdin>:4:3: warning: Unused expression
  x + 1
  ~~~~~
<stdin>:5:3: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  x ? x : x
  ^
<stdin>:5:7: warning: Both sides of \":\" are identical, is this a bug?
  x ? x : x
      ~~~~~
<stdin>:5:7: warning: Unused expression
  x ? x : x
      ^
<stdin>:5:11: warning: Unused expression
  x ? x : x
          ^
")

test("
def main {
  bar(x => foo(x))
  bar(x => x + 1)
  bar(x => x)
}

def foo(x int) int {
  return 0
}

def bar(x fn(int)) {
}
", "
<stdin>:3:12: warning: Unused expression
  bar(x => x + 1)
           ~~~~~
<stdin>:4:12: warning: Unused expression
  bar(x => x)
           ^
")

test("
def main {
  var x = null
  var y = => null
}
", "
<stdin>:2:7: error: Implicitly typed variables cannot be of type \"null\"
  var x = null
      ^
<stdin>:3:14: error: Cannot create a function with a return type of \"null\"
  var y = => null
             ~~~~
<stdin>:2:7: warning: Local variable \"x\" is never read
  var x = null
      ^
<stdin>:3:7: warning: Local variable \"y\" is never read
  var y = => null
      ^
")

test("
def main {
  var a = => 0
  var b = => {}
  var c = () => 0
  var d = () => {}
  var e = () int => 0
  var f = () int => { return 0 }
  var g fn(int) = x => 0
  var h fn(int) = x => {}
  var i fn(int) int = (x) => 0
  var j fn(int) int = (x) => { return 0 }
  var k = (x int) => 0
  var l = (x int) => {}
  var m = (x int) int => 0
  var n = (x int) int => { return 0 }
}
", "
<stdin>:8:24: warning: Unused expression
  var g fn(int) = x => 0
                       ^
<stdin>:2:7: warning: Local variable \"a\" is never read
  var a = => 0
      ^
<stdin>:3:7: warning: Local variable \"b\" is never read
  var b = => {}
      ^
<stdin>:4:7: warning: Local variable \"c\" is never read
  var c = () => 0
      ^
<stdin>:5:7: warning: Local variable \"d\" is never read
  var d = () => {}
      ^
<stdin>:6:7: warning: Local variable \"e\" is never read
  var e = () int => 0
      ^
<stdin>:7:7: warning: Local variable \"f\" is never read
  var f = () int => { return 0 }
      ^
<stdin>:8:7: warning: Local variable \"g\" is never read
  var g fn(int) = x => 0
      ^
<stdin>:9:7: warning: Local variable \"h\" is never read
  var h fn(int) = x => {}
      ^
<stdin>:10:7: warning: Local variable \"i\" is never read
  var i fn(int) int = (x) => 0
      ^
<stdin>:11:7: warning: Local variable \"j\" is never read
  var j fn(int) int = (x) => { return 0 }
      ^
<stdin>:12:7: warning: Local variable \"k\" is never read
  var k = (x int) => 0
      ^
<stdin>:13:7: warning: Local variable \"l\" is never read
  var l = (x int) => {}
      ^
<stdin>:14:7: warning: Local variable \"m\" is never read
  var m = (x int) int => 0
      ^
<stdin>:15:7: warning: Local variable \"n\" is never read
  var n = (x int) int => { return 0 }
      ^
")

test("
class Foo<T> {
  def new {}
}

def main {
  var foo Foo<int> = Foo<int>.new
  var bar Foo<bool> = Foo<int>.new
}
", "
<stdin>:7:23: error: Cannot convert from type \"Foo<int>\" to type \"Foo<bool>\"
  var bar Foo<bool> = Foo<int>.new
                      ~~~~~~~~~~~~
<stdin>:6:7: warning: Local variable \"foo\" is never read
  var foo Foo<int> = Foo<int>.new
      ~~~
<stdin>:7:7: warning: Local variable \"bar\" is never read
  var bar Foo<bool> = Foo<int>.new
      ~~~
")

test("
class Foo {
  def in(x int) bool
}

def main(foo Foo) {
  false in foo
  0 in foo
}
", "
<stdin>:6:3: error: Cannot convert from type \"bool\" to type \"int\" without a cast
  false in foo
  ~~~~~
")

test("
namespace foo {
  namespace bar {
    def @baz
  }
}

@foo.bar.bax
@foo.bar.baz
def main {}
", "
<stdin>:7:10: error: \"@bax\" is not declared on type \"foo.bar\"
@foo.bar.bax
         ~~~
")

test("
def @foo(x int)
def @bar

@foo
@foo(1, 2)
@bar(1)
def main {}
", "
<stdin>:4:1: error: Expected 1 argument but found 0 arguments when calling \"@foo\"
@foo
~~~~
<stdin>:1:5: note: The function declaration is here
def @foo(x int)
    ~~~~
<stdin>:5:5: error: Expected 1 argument but found 2 arguments when calling \"@foo\"
@foo(1, 2)
    ~~~~~~
<stdin>:1:5: note: The function declaration is here
def @foo(x int)
    ~~~~
<stdin>:6:5: error: Cannot call the value returned from the function \"@bar\" (this function was called automatically because it takes no arguments)
@bar(1)
    ~~~
<stdin>:2:5: note: The function declaration is here
def @bar
    ~~~~
")

# These shouldn't cause missing newline errors
test("
def @foo

class foo {
  def -
  def new {}
}

class bar {
  def -

  @foo
  def new {}
}

class baz {
  def -

  # foo
  def new {}
}

def main bool {
  return 1 -
    1
}
", "
<stdin>:23:10: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  return 1 -
         ~~~
")

test("
class Foo {
  def foo {
    var self int
  }

  def bar(self int) {
  }

  def baz {
    if true {
      var self int
    }
  }
}
", "
<stdin>:3:9: error: \"self\" is already declared
    var self int
        ~~~~
<stdin>:6:11: error: \"self\" is already declared
  def bar(self int) {
          ~~~~
<stdin>:11:11: error: \"self\" shadows a previous declaration
      var self int
          ~~~~
<stdin>:3:9: warning: Local variable \"self\" is never read
    var self int
        ~~~~
<stdin>:11:11: warning: Local variable \"self\" is never read
      var self int
          ~~~~
")

test("
namespace a {
  class Foo.Bar {}
  class Foo.Baz {}
  class Foo {}
  def main(foo Foo.Bar, bar Foo.Baz) {}
}
namespace b {
  class Foo {
    class Bar {}
    class Baz {}
  }
  def main(foo Foo.Bar, bar Foo.Baz) {}
}
", "
")

test("
class ns1.Foo {}
var ns1 int
var ns2 int
class ns2.Foo {}
", "
<stdin>:2:5: error: \"ns1\" is already declared
var ns1 int
    ~~~
<stdin>:1:7: note: The previous declaration is here
class ns1.Foo {}
      ~~~
<stdin>:3:5: error: \"ns2\" is already declared
var ns2 int
    ~~~
<stdin>:4:7: note: The previous declaration is here
class ns2.Foo {}
      ~~~
")

test("
var ns.foo int
", "
<stdin>:1:7: error: Expected NEWLINE but found DOT
var ns.foo int
      ^
")

test("
def ns.foo int
", "
<stdin>:1:7: error: Expected NEWLINE but found DOT
def ns.foo int
      ^
")

test("
@skip
var a int

@skip {
  var x int
  var y int
}

@skip
@skip
def b {}

@skip
@skip {
  def c {}
}
", "
<stdin>:10:1: warning: Duplicate annotation \"@skip\" on \"b\"
@skip
~~~~~
<stdin>:14:1: warning: Duplicate annotation \"@skip\" on \"c\"
@skip {
~~~~~
<stdin>:1:1: error: Cannot use the annotation \"@skip\" on \"a\"
@skip
~~~~~
<stdin>:4:1: error: Cannot use the annotation \"@skip\" on \"x\"
@skip {
~~~~~
<stdin>:4:1: error: Cannot use the annotation \"@skip\" on \"y\"
@skip {
~~~~~
")

test("
class Foo {
  const a
  const b int
  const c = 0
  const d bool = 0
}

@import
class Bar {
  const a
  const b int
  const c = 0
  const d bool = 0
}

const a
const b int
const c = 0
const d bool = 0

@import {
  const w
  const x int
  const y = 0
  const z bool = 0
}
", "
<stdin>:2:9: error: Unable to determine the type of \"a\"
  const a
        ^
<stdin>:5:18: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  const d bool = 0
                 ^
<stdin>:10:9: error: Unable to determine the type of \"a\"
  const a
        ^
<stdin>:13:18: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  const d bool = 0
                 ^
<stdin>:16:7: error: Unable to determine the type of \"a\"
const a
      ^
<stdin>:17:7: error: The constant \"b\" must be initialized
const b int
      ^
<stdin>:19:16: error: Cannot convert from type \"int\" to type \"bool\" without a cast
const d bool = 0
               ^
<stdin>:22:9: error: Unable to determine the type of \"w\"
  const w
        ^
<stdin>:25:18: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  const z bool = 0
                 ^
")

test("
const a = 0
var b = 0

class Foo {
  const x = 0
}

def main(foo Foo) {
  const y = 0
  a = 0
  b = 0
  foo.x = 0
  y = 0
}
", "
<stdin>:10:3: error: Cannot store to constant symbol \"a\"
  a = 0
  ^
<stdin>:12:7: error: Cannot store to constant symbol \"x\"
  foo.x = 0
      ^
<stdin>:13:3: error: Cannot store to constant symbol \"y\"
  y = 0
  ^
<stdin>:9:9: warning: Local variable \"y\" is never read
  const y = 0
        ^
")

test("
class _Foo {
  var _x int
  var _bar _Bar

  def _foo {
    _x = 0
    _foo
    var _y = => _x
  }

  class _Bar {}
}

def _main(_foo _Foo) {
  _foo._x = 0
  _foo._foo
  var _x = => _foo._x
  var _y = => _foo._foo
  var _z _Foo._Bar
}
", "
<stdin>:15:8: error: Cannot access protected symbol \"_x\" here
  _foo._x = 0
       ~~
<stdin>:16:8: error: Cannot access protected symbol \"_foo\" here
  _foo._foo
       ~~~~
<stdin>:17:20: error: Cannot access protected symbol \"_x\" here
  var _x = => _foo._x
                   ~~
<stdin>:18:20: error: Cannot access protected symbol \"_foo\" here
  var _y = => _foo._foo
                   ~~~~
<stdin>:19:15: error: Cannot access protected symbol \"_Bar\" here
  var _z _Foo._Bar
              ~~~~
<stdin>:8:9: warning: Local variable \"_y\" is never read
    var _y = => _x
        ~~
<stdin>:17:7: warning: Local variable \"_x\" is never read
  var _x = => _foo._x
      ~~
<stdin>:18:7: warning: Local variable \"_y\" is never read
  var _y = => _foo._foo
      ~~
<stdin>:19:7: warning: Local variable \"_z\" is never read
  var _z _Foo._Bar
      ~~
")

test("
class bool {
  def +(x int, y int)
  def -(x int, y int) {}
}

def main {
  false + false
  false - false
}
", "
<stdin>:2:7: error: Expected \"+\" to take at most 1 argument
  def +(x int, y int)
      ^
<stdin>:3:7: error: Expected \"-\" to take at most 1 argument
  def -(x int, y int) {}
      ^
<stdin>:7:9: error: Expected 2 arguments but found 1 argument when calling \"+\"
  false + false
        ^
<stdin>:2:7: note: The function declaration is here
  def +(x int, y int)
      ^
<stdin>:8:9: error: Expected 2 arguments but found 1 argument when calling \"-\"
  false - false
        ^
<stdin>:3:7: note: The function declaration is here
  def -(x int, y int) {}
      ^
")

test("
class bool {
  def +(x bool)
  def -(x bool) {}
}

def main {
  false + false + false
  false - false - false
}
", "
<stdin>:7:3: error: The function \"+\" does not return a value
  false + false + false
  ~~~~~~~~~~~~~
<stdin>:2:7: note: The function declaration is here
  def +(x bool)
      ^
<stdin>:8:3: error: The function \"-\" does not return a value
  false - false - false
  ~~~~~~~~~~~~~
<stdin>:3:7: note: The function declaration is here
  def -(x bool) {}
      ^
")

test("
def main {
  0 + 0
  0 + 0.5
  0.5 + 0
  0.5 + 0.5
}
", "
<stdin>:2:3: warning: Unused expression
  0 + 0
  ~~~~~
<stdin>:3:3: warning: Unused expression
  0 + 0.5
  ~~~~~~~
<stdin>:4:3: warning: Unused expression
  0.5 + 0
  ~~~~~~~
<stdin>:5:3: warning: Unused expression
  0.5 + 0.5
  ~~~~~~~~~
")

test("
class Foo {
  def *
  def -(x int, y int)
  def <=> int
  def [...]
  def []
  def []=
  def foo=
  def !(x int)
  def {...}
}
", "
<stdin>:2:7: error: Expected \"*\" to take 1 argument
  def *
      ^
<stdin>:3:7: error: Expected \"-\" to take at most 1 argument
  def -(x int, y int)
      ^
<stdin>:4:7: error: Expected \"<=>\" to take 1 argument
  def <=> int
      ~~~
<stdin>:5:7: error: Expected \"[...]\" to take 1 argument
  def [...]
      ~~~~~
<stdin>:6:7: error: Expected \"[]\" to take 1 argument
  def []
      ~~
<stdin>:7:7: error: Expected \"[]=\" to take 2 arguments
  def []=
      ~~~
<stdin>:8:7: error: Expected \"foo=\" to take 1 argument
  def foo=
      ~~~~
<stdin>:9:7: error: Expected \"!\" to take 0 arguments
  def !(x int)
      ^
<stdin>:10:7: error: Expected \"{...}\" to take 2 arguments
  def {...}
      ~~~~~
")

test("
def main(x List<double>) {
  var y bool = x[false]
}
", "
<stdin>:2:18: error: Cannot convert from type \"bool\" to type \"int\" without a cast
  var y bool = x[false]
                 ~~~~~
<stdin>:2:16: error: Cannot convert from type \"double\" to type \"bool\" without a cast
  var y bool = x[false]
               ~~~~~~~~
<stdin>:2:7: warning: Local variable \"y\" is never read
  var y bool = x[false]
      ^
")

test("
def main(i int) {
  for i in false..false {
    i = false
  }
  for i in List<string>.new {
    i = false
  }
  for i in 0 {
    i = false
  }
  for j in 0..10 {}
  for j in 10..0 {}
}
", "
<stdin>:2:12: error: Cannot convert from type \"bool\" to type \"int\" without a cast
  for i in false..false {
           ~~~~~
<stdin>:2:19: error: Cannot convert from type \"bool\" to type \"int\" without a cast
  for i in false..false {
                  ~~~~~
<stdin>:2:7: error: \"i\" shadows a previous declaration
  for i in false..false {
      ^
<stdin>:1:10: note: The previous declaration is here
def main(i int) {
         ^
<stdin>:3:9: error: Cannot convert from type \"bool\" to type \"int\" without a cast
    i = false
        ~~~~~
<stdin>:5:7: error: \"i\" shadows a previous declaration
  for i in List<string>.new {
      ^
<stdin>:1:10: note: The previous declaration is here
def main(i int) {
         ^
<stdin>:6:9: error: Cannot convert from type \"bool\" to type \"int\" without a cast
    i = false
        ~~~~~
<stdin>:8:12: error: Cannot iterate over type \"int\"
  for i in 0 {
           ^
<stdin>:8:7: error: \"i\" shadows a previous declaration
  for i in 0 {
      ^
<stdin>:1:10: note: The previous declaration is here
def main(i int) {
         ^
<stdin>:9:9: error: Cannot convert from type \"bool\" to type \"int\" without a cast
    i = false
        ~~~~~
<stdin>:12:12: warning: This range is empty
  for j in 10..0 {}
           ~~~~~
")

test("
def main {
  var foo = true ? false : 0
  var bar bool = true ? 0 : 0.5
}
", "
<stdin>:2:20: error: No common type for \"bool\" and \"int\"
  var foo = true ? false : 0
                   ~~~~~~~~~
<stdin>:3:25: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  var bar bool = true ? 0 : 0.5
                        ^
<stdin>:3:29: error: Cannot convert from type \"double\" to type \"bool\" without a cast
  var bar bool = true ? 0 : 0.5
                            ~~~
<stdin>:2:7: warning: Local variable \"foo\" is never read
  var foo = true ? false : 0
      ~~~
<stdin>:3:7: warning: Local variable \"bar\" is never read
  var bar bool = true ? 0 : 0.5
      ~~~
")

test("
def main {
  var a int = [false]
  var b List<int> = [false]
  var c List<List<int>> = [[false]]
  var d int = {1: 2}
  var e IntMap<bool> = {\"a\": \"b\"}
  var f StringMap<bool> = {1: 2}
  [false, 0]
  [0, 0.5] - 1
  [null, [1], [0.5]]
  [null]
  []
  {0: 1} - 1
  {\"a\": 1} - 1
  {0.5: 1} - 1
  [foo]
}

def foo(x int) {
}
", "
<stdin>:2:15: error: Cannot infer a type for this literal
  var a int = [false]
              ~~~~~~~
<stdin>:3:22: error: Cannot convert from type \"bool\" to type \"int\" without a cast
  var b List<int> = [false]
                     ~~~~~
<stdin>:4:29: error: Cannot convert from type \"bool\" to type \"int\" without a cast
  var c List<List<int>> = [[false]]
                            ~~~~~
<stdin>:5:15: error: Cannot infer a type for this literal
  var d int = {1: 2}
              ~~~~~~
<stdin>:6:25: error: Cannot convert from type \"string\" to type \"int\"
  var e IntMap<bool> = {\"a\": \"b\"}
                        ~~~
<stdin>:6:30: error: Cannot convert from type \"string\" to type \"bool\"
  var e IntMap<bool> = {\"a\": \"b\"}
                             ~~~
<stdin>:7:28: error: Cannot convert from type \"int\" to type \"string\"
  var f StringMap<bool> = {1: 2}
                           ^
<stdin>:7:31: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  var f StringMap<bool> = {1: 2}
                              ^
<stdin>:8:11: error: No common type for \"bool\" and \"int\"
  [false, 0]
          ^
<stdin>:8:3: warning: Unused expression
  [false, 0]
  ~~~~~~~~~~
<stdin>:9:12: error: \"-\" is not declared on type \"List<double>\"
  [0, 0.5] - 1
           ^
<stdin>:10:15: error: No common type for \"List<int>\" and \"List<double>\"
  [null, [1], [0.5]]
              ~~~~~
<stdin>:10:3: warning: Unused expression
  [null, [1], [0.5]]
  ~~~~~~~~~~~~~~~~~~
<stdin>:11:3: error: Cannot infer a type for this literal
  [null]
  ~~~~~~
<stdin>:12:3: error: Cannot infer a type for this literal
  []
  ~~
<stdin>:13:10: error: \"-\" is not declared on type \"IntMap<int>\"
  {0: 1} - 1
         ^
<stdin>:14:12: error: \"-\" is not declared on type \"StringMap<int>\"
  {\"a\": 1} - 1
           ^
<stdin>:15:3: error: Cannot infer a type for this literal
  {0.5: 1} - 1
  ~~~~~~~~
<stdin>:16:4: error: The function \"foo\" must be called
  [foo]
   ~~~
<stdin>:16:3: warning: Unused expression
  [foo]
  ~~~~~
<stdin>:2:7: warning: Local variable \"a\" is never read
  var a int = [false]
      ^
<stdin>:3:7: warning: Local variable \"b\" is never read
  var b List<int> = [false]
      ^
<stdin>:4:7: warning: Local variable \"c\" is never read
  var c List<List<int>> = [[false]]
      ^
<stdin>:5:7: warning: Local variable \"d\" is never read
  var d int = {1: 2}
      ^
<stdin>:6:7: warning: Local variable \"e\" is never read
  var e IntMap<bool> = {\"a\": \"b\"}
      ^
<stdin>:7:7: warning: Local variable \"f\" is never read
  var f StringMap<bool> = {1: 2}
      ^
")

test("
class A {}

class B {
  def [...] {}
}

class C {
  def new {}
  def [...] {}
}

class D {
  def new {}
  def [...](x bool) D { return self }
}

def main {
  var a A = [1, 2]
  var b B = [1, 2]
  var c C = [1, 2]
  var d D = [1, 2]
}
", "
<stdin>:4:7: error: Expected \"[...]\" to take 1 argument
  def [...] {}
      ~~~~~
<stdin>:9:7: error: Expected \"[...]\" to take 1 argument
  def [...] {}
      ~~~~~
<stdin>:18:13: error: Cannot infer a type for this literal
  var a A = [1, 2]
            ~~~~~~
<stdin>:19:14: error: The function \"[...]\" does not return a value
  var b B = [1, 2]
             ^
<stdin>:4:7: note: The function declaration is here
  def [...] {}
      ~~~~~
<stdin>:19:14: error: Expected 0 arguments but found 1 argument when calling \"[...]\"
  var b B = [1, 2]
             ^
<stdin>:4:7: note: The function declaration is here
  def [...] {}
      ~~~~~
<stdin>:20:14: error: The function \"[...]\" does not return a value
  var c C = [1, 2]
             ^
<stdin>:9:7: note: The function declaration is here
  def [...] {}
      ~~~~~
<stdin>:20:14: error: Expected 0 arguments but found 1 argument when calling \"[...]\"
  var c C = [1, 2]
             ^
<stdin>:9:7: note: The function declaration is here
  def [...] {}
      ~~~~~
<stdin>:21:14: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  var d D = [1, 2]
             ^
<stdin>:21:17: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  var d D = [1, 2]
                ^
<stdin>:18:7: warning: Local variable \"a\" is never read
  var a A = [1, 2]
      ^
<stdin>:19:7: warning: Local variable \"b\" is never read
  var b B = [1, 2]
      ^
<stdin>:20:7: warning: Local variable \"c\" is never read
  var c C = [1, 2]
      ^
<stdin>:21:7: warning: Local variable \"d\" is never read
  var d D = [1, 2]
      ^
")

test("
class Foo {
  def [new](x int, y int, z int) int {}
  def {new}(x int, y int, z int) int {}
}
", "
<stdin>:2:34: error: Constructors cannot have a return type
  def [new](x int, y int, z int) int {}
                                 ~~~
<stdin>:2:7: error: Expected \"[new]\" to take at most 1 argument
  def [new](x int, y int, z int) int {}
      ~~~~~
<stdin>:3:34: error: Constructors cannot have a return type
  def {new}(x int, y int, z int) int {}
                                 ~~~
<stdin>:3:7: error: Expected \"{new}\" to take either 0 or 2 arguments
  def {new}(x int, y int, z int) int {}
      ~~~~~
")

test("
class Foo {
  def foo int {
    return Bar<int>.new.foo
  }

  def bar List<int> {
    return Bar<int>.new.foo
  }
}

class Bar<X> {
  def new {}
  def foo List<X> { return null }
}
", "
<stdin>:3:12: error: Cannot convert from type \"List<int>\" to type \"int\"
    return Bar<int>.new.foo
           ~~~~~~~~~~~~~~~~
")

test("
class Foo {
  def foo int
  def foo double
  def bar(x int)
  def bar(x double)
  def bar(x int)
}
", "
<stdin>:3:7: error: Duplicate overloaded function \"foo\"
  def foo double
      ~~~
<stdin>:2:7: note: The previous declaration is here
  def foo int
      ~~~
<stdin>:6:7: error: Duplicate overloaded function \"bar\"
  def bar(x int)
      ~~~
<stdin>:4:7: note: The previous declaration is here
  def bar(x int)
      ~~~
")

test("
class Bar : Foo {
  over foo
}

class Foo {
  def foo
}
", "
")

test("
class Foo {
  def foo
}

class Bar : Foo {
  over foo
}
", "
")

test("
class Bar : Foo {
  over foo
}

class Foo {
  def foo
  def foo
}
", "
<stdin>:7:7: error: Duplicate overloaded function \"foo\"
  def foo
      ~~~
<stdin>:6:7: note: The previous declaration is here
  def foo
      ~~~
")

test("
class Foo {
  def foo
  def foo
}

class Bar : Foo {
  over foo
}
", "
<stdin>:3:7: error: Duplicate overloaded function \"foo\"
  def foo
      ~~~
<stdin>:2:7: note: The previous declaration is here
  def foo
      ~~~
")

test("
class Bar : Foo {
  over foo
  over foo
}

class Foo {
  def foo
}
", "
<stdin>:3:8: error: Duplicate overloaded function \"foo\"
  over foo
       ~~~
<stdin>:2:8: note: The previous declaration is here
  over foo
       ~~~
")

test("
class Foo {
  def foo
}

class Bar : Foo {
  over foo
  over foo
}
", "
<stdin>:7:8: error: Duplicate overloaded function \"foo\"
  over foo
       ~~~
<stdin>:6:8: note: The previous declaration is here
  over foo
       ~~~
")

test("
class Bar : Foo {
  over foo
  over foo
}

class Foo {
  def foo
  def foo
}
", "
<stdin>:3:8: error: Duplicate overloaded function \"foo\"
  over foo
       ~~~
<stdin>:2:8: note: The previous declaration is here
  over foo
       ~~~
<stdin>:8:7: error: Duplicate overloaded function \"foo\"
  def foo
      ~~~
<stdin>:7:7: note: The previous declaration is here
  def foo
      ~~~
")

test("
class Foo {
  def foo
  def foo
}

class Bar : Foo {
  over foo
  over foo
}
", "
<stdin>:3:7: error: Duplicate overloaded function \"foo\"
  def foo
      ~~~
<stdin>:2:7: note: The previous declaration is here
  def foo
      ~~~
<stdin>:8:8: error: Duplicate overloaded function \"foo\"
  over foo
       ~~~
<stdin>:7:8: note: The previous declaration is here
  over foo
       ~~~
")

test("
def bar(x int) int { return 0 }
def bar(x double) double { return 0 }
def bar(x List<int>) List<int> { return null }

def main {
  var w bool = bar(null)
  var x bool = bar(0)
  var y bool = bar(0.5)
  var z bool = bar([])
}
", "
<stdin>:6:16: error: Cannot convert from type \"List<int>\" to type \"bool\"
  var w bool = bar(null)
               ~~~~~~~~~
<stdin>:7:16: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  var x bool = bar(0)
               ~~~~~~
<stdin>:8:16: error: Cannot convert from type \"double\" to type \"bool\" without a cast
  var y bool = bar(0.5)
               ~~~~~~~~
<stdin>:9:16: error: Cannot convert from type \"List<int>\" to type \"bool\"
  var z bool = bar([])
               ~~~~~~~
<stdin>:6:7: warning: Local variable \"w\" is never read
  var w bool = bar(null)
      ^
<stdin>:7:7: warning: Local variable \"x\" is never read
  var x bool = bar(0)
      ^
<stdin>:8:7: warning: Local variable \"y\" is never read
  var y bool = bar(0.5)
      ^
<stdin>:9:7: warning: Local variable \"z\" is never read
  var z bool = bar([])
      ^
")

test("
namespace Foo {
  def [new](x List<int>) {}
}

class Foo {}

def main(foo Foo) {
  foo = []
}
", "
<stdin>:8:9: error: The function \"[new]\" does not return a value
  foo = []
        ~~
<stdin>:2:7: note: The function declaration is here
  def [new](x List<int>) {}
      ~~~~~
")

test("
namespace Foo {
  def foo {}
  var bar = 0
}

class Foo<T> {
  def new {}
  def ifoo {}
  var ibar = 0
}

def main(foo Foo<int>) {
  foo.new
  Foo.new
  Foo<int>.new

  foo.foo
  Foo.foo
  Foo<int>.foo

  foo.bar = 0
  Foo.bar = 0
  Foo<int>.bar = 0

  foo.ifoo
  Foo.ifoo
  Foo<int>.ifoo

  foo.ibar = 0
  Foo.ibar = 0
  Foo<int>.ibar = 0
}
", "
<stdin>:13:7: error: Cannot access global member \"new\" from an instance context
  foo.new
      ~~~
<stdin>:14:3: error: Cannot use unparameterized type \"Foo\" here
  Foo.new
  ~~~
<stdin>:17:7: error: Cannot access global member \"foo\" from an instance context
  foo.foo
      ~~~
<stdin>:18:3: error: Cannot use unparameterized type \"Foo\" here
  Foo.foo
  ~~~
<stdin>:21:7: error: Cannot access global member \"bar\" from an instance context
  foo.bar = 0
      ~~~
<stdin>:23:3: error: Cannot use parameterized type \"Foo<int>\" here
  Foo<int>.bar = 0
  ~~~~~~~~
<stdin>:26:7: error: Cannot access instance member \"ifoo\" from a global context
  Foo.ifoo
      ~~~~
<stdin>:27:12: error: Cannot access instance member \"ifoo\" from a global context
  Foo<int>.ifoo
           ~~~~
<stdin>:30:7: error: Cannot access instance member \"ibar\" from a global context
  Foo.ibar = 0
      ~~~~
<stdin>:31:12: error: Cannot access instance member \"ibar\" from a global context
  Foo<int>.ibar = 0
           ~~~~
")

test("
class Foo {
  class Bar { def bar int { return foo + baz } }
  def baz int { return 0 }
  var foo = 0
}
", "
<stdin>:2:36: error: Cannot access instance member \"foo\" from a global context
  class Bar { def bar int { return foo + baz } }
                                   ~~~
<stdin>:2:42: error: Cannot access instance member \"baz\" from a global context
  class Bar { def bar int { return foo + baz } }
                                         ~~~
")

test("
class Foo { class Bar {} }
namespace Foo {
  namespace Bar { def bar int { return foo + baz } }
  def baz int { return 0 }
  var foo = 0
}
", "
")

test("
class Foo : int {}
class Bar : fn() {}
class Baz : Baz {}
", "
<stdin>:1:13: error: Cannot extend type \"int\"
class Foo : int {}
            ~~~
<stdin>:2:13: error: Cannot extend type \"fn()\"
class Bar : fn() {}
            ~~~~
<stdin>:3:7: error: Cyclic declaration of \"Baz\"
class Baz : Baz {}
      ~~~
")

test("
class Foo { def foo {} }
class Bar : Foo { def bar {} }
class Baz : Foo { def baz {} }

def main(foo Foo, bar Bar, baz Baz) {
  foo.foo
  foo.bar
  bar.foo
  bar.bar
  baz.foo
  baz.bar
}
", "
<stdin>:7:7: error: \"bar\" is not declared on type \"Foo\"
  foo.bar
      ~~~
<stdin>:11:7: error: \"bar\" is not declared on type \"Baz\"
  baz.bar
      ~~~
")

test("
class Foo { def new {} }
class Bar : Foo { def new { super } }
class Baz : Foo { def new { super } }

def main {
  var a Foo = Foo.new
  var b Foo = Bar.new
  var c Foo = Baz.new
  var d Bar = Foo.new
  var e Bar = Bar.new
  var f Bar = Baz.new
}
", "
<stdin>:9:15: error: Cannot convert from type \"Foo\" to type \"Bar\" without a cast
  var d Bar = Foo.new
              ~~~~~~~
<stdin>:11:15: error: Cannot convert from type \"Baz\" to type \"Bar\"
  var f Bar = Baz.new
              ~~~~~~~
<stdin>:6:7: warning: Local variable \"a\" is never read
  var a Foo = Foo.new
      ^
<stdin>:7:7: warning: Local variable \"b\" is never read
  var b Foo = Bar.new
      ^
<stdin>:8:7: warning: Local variable \"c\" is never read
  var c Foo = Baz.new
      ^
<stdin>:9:7: warning: Local variable \"d\" is never read
  var d Bar = Foo.new
      ^
<stdin>:10:7: warning: Local variable \"e\" is never read
  var e Bar = Bar.new
      ^
<stdin>:11:7: warning: Local variable \"f\" is never read
  var f Bar = Baz.new
      ^
")

test("
class Foo<T> { def new {} }
class Bar : Foo<int> { def new { super } }
class Baz : Foo<int> { def new { super } }

def main {
  var foo = true ? Bar.new : Baz.new
  var bar int = foo
}
", "
<stdin>:7:17: error: Cannot convert from type \"Foo<int>\" to type \"int\"
  var bar int = foo
                ~~~
<stdin>:7:7: warning: Local variable \"bar\" is never read
  var bar int = foo
      ~~~
")

test("
class Foo<T> { def new {} }
class Bar : Foo<int> { def new { super } }
class Baz : Foo<bool> { def new { super } }

def main {
  var foo = true ? Bar.new : Baz.new
  var bar int = foo
}
", "
<stdin>:6:20: error: No common type for \"Bar\" and \"Baz\"
  var foo = true ? Bar.new : Baz.new
                   ~~~~~~~~~~~~~~~~~
<stdin>:7:7: warning: Local variable \"bar\" is never read
  var bar int = foo
      ~~~
")

test("
class Foo<A, B> {
  def foo(a A) Foo<A, B> { return self }
  def bar(b B) A { return b as dynamic }
}

class Bar<T> : Foo<int, T> {
}

class Baz : Bar<bool> {
  def new { super }
}

def foo string {
  return Baz.new.foo(0.5).bar(null)
}
", "
<stdin>:14:22: error: Cannot convert from type \"double\" to type \"int\" without a cast
  return Baz.new.foo(0.5).bar(null)
                     ~~~
<stdin>:14:31: error: Cannot convert from type \"null\" to type \"bool\"
  return Baz.new.foo(0.5).bar(null)
                              ~~~~
<stdin>:14:10: error: Cannot convert from type \"int\" to type \"string\"
  return Baz.new.foo(0.5).bar(null)
         ~~~~~~~~~~~~~~~~~~~~~~~~~~
")

test("
var a = 0 # a
var b = 0 # b
# comment
var c = 0 # c

# comment
var d = 0 # d
", "
")

test("
class Foo<T> {
  def foo(x T)
  def foo(x int)
}

def foo(foo Foo<bool>) {
  foo.foo(0)
  foo.foo(0.5)
  foo.foo(false)
}
", "
<stdin>:8:3: error: No overload of \"foo\" was found that takes 1 argument of type double
  foo.foo(0.5)
  ~~~~~~~
")

test("
class Foo {
  def +=(x int)
  def +=(x List<int>)
}

def foo(foo Foo) {
  foo += false
  foo += []
  foo += [false]
  foo += {}
  foo += {false: false}
}
", "
<stdin>:7:7: error: No overload of \"+=\" was found that takes 1 argument of type bool
  foo += false
      ~~
<stdin>:9:11: error: Cannot convert from type \"bool\" to type \"int\" without a cast
  foo += [false]
          ~~~~~
<stdin>:10:10: error: Cannot infer a type for this literal
  foo += {}
         ~~
<stdin>:10:7: error: No overload of \"+=\" was found that takes 1 argument of type dynamic
  foo += {}
      ~~
<stdin>:11:10: error: Cannot infer a type for this literal
  foo += {false: false}
         ~~~~~~~~~~~~~~
<stdin>:11:7: error: No overload of \"+=\" was found that takes 1 argument of type dynamic
  foo += {false: false}
      ~~
")

test("
class Foo {
  def +=(x dynamic)
  def +=(x List<int>)
}

def foo(foo Foo) {
  foo += false
  foo += [false]
}
", "
<stdin>:8:11: error: Cannot convert from type \"bool\" to type \"int\" without a cast
  foo += [false]
          ~~~~~
")

test("
class Foo {
  def +=(x dynamic)
  def +=(x double)
}

def foo(foo Foo) {
  foo += 0
}
", "
<stdin>:7:7: error: Multiple matching overloads of \"+=\" were found that can take 1 argument of type int
  foo += 0
      ~~
")

test("
class Foo {
  def +=(x dynamic) int
  @prefer
  def +=(x double) double
}

def foo(foo Foo) {
  var bar bool = foo += 0
}
", "
<stdin>:8:18: error: Cannot convert from type \"double\" to type \"bool\" without a cast
  var bar bool = foo += 0
                 ~~~~~~~~
<stdin>:8:7: warning: Local variable \"bar\" is never read
  var bar bool = foo += 0
      ~~~
")

test("
class Foo {
  def new {}
  def <=>(x Foo) int { return 0 }
}

var foo int = Foo.new < Foo.new
var bar bool = Foo.new <=> Foo.new
var baz int = 1 < 2
", "
<stdin>:6:15: error: Cannot convert from type \"bool\" to type \"int\" without a cast
var foo int = Foo.new < Foo.new
              ~~~~~~~~~~~~~~~~~
<stdin>:7:16: error: Cannot convert from type \"int\" to type \"bool\" without a cast
var bar bool = Foo.new <=> Foo.new
               ~~~~~~~~~~~~~~~~~~~
<stdin>:8:15: error: Cannot convert from type \"bool\" to type \"int\" without a cast
var baz int = 1 < 2
              ~~~~~
")

test("
def main(x List<List<int>>) {
  var foo = [false] in x
}
", "
<stdin>:2:14: error: Cannot convert from type \"bool\" to type \"int\" without a cast
  var foo = [false] in x
             ~~~~~
<stdin>:2:7: warning: Local variable \"foo\" is never read
  var foo = [false] in x
      ~~~
")

test("
def main {
  for i in 0..10 {
    0 += 1
    0 = 1
    i += 1
    i = 1
  }
}
", "
<stdin>:3:5: error: Cannot store to this location
    0 += 1
    ^
<stdin>:4:5: error: Cannot store to this location
    0 = 1
    ^
<stdin>:5:5: error: Cannot store to constant symbol \"i\"
    i += 1
    ^
<stdin>:6:5: error: Cannot store to constant symbol \"i\"
    i = 1
    ^
")

test("
def main {
  for i in 0..10 {
    0 += 1
    0 = 1
    i += 1
    i = 1
  }
}
", "
<stdin>:3:5: error: Cannot store to this location
    0 += 1
    ^
<stdin>:4:5: error: Cannot store to this location
    0 = 1
    ^
<stdin>:5:5: error: Cannot store to constant symbol \"i\"
    i += 1
    ^
<stdin>:6:5: error: Cannot store to constant symbol \"i\"
    i = 1
    ^
")

test("
class Foo {
  def foo(x int)
}

class Bar : Foo {
  def foo(x bool)
}

def main(x Bar) {
  x.foo(0)
  x.foo(0.5)
  x.foo(false)
}
", "
<stdin>:11:3: error: No overload of \"foo\" was found that takes 1 argument of type double
  x.foo(0.5)
  ~~~~~
")

test("
class Foo {
  def foo(x string)
  def foo(x int)
}

class Bar : Foo {
  def foo(x bool)
}

def main(x Bar) {
  x.foo(0)
  x.foo(\"\")
  x.foo(0.5)
  x.foo(false)
}
", "
<stdin>:13:3: error: No overload of \"foo\" was found that takes 1 argument of type double
  x.foo(0.5)
  ~~~~~
")

test("
class Foo {
  def foo(x int)
}

class Bar : Foo {
  def foo(x string)
  def foo(x bool)
}

def main(x Bar) {
  x.foo(0)
  x.foo(\"\")
  x.foo(0.5)
  x.foo(false)
}
", "
<stdin>:13:3: error: No overload of \"foo\" was found that takes 1 argument of type double
  x.foo(0.5)
  ~~~~~
")

test("
class Foo {
  def foo(x Foo)
  def foo(x int)
}

class Bar : Foo {
  def foo(x string)
  def foo(x bool)
}

def main(x Bar) {
  x.foo(0)
  x.foo(\"\")
  x.foo(0.5)
  x.foo(null)
  x.foo(false)
}
", "
<stdin>:14:3: error: No overload of \"foo\" was found that takes 1 argument of type double
  x.foo(0.5)
  ~~~~~
<stdin>:15:3: error: Multiple matching overloads of \"foo\" were found that can take 1 argument of type null
  x.foo(null)
  ~~~~~
")

test("
class Foo<T> {
  var foo int
}

class Bar : Foo<int> {
  def foo
}
", "
<stdin>:6:7: error: \"foo\" overrides another declaration with the same name in base type \"Foo<int>\"
  def foo
      ~~~
<stdin>:2:7: note: The overridden declaration is here
  var foo int
      ~~~
")

test("
class Foo<T> {
  def foo
}

class Bar : Foo<int> {
  var foo int
}
", "
<stdin>:6:7: error: \"foo\" overrides another declaration with the same name in base type \"Foo<int>\"
  var foo int
      ~~~
<stdin>:2:7: note: The overridden declaration is here
  def foo
      ~~~
")

test("
class Foo<T> {
  class foo {}
}

class Bar : Foo<int> {
  def foo
}
", "
<stdin>:6:7: error: \"foo\" overrides another declaration with the same name in base type \"Foo<int>\"
  def foo
      ~~~
<stdin>:2:9: note: The overridden declaration is here
  class foo {}
        ~~~
")

test("
class Foo<T> {
  def foo
}

class Bar : Foo<int> {
  class foo {}
}
", "
<stdin>:6:9: error: \"foo\" overrides another declaration with the same name in base type \"Foo<int>\"
  class foo {}
        ~~~
<stdin>:2:7: note: The overridden declaration is here
  def foo
      ~~~
")

test("
class Foo<T> {
}

namespace Foo {
  def foo {}
}

class Bar : Foo<int> {
  def foo
}
", "
<stdin>:9:7: error: \"foo\" overrides another declaration with the same name in base type \"Foo<int>\"
  def foo
      ~~~
<stdin>:5:7: note: The overridden declaration is here
  def foo {}
      ~~~
")

test("
class Foo<T> {
  def foo
}

class Bar : Foo<int> {
}

namespace Bar {
  def foo {}
}
", "
<stdin>:9:7: error: \"foo\" overrides another declaration with the same name in base type \"Foo<int>\"
  def foo {}
      ~~~
<stdin>:2:7: note: The overridden declaration is here
  def foo
      ~~~
")

test("
class Foo<T> {
  def new {}
  def foo
}

class Bar : Foo<int> {
  def new { super }
  over foo
}

namespace Foo {
  def bar {}
}

namespace Bar {
  def bar {}
}
", "
")

test("
class Foo<T> {
  def foo int
}

class Bar : Foo<int> {
  def foo bool
}
", "
<stdin>:6:7: error: \"foo\" overrides another function with the same name and argument types but a different return type in base type \"Foo<int>\"
  def foo bool
      ~~~
<stdin>:2:7: note: The overridden function is here
  def foo int
      ~~~
")

test("
class Foo<T> {
  def foo int
}

class Bar : Foo<int> {
  def foo bool
  def bar int
}
", "
<stdin>:6:7: error: \"foo\" overrides another function with the same name and argument types but a different return type in base type \"Foo<int>\"
  def foo bool
      ~~~
<stdin>:2:7: note: The overridden function is here
  def foo int
      ~~~
")

test("
class Foo<T> {
  def foo int
  def bar int
}

class Bar : Foo<int> {
  def foo bool
}
", "
<stdin>:7:7: error: \"foo\" overrides another function with the same name and argument types but a different return type in base type \"Foo<int>\"
  def foo bool
      ~~~
<stdin>:2:7: note: The overridden function is here
  def foo int
      ~~~
")

test("
class Foo<T> {
  def foo int
  def bar bool
}

class Bar : Foo<int> {
  def foo bool
  def bar int
}
", "
<stdin>:7:7: error: \"foo\" overrides another function with the same name and argument types but a different return type in base type \"Foo<int>\"
  def foo bool
      ~~~
<stdin>:2:7: note: The overridden function is here
  def foo int
      ~~~
<stdin>:8:7: error: \"bar\" overrides another function with the same name and argument types but a different return type in base type \"Foo<int>\"
  def bar int
      ~~~
<stdin>:3:7: note: The overridden function is here
  def bar bool
      ~~~
")

test("
var x = super
def foo { super }

class Foo {
  def new { super }
  def foo { super }
}

namespace Foo {
  def bar { super }
}

class Bar : Foo {
  def new { super }
  over foo { super }
}

namespace Bar {
  def bar { super }
}
", "
<stdin>:5:13: error: Cannot use \"super\" here
  def new { super }
            ~~~~~
<stdin>:6:13: error: Cannot use \"super\" here
  def foo { super }
            ~~~~~
<stdin>:10:13: error: Cannot use \"super\" here
  def bar { super }
            ~~~~~
<stdin>:2:11: error: Cannot use \"super\" here
def foo { super }
          ~~~~~
<stdin>:1:9: error: Cannot use \"super\" here
var x = super
        ~~~~~
")

test("
class Foo {
  def new(x int) {}
  def foo(x int) {}
}

namespace Foo {
  def bar(x int) {}
}

class Bar : Foo {
  def new(x int) { super() }
  over foo(x int) { super() }
}

namespace Bar {
  def bar(x int) { super() }
}
", "
<stdin>:11:25: error: Expected 1 argument but found 0 arguments when calling \"new\"
  def new(x int) { super() }
                        ~~
<stdin>:2:7: note: The function declaration is here
  def new(x int) {}
      ~~~
<stdin>:12:26: error: Expected 1 argument but found 0 arguments when calling \"foo\"
  over foo(x int) { super() }
                         ~~
<stdin>:3:7: note: The function declaration is here
  def foo(x int) {}
      ~~~
<stdin>:16:25: error: Expected 1 argument but found 0 arguments when calling \"bar\"
  def bar(x int) { super() }
                        ~~
<stdin>:7:7: note: The function declaration is here
  def bar(x int) {}
      ~~~
")

test("
class Foo {
  def new(x int) {}
}

class Bar : Foo {
  def new(x bool) {
    super(x)
  }
}
", "
<stdin>:7:11: error: Cannot convert from type \"bool\" to type \"int\" without a cast
    super(x)
          ^
")

test("
class Foo {
  def new(x int) {}
}

class Bar : Foo {
  def new {
    super(1, 2)
  }
}
", "
<stdin>:7:10: error: Expected 1 argument but found 2 arguments when calling \"new\"
    super(1, 2)
         ~~~~~~
<stdin>:2:7: note: The function declaration is here
  def new(x int) {}
      ~~~
")

test("
class Foo {
  def new(x int) {}
  def new(x int, y int) {}
}

class Bar : Foo {
  def new(z int) {
    super(false)
  }

  def new(y int, z int) {
    super(false, y)
  }

  def new(x int, y int, z int) {
    super(x, y, z)
  }
}
", "
<stdin>:8:11: error: Cannot convert from type \"bool\" to type \"int\" without a cast
    super(false)
          ~~~~~
<stdin>:12:11: error: Cannot convert from type \"bool\" to type \"int\" without a cast
    super(false, y)
          ~~~~~
<stdin>:16:5: error: No overload of \"new\" was found that takes 3 arguments
    super(x, y, z)
    ~~~~~
")

test("
class Foo {
  def new(x int) {
    super
  }
}
", "
<stdin>:3:5: error: Cannot use \"super\" here
    super
    ~~~~~
")

test("
class Foo {
  def foo(x int) {}
  def foo {}
}

class Bar : Foo {
  over foo { super(false) }
  over foo(x int) { super }
  def foo(x int, y int) { super(x, y) }
}
", "
<stdin>:7:20: error: Cannot convert from type \"bool\" to type \"int\" without a cast
  over foo { super(false) }
                   ~~~~~
<stdin>:9:27: error: No overload of \"foo\" was found that takes 2 arguments
  def foo(x int, y int) { super(x, y) }
                          ~~~~~
")

test("
enum Foo {
  FOO
  BAR
}

def main {
  var foo int = Foo.FOO == .BAR
  var bar int = .FOO == Foo.BAR
  var baz int = .FOO == .BAR
}
", "
<stdin>:7:17: error: Cannot convert from type \"bool\" to type \"int\" without a cast
  var foo int = Foo.FOO == .BAR
                ~~~~~~~~~~~~~~~
<stdin>:8:17: error: Cannot convert from type \"bool\" to type \"int\" without a cast
  var bar int = .FOO == Foo.BAR
                ~~~~~~~~~~~~~~~
<stdin>:9:25: error: Cannot access \"BAR\" without type context
  var baz int = .FOO == .BAR
                        ~~~~
<stdin>:9:17: error: Cannot convert from type \"bool\" to type \"int\" without a cast
  var baz int = .FOO == .BAR
                ~~~~~~~~~~~~
<stdin>:7:7: warning: Local variable \"foo\" is never read
  var foo int = Foo.FOO == .BAR
      ~~~
<stdin>:8:7: warning: Local variable \"bar\" is never read
  var bar int = .FOO == Foo.BAR
      ~~~
<stdin>:9:7: warning: Local variable \"baz\" is never read
  var baz int = .FOO == .BAR
      ~~~
")

test("
enum Foo {
  var foo
  def bar
  def new
}

namespace Foo {
  var foo2
  def bar2
}
", "
<stdin>:2:3: error: Cannot use this declaration here
  var foo
  ~~~~~~~
<stdin>:4:3: error: Cannot use this declaration here
  def new
  ~~~~~~~
")

test("
enum Foo {
  FOO
}

def main {
  var a bool = Foo.FOO as string
  var b bool = Foo.FOO as int
  var c bool = Foo.FOO as double
  var d bool = \"FOO\" as Foo
  var e bool = 0 as Foo
  var f bool = 0.0 as Foo
  var g bool = Foo.FOO.toString
  var h int = Foo.FOO
}
", "
<stdin>:6:16: error: Cannot convert from type \"Foo\" to type \"string\"
  var a bool = Foo.FOO as string
               ~~~~~~~
<stdin>:6:16: error: Cannot convert from type \"string\" to type \"bool\"
  var a bool = Foo.FOO as string
               ~~~~~~~~~~~~~~~~~
<stdin>:7:16: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  var b bool = Foo.FOO as int
               ~~~~~~~~~~~~~~
<stdin>:8:16: error: Cannot convert from type \"double\" to type \"bool\" without a cast
  var c bool = Foo.FOO as double
               ~~~~~~~~~~~~~~~~~
<stdin>:9:16: error: Cannot convert from type \"string\" to type \"Foo\"
  var d bool = \"FOO\" as Foo
               ~~~~~
<stdin>:9:16: error: Cannot convert from type \"Foo\" to type \"bool\"
  var d bool = \"FOO\" as Foo
               ~~~~~~~~~~~~
<stdin>:10:16: error: Cannot convert from type \"Foo\" to type \"bool\"
  var e bool = 0 as Foo
               ~~~~~~~~
<stdin>:11:16: error: Cannot convert from type \"Foo\" to type \"bool\"
  var f bool = 0.0 as Foo
               ~~~~~~~~~~
<stdin>:12:16: error: Cannot convert from type \"string\" to type \"bool\"
  var g bool = Foo.FOO.toString
               ~~~~~~~~~~~~~~~~
<stdin>:6:7: warning: Local variable \"a\" is never read
  var a bool = Foo.FOO as string
      ^
<stdin>:7:7: warning: Local variable \"b\" is never read
  var b bool = Foo.FOO as int
      ^
<stdin>:8:7: warning: Local variable \"c\" is never read
  var c bool = Foo.FOO as double
      ^
<stdin>:9:7: warning: Local variable \"d\" is never read
  var d bool = \"FOO\" as Foo
      ^
<stdin>:10:7: warning: Local variable \"e\" is never read
  var e bool = 0 as Foo
      ^
<stdin>:11:7: warning: Local variable \"f\" is never read
  var f bool = 0.0 as Foo
      ^
<stdin>:12:7: warning: Local variable \"g\" is never read
  var g bool = Foo.FOO.toString
      ^
<stdin>:13:7: warning: Local variable \"h\" is never read
  var h int = Foo.FOO
      ^
")

test("
def main {
  if true {} else if true {} else {}

  # A
  if true {} # AA

  # B
  else if true {} # BB

  # C
  else {} # CC
}
", "
")

test("
def main {
  while true {} else {}
}
", "
<stdin>:2:17: error: Unexpected ELSE
  while true {} else {}
                ~~~~
")

test("
def main {
  while true {
    break
    continue
  }

  break
  continue

  if true {
    break
    continue
  }

  while true {
    if true {
      break
      continue
    }
  }
}
", "
<stdin>:7:3: error: Cannot use \"break\" outside a loop
  break
  ~~~~~
<stdin>:8:3: error: Cannot use \"continue\" outside a loop
  continue
  ~~~~~~~~
<stdin>:11:5: error: Cannot use \"break\" outside a loop
    break
    ~~~~~
<stdin>:12:5: error: Cannot use \"continue\" outside a loop
    continue
    ~~~~~~~~
")

test("
def main {
  while true {
    var x = => {
      break
      continue
    }
  }
}
", "
<stdin>:4:7: error: Cannot use \"break\" outside a loop
      break
      ~~~~~
<stdin>:5:7: error: Cannot use \"continue\" outside a loop
      continue
      ~~~~~~~~
<stdin>:3:9: warning: Local variable \"x\" is never read
    var x = => {
        ^
")

test("
enum Foo {
  FOO
  BAR
}

def main {
  switch Foo.FOO {
    case .FOO, .BAR, .BAZ {}
    case 0 {}
    default {}
  }
}
", "
<stdin>:8:23: error: \"BAZ\" is not declared on type \"Foo\"
    case .FOO, .BAR, .BAZ {}
                      ~~~
<stdin>:9:10: error: Cannot convert from type \"int\" to type \"Foo\" without a cast
    case 0 {}
         ^
<stdin>:9:10: error: Duplicate case value
    case 0 {}
         ^
<stdin>:8:10: note: The first occurrence is here
    case .FOO, .BAR, .BAZ {}
         ~~~~
")

test("
def main(x Foo) {
  switch 0 {
    case 0, 1, 2 {}
    case 0, 2 {}
    case 1 {}
  }

  switch x {
    case .FOO, .BAR, .BAZ {}
    case .FOO, .BAZ {}
    case .BAR {}
  }
}

enum Foo {
  FOO
  BAR
  BAZ
}
", "
<stdin>:4:10: error: Duplicate case value
    case 0, 2 {}
         ^
<stdin>:3:10: note: The first occurrence is here
    case 0, 1, 2 {}
         ^
<stdin>:4:13: error: Duplicate case value
    case 0, 2 {}
            ^
<stdin>:3:16: note: The first occurrence is here
    case 0, 1, 2 {}
               ^
<stdin>:5:10: error: Duplicate case value
    case 1 {}
         ^
<stdin>:3:13: note: The first occurrence is here
    case 0, 1, 2 {}
            ^
<stdin>:10:10: error: Duplicate case value
    case .FOO, .BAZ {}
         ~~~~
<stdin>:9:10: note: The first occurrence is here
    case .FOO, .BAR, .BAZ {}
         ~~~~
<stdin>:10:16: error: Duplicate case value
    case .FOO, .BAZ {}
               ~~~~
<stdin>:9:22: note: The first occurrence is here
    case .FOO, .BAR, .BAZ {}
                     ~~~~
<stdin>:11:10: error: Duplicate case value
    case .BAR {}
         ~~~~
<stdin>:9:16: note: The first occurrence is here
    case .FOO, .BAR, .BAZ {}
               ~~~~
")

test("
def foo(x double, y double) double { return 0 }
def foo(x int, y int) int { return 0 }

@prefer
def bar(x double, y double) double { return 0 }
def bar(x int, y int) int { return 0 }

def main {
  var a bool = foo(1, 2)
  var b bool = foo(1, 2.0)
  var c bool = foo(1, 2 as dynamic)

  var x bool = bar(1, 2)
  var y bool = bar(1, 2.0)
  var z bool = bar(1, 2 as dynamic)
}
", "
<stdin>:9:16: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  var a bool = foo(1, 2)
               ~~~~~~~~~
<stdin>:10:16: error: Cannot convert from type \"double\" to type \"bool\" without a cast
  var b bool = foo(1, 2.0)
               ~~~~~~~~~~~
<stdin>:11:16: error: Multiple matching overloads of \"foo\" were found that can take 2 arguments of types int and dynamic
  var c bool = foo(1, 2 as dynamic)
               ~~~
<stdin>:13:16: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  var x bool = bar(1, 2)
               ~~~~~~~~~
<stdin>:14:16: error: Cannot convert from type \"double\" to type \"bool\" without a cast
  var y bool = bar(1, 2.0)
               ~~~~~~~~~~~
<stdin>:15:16: error: Cannot convert from type \"double\" to type \"bool\" without a cast
  var z bool = bar(1, 2 as dynamic)
               ~~~~~~~~~~~~~~~~~~~~
<stdin>:9:7: warning: Local variable \"a\" is never read
  var a bool = foo(1, 2)
      ^
<stdin>:10:7: warning: Local variable \"b\" is never read
  var b bool = foo(1, 2.0)
      ^
<stdin>:11:7: warning: Local variable \"c\" is never read
  var c bool = foo(1, 2 as dynamic)
      ^
<stdin>:13:7: warning: Local variable \"x\" is never read
  var x bool = bar(1, 2)
      ^
<stdin>:14:7: warning: Local variable \"y\" is never read
  var y bool = bar(1, 2.0)
      ^
<stdin>:15:7: warning: Local variable \"z\" is never read
  var z bool = bar(1, 2 as dynamic)
      ^
")

test("
class Foo {
  var a bool
  var b = 0
}

class Bar : Foo {
  var c double
  var d = \"\"
}

def main {
  var foo int = Foo.new(0)
  var bar int = Bar.new(0, 1)
}
", "
<stdin>:12:25: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  var foo int = Foo.new(0)
                        ^
<stdin>:12:17: error: Cannot convert from type \"Foo\" to type \"int\"
  var foo int = Foo.new(0)
                ~~~~~~~~~~
<stdin>:13:25: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  var bar int = Bar.new(0, 1)
                        ^
<stdin>:13:17: error: Cannot convert from type \"Bar\" to type \"int\"
  var bar int = Bar.new(0, 1)
                ~~~~~~~~~~~~~
<stdin>:12:7: warning: Local variable \"foo\" is never read
  var foo int = Foo.new(0)
      ~~~
<stdin>:13:7: warning: Local variable \"bar\" is never read
  var bar int = Bar.new(0, 1)
      ~~~
")

test("
class Foo {
  const x int
  def new {
    x = 100
  }
}

class Bar : Foo {
  const y int
  def new {
    super
    x = 0
    y = 100
  }
}
", "
<stdin>:12:5: error: Cannot store to constant symbol \"x\"
    x = 0
    ^
")

test("
@import
class Foo {
  def new
  def foo { new }
}

@import
class Bar : Foo {
  over foo { new }
}

@import
class Baz : Foo {
  def new
  over foo { new }
}

def main {
  Foo.new
  Bar.new
  Baz.new
}
", "
<stdin>:9:14: error: \"new\" is not declared
  over foo { new }
             ~~~
<stdin>:20:7: error: \"new\" is not declared on type \"Bar\"
  Bar.new
      ~~~
")

test("
class Foo {
  var x int
}

class Bar : Foo {
  var y int
}

def main {
  Foo.new(0)
  Bar.new(0)
  Bar.new(0, 1)
}
", "
<stdin>:11:10: error: Expected 2 arguments but found 1 argument when calling \"new\"
  Bar.new(0)
         ~~~
<stdin>:5:7: note: The function declaration is here
class Bar : Foo {
      ~~~
")

test("
class Foo {}

namespace Foo {
  const x = 0
}

def main {
  Foo.new
}
", "
")

test("
class Foo {
  var foo = Foo.new
}

class Bar {
}

namespace Bar {
  var foo = Bar.new
}
", "
<stdin>:1:7: error: Cyclic declaration of \"new\"
class Foo {
      ~~~
")

test("
class Foo {
}

class Bar : Foo {
}

class Baz : Foo {
}

def main {
  Foo.new
  Bar.new
  Baz.new
}
", "
")

test("
class Foo {}
class Bar : Foo {}

def main {
  var a Foo = null as Foo
  var b = null as Bar
  var c = a as Foo
  var d = a as Bar
  var e int = 0.5 as int
  var f double = 0 as double
}
", "
<stdin>:5:20: warning: Unnecessary cast from type \"null\" to type \"Foo\"
  var a Foo = null as Foo
                   ~~~~~~
<stdin>:7:13: warning: Unnecessary cast from type \"Foo\" to type \"Foo\"
  var c = a as Foo
            ~~~~~~
<stdin>:10:20: warning: Unnecessary cast from type \"int\" to type \"double\"
  var f double = 0 as double
                   ~~~~~~~~~
<stdin>:6:7: warning: Local variable \"b\" is never read
  var b = null as Bar
      ^
<stdin>:7:7: warning: Local variable \"c\" is never read
  var c = a as Foo
      ^
<stdin>:8:7: warning: Local variable \"d\" is never read
  var d = a as Bar
      ^
<stdin>:9:7: warning: Local variable \"e\" is never read
  var e int = 0.5 as int
      ^
<stdin>:10:7: warning: Local variable \"f\" is never read
  var f double = 0 as double
      ^
")

test("
def foo
def foo
", "
<stdin>:2:5: error: Duplicate overloaded function \"foo\"
def foo
    ~~~
<stdin>:1:5: note: The previous declaration is here
def foo
    ~~~
<stdin>:1:5: error: Non-imported function \"foo\" is missing an implementation (use the \"@import\" annotation if it's implemented externally)
def foo
    ~~~
")

test("
def foo {}
def foo
", "
")

test("
def foo
def foo {}
", "
")

test("
def foo
def foo {}
def foo
", "
")

test("
def foo {}
def foo
def foo {}
def foo
", "
<stdin>:3:5: error: Duplicate overloaded function \"foo\"
def foo {}
    ~~~
<stdin>:1:5: note: The previous declaration is here
def foo {}
    ~~~
")

test("
def foo {}
def foo {}
", "
<stdin>:2:5: error: Duplicate overloaded function \"foo\"
def foo {}
    ~~~
<stdin>:1:5: note: The previous declaration is here
def foo {}
    ~~~
")

test("
def foo int
def foo double { return 0 }
", "
<stdin>:2:5: error: Duplicate overloaded function \"foo\"
def foo double { return 0 }
    ~~~
<stdin>:1:5: note: The previous declaration is here
def foo int
    ~~~
<stdin>:1:5: error: Non-imported function \"foo\" is missing an implementation (use the \"@import\" annotation if it's implemented externally)
def foo int
    ~~~
")

test("
def foo(x int)
def foo(x double)

def foo(x int) {}
def foo(x double) {}

def main {
  foo(null as dynamic)
}
", "
<stdin>:8:3: error: Multiple matching overloads of \"foo\" were found that can take 1 argument of type dynamic
  foo(null as dynamic)
  ~~~
")

test("
@prefer
def foo(x int)
def foo(x double)

def foo(x int) {}
def foo(x double) {}

def main {
  foo(null as dynamic)
}
", "
")

test("
def foo(x int) {}
def foo(x double) {}

@prefer
def foo(x int)
def foo(x double)

def main {
  foo(null as dynamic)
}
", "
")

test("
class Foo {
  def new(x int) {}
  def foo(x int) {}
  def foo(x double) {}
}

def main {
  Foo.new
  Foo.new(0).foo
}
", "
<stdin>:8:7: error: The function \"new\" must be called
  Foo.new
      ~~~
<stdin>:9:14: error: The function \"foo\" must be called
  Foo.new(0).foo
             ~~~
")

test("
class Foo {
}

namespace Foo {
  def new(x int) Foo {
    return null
  }
}

def main {
  var foo = Foo.new
}
", "
<stdin>:11:17: error: The function \"new\" must be called
  var foo = Foo.new
                ~~~
<stdin>:11:7: warning: Local variable \"foo\" is never read
  var foo = Foo.new
      ~~~
")

test("
class Foo {
  var foo = 0
  var bar = foo
}
", "
<stdin>:3:13: error: Cannot access instance member \"foo\" from a global context
  var bar = foo
            ~~~
")

test("
class Foo<T> {
  var foo T

  class Bar {
    var foo T
  }

  namespace Bar {
    var bar T
  }
}

namespace Foo {
  var bar T
}
", "
<stdin>:5:13: error: Cannot access type parameter \"T\" here
    var foo T
            ^
<stdin>:9:13: error: Cannot access type parameter \"T\" here
    var bar T
            ^
<stdin>:9:9: error: Cannot construct a default value of type \"T\"
    var bar T
        ~~~
<stdin>:14:11: error: Cannot access type parameter \"T\" here
  var bar T
          ^
<stdin>:14:7: error: Cannot construct a default value of type \"T\"
  var bar T
      ~~~
")

test("
# Nested uses of T should be fine inside instance functions
class Foo<T> {
  def new {
    var x = (a T) => {
      var y = (b T) => {}
    }
  }
}

namespace Foo {
  var x = (a T) => {
    var y = (b T) => {}
  }
}
", "
<stdin>:11:14: error: Cannot access type parameter \"T\" here
  var x = (a T) => {
             ^
<stdin>:12:16: error: Cannot access type parameter \"T\" here
    var y = (b T) => {}
               ^
<stdin>:4:9: warning: Local variable \"x\" is never read
    var x = (a T) => {
        ^
<stdin>:5:11: warning: Local variable \"y\" is never read
      var y = (b T) => {}
          ^
<stdin>:12:9: warning: Local variable \"y\" is never read
    var y = (b T) => {}
        ^
")

test("
class Foo<T> {
}

namespace Foo {
  def new(x T) T {
    var y Foo<T>
    return x
  }

  def foo {
    var y Foo<T>
  }
}
", "
<stdin>:6:9: warning: Local variable \"y\" is never read
    var y Foo<T>
        ^
<stdin>:11:9: warning: Local variable \"y\" is never read
    var y Foo<T>
        ^
")

test("
class Foo<T> {
}

namespace Foo {
  def foo {}
  def bar T { return dynamic.t }
}

def main {
  Foo.foo
  Foo<int>.foo
  Foo.bar
  Foo<int>.bar
}
", "
<stdin>:10:3: error: Cannot use unparameterized type \"Foo\" here
  Foo.foo
  ~~~
<stdin>:12:3: error: Cannot use unparameterized type \"Foo\" here
  Foo.bar
  ~~~
")

test("
class Foo<A, B, C> {
}

class Foo<X, Y> {
}
", "
<stdin>:4:11: error: \"Foo\" already has type parameters
class Foo<X, Y> {
          ~~~~
<stdin>:1:11: note: Type parameters were previously declared here
class Foo<A, B, C> {
          ~~~~~~~
")

test("
class Foo<T> {
  def [new](t List<T>) {}
}

class Bar<T> {
  def [new](t T) {}
}

def main {
  var foo Foo<int> = [0]
  var bar Foo<int> = [0]
}
", "
<stdin>:6:13: error: Expected argument \"t\" to be of type \"List<T>\" instead of type \"T\"
  def [new](t T) {}
            ^
<stdin>:10:7: warning: Local variable \"foo\" is never read
  var foo Foo<int> = [0]
      ~~~
<stdin>:11:7: warning: Local variable \"bar\" is never read
  var bar Foo<int> = [0]
      ~~~
")

test("
class Foo<K, V> {
  def {new}(k List<K>, v List<V>) {}
}

class Bar<K, V> {
  def {new}(k K, v V) {}
}

def main {
  var foo Foo<int, bool> = {1: false}
  var bar Foo<int, bool> = {1: false}
}
", "
<stdin>:6:13: error: Expected argument \"k\" to be of type \"List<T>\" instead of type \"K\"
  def {new}(k K, v V) {}
            ^
<stdin>:6:18: error: Expected argument \"v\" to be of type \"List<T>\" instead of type \"V\"
  def {new}(k K, v V) {}
                 ^
<stdin>:10:7: warning: Local variable \"foo\" is never read
  var foo Foo<int, bool> = {1: false}
      ~~~
<stdin>:11:7: warning: Local variable \"bar\" is never read
  var bar Foo<int, bool> = {1: false}
      ~~~
")

test("
class Foo<K, V> {
  def []=(key K, value V) {}
}

namespace Foo {
  def {new}(keys List<K>, values List<V>) Foo<K, V> {
    var foo = Foo<K, V>.new
    for i in 0..keys.count {
      foo[keys[i]] = values[i]
    }
    return foo
  }
}

def main {
  var foo Foo<int, bool> = {false: 1}
}
", "
<stdin>:16:29: error: Cannot convert from type \"bool\" to type \"int\" without a cast
  var foo Foo<int, bool> = {false: 1}
                            ~~~~~
<stdin>:16:36: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  var foo Foo<int, bool> = {false: 1}
                                   ^
<stdin>:16:7: warning: Local variable \"foo\" is never read
  var foo Foo<int, bool> = {false: 1}
      ~~~
")

test("
class Foo<T> {
  def new {}
  def {...}(x int, y T) Foo<T> { return self }
}

class Bar<T> {
  def {...}(x int, y T) Bar<T> { return self }
}

namespace Bar {
  def new Bar<T> { return null }
}

def main {
  var foo Foo<int> = {0: 1}
  var bar Bar<int> = {0: 1}
}
", "
<stdin>:15:7: warning: Local variable \"foo\" is never read
  var foo Foo<int> = {0: 1}
      ~~~
<stdin>:16:7: warning: Local variable \"bar\" is never read
  var bar Bar<int> = {0: 1}
      ~~~
")

test("
class Foo {
  var ivar = 0
  def ifun {}
}
class Bar : Foo {}
class Baz : Bar {
  over ifun {}
}

namespace Foo {
  var gvar = 0
  def gfun {}
}
namespace Bar {}
namespace Baz {
  def gfun {}
}

def main {
  Foo.new.ivar = 0
  Bar.new.ivar = 0
  Baz.new.ivar = 0

  Foo.new.ifun
  Bar.new.ifun
  Baz.new.ifun

  Foo.gvar = 0
  Bar.gvar = 0
  Baz.gvar = 0

  Foo.gfun
  Bar.gfun
  Baz.gfun
}
", "
<stdin>:29:7: error: \"gvar\" is not declared on type \"Bar\"
  Bar.gvar = 0
      ~~~~
<stdin>:30:7: error: \"gvar\" is not declared on type \"Baz\"
  Baz.gvar = 0
      ~~~~
<stdin>:33:7: error: \"gfun\" is not declared on type \"Bar\"
  Bar.gfun
      ~~~~
")

test("
def main {
  var foo = dynamic
}
", "
<stdin>:2:20: error: Expected DOT but found NEWLINE
  var foo = dynamic
                   ^
")

test("
def main {
  var bar = dynamic.foo
}
", "
<stdin>:2:7: warning: Local variable \"bar\" is never read
  var bar = dynamic.foo
      ~~~
")

test("
class Bar : Foo {
  var y int
}

class Foo {
  var x int
}

def main {
  Bar.new(0, 1) # This used to fail when Bar came before Foo since Foo.new wasn't initialized first and so had no arguments
}
", "
")

test("
enum Foo {
  FOO
  BAR
}

def main {
  if Foo.FOO in [.FOO, .BAR] {}
  if .FOO in [Foo.FOO, Foo.BAR] {}
}
", "
")

test("
def main {
  var a = [.FOO, .BAR]
  var b = [Foo.FOO, .BAR]
  var c = [.FOO, Foo.BAR]
  var d = [Foo.FOO, Foo.BAR]
}

enum Foo {
  FOO
  BAR
}
", "
<stdin>:2:12: error: Cannot access \"FOO\" without type context
  var a = [.FOO, .BAR]
           ~~~~
<stdin>:2:18: error: Cannot access \"BAR\" without type context
  var a = [.FOO, .BAR]
                 ~~~~
<stdin>:2:7: warning: Local variable \"a\" is never read
  var a = [.FOO, .BAR]
      ^
<stdin>:3:7: warning: Local variable \"b\" is never read
  var b = [Foo.FOO, .BAR]
      ^
<stdin>:4:7: warning: Local variable \"c\" is never read
  var c = [.FOO, Foo.BAR]
      ^
<stdin>:5:7: warning: Local variable \"d\" is never read
  var d = [Foo.FOO, Foo.BAR]
      ^
")

test("
def main(x int) {
  switch x {
    case 0 { var foo = 0 }
    case 1 { var foo = false }
  }
}
", "
<stdin>:3:18: warning: Local variable \"foo\" is never read
    case 0 { var foo = 0 }
                 ~~~
<stdin>:4:18: warning: Local variable \"foo\" is never read
    case 1 { var foo = false }
                 ~~~
")

# This tests a special case in the globalizing pass for super calls
test("
@import
class Foo {
  def foo {}
  def foo(x int) {}
}
class Bar : Foo {
  over foo { super }
  over foo(x int) { super(x) }
}
", "
")

test("
class Foo {
  @deprecated {
    def foo
    def bar(x int)
    def baz
    def baz(x int)
  }
}

def main(foo Foo) {
  foo.foo
  foo.bar(0)
  foo.baz
  foo.baz(0)
}
", "
<stdin>:11:7: warning: Use of deprecated symbol \"foo\"
  foo.foo
      ~~~
<stdin>:12:7: warning: Use of deprecated symbol \"bar\"
  foo.bar(0)
      ~~~
<stdin>:13:7: warning: Use of deprecated symbol \"baz\"
  foo.baz
      ~~~
<stdin>:14:7: warning: Use of deprecated symbol \"baz\"
  foo.baz(0)
      ~~~
")

test("
class Foo {
  @deprecated {
    def +
    def +(x int)
    def -(x int)
    def -(x bool)
  }
}

def main(foo Foo) {
  +foo
  foo + 0
  foo - 0
  foo - false
}
", "
<stdin>:11:3: warning: Use of deprecated symbol \"+\"
  +foo
  ^
<stdin>:12:7: warning: Use of deprecated symbol \"+\"
  foo + 0
      ^
<stdin>:13:7: warning: Use of deprecated symbol \"-\"
  foo - 0
      ^
<stdin>:14:7: warning: Use of deprecated symbol \"-\"
  foo - false
      ^
")

test("
class Foo {
  @deprecated
  def foo {}
}

class Bar : Foo {
  over foo { super }
}
", "
<stdin>:7:14: warning: Use of deprecated symbol \"foo\"
  over foo { super }
             ~~~~~
")

test("
@deprecated
class Foo {}

def main {
  Foo.new
}
", "
<stdin>:5:3: warning: Use of deprecated symbol \"Foo\"
  Foo.new
  ~~~
")

test("
class Foo {
  def ++
}

def main(x Foo) {
  var foo = ++x
  var bar = x++
}
", "
<stdin>:6:13: error: The function \"++\" does not return a value
  var foo = ++x
            ~~~
<stdin>:2:7: note: The function declaration is here
  def ++
      ~~
<stdin>:7:13: error: The function \"++\" does not return a value
  var bar = x++
            ~~~
<stdin>:2:7: note: The function declaration is here
  def ++
      ~~
<stdin>:6:7: warning: Local variable \"foo\" is never read
  var foo = ++x
      ~~~
<stdin>:7:7: warning: Local variable \"bar\" is never read
  var bar = x++
      ~~~
")

test("
def foo int {}
", "
<stdin>:1:5: error: All control paths for \"foo\" must return a value of type \"int\"
def foo int {}
    ~~~
")

test("
def foo(x bool) int {
  if x {
    return 0
  }
}
", "
<stdin>:1:5: error: All control paths for \"foo\" must return a value of type \"int\"
def foo(x bool) int {
    ~~~
")

test("
def foo(x bool) int {
  if x {
  } else {
    return 0
  }
}
", "
<stdin>:1:5: error: All control paths for \"foo\" must return a value of type \"int\"
def foo(x bool) int {
    ~~~
")

test("
def foo(x bool) int {
  if x {
    return 0
  } else {
    return 0
  }
}
", "
")

test("
def foo int {
  if false {
  }
  if true {
  }
}
", "
<stdin>:1:5: error: All control paths for \"foo\" must return a value of type \"int\"
def foo int {
    ~~~
")


test("
def foo int {
  if true {
    return 0
  }
}
", "
")

test("
def foo int {
  if false {
  } else {
    return 0
  }
}
", "
")

test("
def foo int {
  while true {}
}
", "
")

test("
def foo int {
  while true {
    return 0
  }
}
", "
")

test("
def foo int {
  while true {
    break
  }
}
", "
<stdin>:1:5: error: All control paths for \"foo\" must return a value of type \"int\"
def foo int {
    ~~~
")

test("
def foo int {
  for i = 0; true; i = i + 1 {}
}
", "
")

test("
def foo int {
  for i = 0; true; i = i + 1 {
    return 0
  }
}
", "
")

test("
def foo int {
  for i = 0; true; i = i + 1 {
    break
  }
}
", "
<stdin>:1:5: error: All control paths for \"foo\" must return a value of type \"int\"
def foo int {
    ~~~
")

test("
def foo int {
  switch dynamic.bar {
    case 0 { return 0 }
    default { return 0 }
  }
}
", "
")

test("
def foo int {
  switch dynamic.bar {
    case 0 { return 0 }
    default {}
  }
}
", "
<stdin>:1:5: error: All control paths for \"foo\" must return a value of type \"int\"
def foo int {
    ~~~
")

test("
def foo int {
  switch dynamic.bar {
    case 0 { return 0 }
  }
}
", "
<stdin>:1:5: error: All control paths for \"foo\" must return a value of type \"int\"
def foo int {
    ~~~
")

test("
def main {
  0--
  0 += 1
  [1][2]=3
}
", "
<stdin>:2:3: error: Cannot store to this location
  0--
  ^
<stdin>:3:3: error: Cannot store to this location
  0 += 1
  ^
")

test("
class Foo {
  class Bar {
    def foo Foo
    def bar Bar
  }
}
", "
")

test("
var a = [
  # comment
]
var b = [
  100
  # comment
]
var c = [
  # comment
  100
]
var d = [
  100,
  # comment
]
var e = [
  # comment
  100,
]
var f = [
  # comment
  100,
  # comment
]
var g = [
  100,
  # comment
  100,
]
", "
<stdin>:1:9: error: Cannot infer a type for this literal
var a = [
        ^
")

test("
def main {
  try {}
  catch x dynamic {}
  catch x dynamic {}
}
", "
")

test("
if true {
  if true {
    var foo = false
  }
}

def main int {
  return foo
}
", "
<stdin>:8:10: error: Cannot convert from type \"bool\" to type \"int\" without a cast
  return foo
         ~~~
")

test("
if true {
  if false {
  } else {
    var foo = false
  }
}

def main int {
  return foo
}
", "
<stdin>:9:10: error: Cannot convert from type \"bool\" to type \"int\" without a cast
  return foo
         ~~~
")

test("
if true {
  if false {
    var foo = 0.0
  }

  else {
    var foo = false
  }
}

def main int {
  return foo
}
", "
<stdin>:12:10: error: Cannot convert from type \"bool\" to type \"int\" without a cast
  return foo
         ~~~
")

test("
if true {
  if false {
    var foo = 0.0
  } else if true {
    var foo = false
  }
}

def main int {
  return foo
}
", "
<stdin>:10:10: error: Cannot convert from type \"bool\" to type \"int\" without a cast
  return foo
         ~~~
")

test("
if true {
  if false {
    var foo = 0.0
  } else if false {
    var foo = \"\"
  } else {
    var foo = false
  }
}

def main int {
  return foo
}
", "
<stdin>:12:10: error: Cannot convert from type \"bool\" to type \"int\" without a cast
  return foo
         ~~~
")

test("
class Foo {
  def foo
}

def main {
  Foo.new
}
", "
<stdin>:6:3: error: Cannot construct abstract type \"Foo\"
  Foo.new
  ~~~~~~~
<stdin>:2:7: note: The type \"Foo\" is abstract due to member \"foo\"
  def foo
      ~~~
")

test("
class Foo {
  def foo
}

class Bar : Foo {
}

def main {
  Bar.new
}
", "
<stdin>:9:3: error: Cannot construct abstract type \"Bar\"
  Bar.new
  ~~~~~~~
<stdin>:2:7: note: The type \"Bar\" is abstract due to member \"foo\"
  def foo
      ~~~
")

test("
class Foo {
  def foo
}

class Bar : Foo {
}

class Baz : Foo {
}

def main {
  Baz.new
}
", "
<stdin>:12:3: error: Cannot construct abstract type \"Baz\"
  Baz.new
  ~~~~~~~
<stdin>:2:7: note: The type \"Baz\" is abstract due to member \"foo\"
  def foo
      ~~~
")

test("
class Foo {
  def foo
}

class Bar : Foo {
  def foo(x int)
}

class Baz : Bar {
}

def main {
  Baz.new
}
", "
<stdin>:13:3: error: Cannot construct abstract type \"Baz\"
  Baz.new
  ~~~~~~~
<stdin>:6:7: note: The type \"Baz\" is abstract due to member \"foo\"
  def foo(x int)
      ~~~
")

test("
class Foo {
  def foo
}

class Bar : Foo {
  def foo(x int) {}
}

class Baz : Bar {
}

def main {
  Baz.new
}
", "
<stdin>:13:3: error: Cannot construct abstract type \"Baz\"
  Baz.new
  ~~~~~~~
<stdin>:2:7: note: The type \"Baz\" is abstract due to member \"foo\"
  def foo
      ~~~
")

test("
class Foo {
  def foo {}
}

class Bar : Foo {
  def foo(x int)
}

class Baz : Bar {
}

def main {
  Baz.new
}
", "
<stdin>:13:3: error: Cannot construct abstract type \"Baz\"
  Baz.new
  ~~~~~~~
<stdin>:6:7: note: The type \"Baz\" is abstract due to member \"foo\"
  def foo(x int)
      ~~~
")

test("
class Foo {
  def foo
}

class Bar : Foo {
  over foo {}
}

def main {
  Bar.new
}
", "
")

test("
class Foo {
}

class Bar : Foo {
  def foo
}

def main {
  Foo.new
}
", "
")

test("
class Foo {
}

class Bar : Foo {
  def foo
}

def main {
  Bar.new
}
", "
<stdin>:9:3: error: Cannot construct abstract type \"Bar\"
  Bar.new
  ~~~~~~~
<stdin>:5:7: note: The type \"Bar\" is abstract due to member \"foo\"
  def foo
      ~~~
")

test("
class Foo<T> {
  def foo T {
    var bar T
    return bar
  }
}
", "
<stdin>:3:9: error: Cannot construct a default value of type \"T\"
    var bar T
        ~~~
")

test("
def main {
  List<bool>.new.sort((a, b) => a <=> b)
  List<int>.new.sort((a, b) => a <=> b)
  List<double>.new.sort((a, b) => a <=> b)
  List<string>.new.sort((a, b) => a <=> b)
}
", "
<stdin>:2:35: error: \"<=>\" is not declared on type \"bool\"
  List<bool>.new.sort((a, b) => a <=> b)
                                  ~~~
")

test("
def foo fn() { return null }
def bar {}

def main {
  foo()
  (foo)()
  bar()
  bar
}
", "
<stdin>:5:3: error: Wrap calls to the function \"foo\" in parentheses to call the returned lambda
  foo()
  ~~~
<stdin>:1:5: note: The function declaration is here
def foo fn() { return null }
    ~~~
<stdin>:7:6: error: Cannot call the value returned from the function \"bar\" (this function was called automatically because it takes no arguments)
  bar()
     ~~
<stdin>:2:5: note: The function declaration is here
def bar {}
    ~~~
")

test("
def main {
  ((a, b) => a + b)(1, false)
}
", "
<stdin>:2:18: error: Cannot convert from type \"bool\" to type \"int\" without a cast
  ((a, b) => a + b)(1, false)
                 ^
")

test("
class Foo {
  def foo=(x int) {}
}

def main {
  Foo.new.foo = false
}
", "
<stdin>:6:17: error: Cannot convert from type \"bool\" to type \"int\" without a cast
  Foo.new.foo = false
                ~~~~~
")

# Make sure the uncalled function error doesn't trigger for overloaded setter calls
test("
class Foo {
  def foo=(x int) {}
  def foo=(x double) {}
}

def main {
  Foo.new.foo = 0
}
", "
")

test("
def main {
  for i = 0, b = false; true; 0, 1 {}
}
", "
<stdin>:2:14: error: Expected loop variable \"b\" to be of type \"int\" instead of type \"bool\"
  for i = 0, b = false; true; 0, 1 {}
             ^
<stdin>:2:31: warning: Unused expression
  for i = 0, b = false; true; 0, 1 {}
                              ^
<stdin>:2:34: warning: Unused expression
  for i = 0, b = false; true; 0, 1 {}
                                 ^
<stdin>:2:7: warning: Local variable \"i\" is never read
  for i = 0, b = false; true; 0, 1 {}
      ^
<stdin>:2:14: warning: Local variable \"b\" is never read
  for i = 0, b = false; true; 0, 1 {}
             ^
")

test("
type Foo = int
type Foo = int
type Foo : int {}
", "
<stdin>:2:12: error: \"Foo\" already has a base type
type Foo = int
           ~~~
<stdin>:1:12: note: The previous base type is here
type Foo = int
           ~~~
<stdin>:3:12: error: \"Foo\" already has a base type
type Foo : int {}
           ~~~
<stdin>:1:12: note: The previous base type is here
type Foo = int
           ~~~
")

test("
class Foo {
  def foo {}
}

type Bar = Foo

type Bar {
  def bar
}

type Baz : Foo {
  def bar
}

def main {
  var foo = Foo.new
  var bar = foo as Bar
  var baz = foo as Baz
  foo.foo
  foo.bar
  bar.foo
  bar.bar
  baz.foo
  baz.bar
}
", "
<stdin>:20:7: error: \"bar\" is not declared on type \"Foo\"
  foo.bar
      ~~~
<stdin>:21:7: error: \"foo\" is not declared on type \"Bar\"
  bar.foo
      ~~~
<stdin>:23:7: error: \"foo\" is not declared on type \"Baz\"
  baz.foo
      ~~~
")

test("
type Foo {
}
", "
<stdin>:1:6: error: Missing base type for wrapped type \"Foo\"
type Foo {
     ~~~
")

test("
class Foo : Bar {}
type Bar = int
", "
<stdin>:1:13: error: Cannot extend type \"Bar\"
class Foo : Bar {}
            ~~~
")

test("
var foo int
type Foo = fn()
type Bar = foo
type Baz = dynamic
type Bat = Foo

def main {
  var foo Foo = => {}
  var foo2 Foo = => {} as Foo
  var bat Bat = foo
  var bat2 Bat = foo as Bat
}
", "
<stdin>:3:12: error: Unexpected expression of type \"int\"
type Bar = foo
           ~~~
<stdin>:8:17: error: Cannot convert from type \"fn()\" to type \"Foo\" without a cast
  var foo Foo = => {}
                ~~~~~
<stdin>:10:17: error: Cannot convert from type \"Foo\" to type \"Bat\" without a cast
  var bat Bat = foo
                ~~~
<stdin>:9:7: warning: Local variable \"foo2\" is never read
  var foo2 Foo = => {} as Foo
      ~~~~
<stdin>:10:7: warning: Local variable \"bat\" is never read
  var bat Bat = foo
      ~~~
<stdin>:11:7: warning: Local variable \"bat2\" is never read
  var bat2 Bat = foo as Bat
      ~~~~
")

test("
type Foo : int {
  var foo
  def bar
  def new
}

namespace Foo {
  var foo2
  def bar2
}
", "
<stdin>:2:3: error: Cannot use this declaration here
  var foo
  ~~~~~~~
<stdin>:4:3: error: Cannot use this declaration here
  def new
  ~~~~~~~
")

test("
class Foo<T> {
}

class Bar<T> : Foo<T> {
}

def main {
  var foo = Foo<int>.new
  var bar = foo as Bar<bool>
  var baz = foo as Bar<int>
  var bat = bar as Bar<int>
}
", "
<stdin>:9:13: error: Cannot convert from type \"Foo<int>\" to type \"Bar<bool>\"
  var bar = foo as Bar<bool>
            ~~~
<stdin>:11:13: error: Cannot convert from type \"Bar<bool>\" to type \"Bar<int>\"
  var bat = bar as Bar<int>
            ~~~
<stdin>:10:7: warning: Local variable \"baz\" is never read
  var baz = foo as Bar<int>
      ~~~
<stdin>:11:7: warning: Local variable \"bat\" is never read
  var bat = bar as Bar<int>
      ~~~
")

test("
class Foo<T> {
}

type Bar<T> : Foo<T> {
}

def main {
  var foo = Foo<int>.new
  var bar = foo as Bar<bool>
  var baz = foo as Bar<int>
  var bat = bar as Bar<int>
}
", "
<stdin>:9:13: error: Cannot convert from type \"Foo<int>\" to type \"Bar<bool>\"
  var bar = foo as Bar<bool>
            ~~~
<stdin>:11:13: error: Cannot convert from type \"Bar<bool>\" to type \"Bar<int>\"
  var bat = bar as Bar<int>
            ~~~
<stdin>:10:7: warning: Local variable \"baz\" is never read
  var baz = foo as Bar<int>
      ~~~
<stdin>:11:7: warning: Local variable \"bat\" is never read
  var bat = bar as Bar<int>
      ~~~
")

test("
type Foo = Bar
type Bar = Foo
", "
<stdin>:1:6: error: Cyclic declaration of \"Foo\"
type Foo = Bar
     ~~~
")

test("
type Foo {}

def main {
  var foo = 0 as Foo
}
", "
<stdin>:1:6: error: Missing base type for wrapped type \"Foo\"
type Foo {}
     ~~~
<stdin>:4:13: error: Cannot convert from type \"int\" to type \"Foo\"
  var foo = 0 as Foo
            ^
<stdin>:4:7: warning: Local variable \"foo\" is never read
  var foo = 0 as Foo
      ~~~
")

test("
type Foo : List<int> {
  def +=(foo int) {
    (self as List<int>).append(foo)
  }
}

namespace Foo {
  def new Foo {
    return List<int>.new as Foo
  }
}

def foo Foo {
  return Foo.new
}

def main {
  foo += 0
  foo += false
}
", "
<stdin>:19:10: error: Cannot convert from type \"bool\" to type \"int\" without a cast
  foo += false
         ~~~~~
")

test("
class Foo :: Baz {}
class Bar : Foo {}
interface Baz {}

@export
def main {
  dynamic.foo(Foo.new is dynamic)
  dynamic.foo(Foo.new is dynamic.Test)
  dynamic.foo(Foo.new is Foo)
  dynamic.foo(Foo.new is Bar)
  dynamic.foo(Foo.new is Baz)
  dynamic.foo(Bar.new is Foo)
  dynamic.foo(Bar.new is Bar)
  dynamic.foo(Bar.new is Baz)
}
", "
<stdin>:7:23: warning: Unnecessary type check, type \"Foo\" is always type \"dynamic\"
  dynamic.foo(Foo.new is dynamic)
                      ~~~~~~~~~~
<stdin>:9:23: warning: Unnecessary type check, type \"Foo\" is always type \"Foo\"
  dynamic.foo(Foo.new is Foo)
                      ~~~~~~
<stdin>:11:26: error: Cannot check against interface type \"Baz\"
  dynamic.foo(Foo.new is Baz)
                         ~~~
<stdin>:12:23: warning: Unnecessary type check, type \"Bar\" is always type \"Foo\"
  dynamic.foo(Bar.new is Foo)
                      ~~~~~~
<stdin>:13:23: warning: Unnecessary type check, type \"Bar\" is always type \"Bar\"
  dynamic.foo(Bar.new is Bar)
                      ~~~~~~
<stdin>:14:26: error: Cannot check against interface type \"Baz\"
  dynamic.foo(Bar.new is Baz)
                         ~~~
")

test("
var a Bool = null
var b Int = null
var c Double = null
var d String = null
var e Bar = null

type Bool = bool
type Int = int
type Double = double
type String = string
type Bar = Foo
enum Foo {}
", "
<stdin>:1:14: error: Cannot convert from type \"null\" to type \"Bool\"
var a Bool = null
             ~~~~
<stdin>:2:13: error: Cannot convert from type \"null\" to type \"Int\"
var b Int = null
            ~~~~
<stdin>:3:16: error: Cannot convert from type \"null\" to type \"Double\"
var c Double = null
               ~~~~
<stdin>:5:13: error: Cannot convert from type \"null\" to type \"Bar\"
var e Bar = null
            ~~~~
")

test("
interface I {}
class C :: I {}
interface I2 :: I {}
namespace N :: I {}
type T : C :: I {}
enum E :: I {}
", "
<stdin>:3:17: error: Cannot implement type \"I\"
interface I2 :: I {}
                ^
<stdin>:4:16: error: Cannot implement type \"I\"
namespace N :: I {}
               ^
<stdin>:5:15: error: Cannot implement type \"I\"
type T : C :: I {}
              ^
<stdin>:6:11: error: Cannot implement type \"I\"
enum E :: I {}
          ^
")

test("
interface I {}
class C :: I, I2, I, I2 {}
interface I2 {}
", "
<stdin>:2:19: error: Duplicate implemented type \"I\"
class C :: I, I2, I, I2 {}
                  ^
<stdin>:2:12: note: The first occurrence is here
class C :: I, I2, I, I2 {}
           ^
<stdin>:2:22: error: Duplicate implemented type \"I2\"
class C :: I, I2, I, I2 {}
                     ~~
<stdin>:2:15: note: The first occurrence is here
class C :: I, I2, I, I2 {}
              ~~
")

test("
class Foo :: IFoo {}
interface IFoo {}
interface IBar {}

def main(foo Foo, ifoo IFoo, ibar IBar) {
  foo = ifoo
  foo = ibar
  ifoo = foo
  ifoo = ibar
  ibar = foo
  ibar = ifoo
}
", "
<stdin>:6:9: error: Cannot convert from type \"IFoo\" to type \"Foo\" without a cast
  foo = ifoo
        ~~~~
<stdin>:7:9: error: Cannot convert from type \"IBar\" to type \"Foo\"
  foo = ibar
        ~~~~
<stdin>:9:10: error: Cannot convert from type \"IBar\" to type \"IFoo\"
  ifoo = ibar
         ~~~~
<stdin>:10:10: error: Cannot convert from type \"Foo\" to type \"IBar\"
  ibar = foo
         ~~~
<stdin>:11:10: error: Cannot convert from type \"IFoo\" to type \"IBar\"
  ibar = ifoo
         ~~~~
")

test("
class Foo :: IFoo<int> {}
interface IFoo<T> {}

def main(foo Foo, ifoo_int IFoo<int>, ifoo_bool IFoo<bool>) {
  foo = ifoo_int
  foo = ifoo_bool
  ifoo_int = foo
  ifoo_int = ifoo_bool
  ifoo_bool = foo
  ifoo_bool = ifoo_int
}
", "
<stdin>:5:9: error: Cannot convert from type \"IFoo<int>\" to type \"Foo\" without a cast
  foo = ifoo_int
        ~~~~~~~~
<stdin>:6:9: error: Cannot convert from type \"IFoo<bool>\" to type \"Foo\"
  foo = ifoo_bool
        ~~~~~~~~~
<stdin>:8:14: error: Cannot convert from type \"IFoo<bool>\" to type \"IFoo<int>\"
  ifoo_int = ifoo_bool
             ~~~~~~~~~
<stdin>:9:15: error: Cannot convert from type \"Foo\" to type \"IFoo<bool>\"
  ifoo_bool = foo
              ~~~
<stdin>:10:15: error: Cannot convert from type \"IFoo<int>\" to type \"IFoo<bool>\"
  ifoo_bool = ifoo_int
              ~~~~~~~~
")

test("
class Foo<T> :: IFoo<T> {}
interface IFoo<T> {}

def main(foo_int Foo<int>, ifoo_int IFoo<int>, ifoo_bool IFoo<bool>) {
  foo_int = ifoo_int
  foo_int = ifoo_bool
  ifoo_int = foo_int
  ifoo_int = ifoo_bool
  ifoo_bool = foo_int
  ifoo_bool = ifoo_int
}
", "
<stdin>:5:13: error: Cannot convert from type \"IFoo<int>\" to type \"Foo<int>\" without a cast
  foo_int = ifoo_int
            ~~~~~~~~
<stdin>:6:13: error: Cannot convert from type \"IFoo<bool>\" to type \"Foo<int>\"
  foo_int = ifoo_bool
            ~~~~~~~~~
<stdin>:8:14: error: Cannot convert from type \"IFoo<bool>\" to type \"IFoo<int>\"
  ifoo_int = ifoo_bool
             ~~~~~~~~~
<stdin>:9:15: error: Cannot convert from type \"Foo<int>\" to type \"IFoo<bool>\"
  ifoo_bool = foo_int
              ~~~~~~~
<stdin>:10:15: error: Cannot convert from type \"IFoo<int>\" to type \"IFoo<bool>\"
  ifoo_bool = ifoo_int
              ~~~~~~~~
")

test("
class Foo :: IFoo {}
interface IFoo { def foo }
", "
<stdin>:1:7: error: Type \"Foo\" is missing an implementation of function \"foo\" from interface \"IFoo\"
class Foo :: IFoo {}
      ~~~
<stdin>:2:22: note: The function declaration is here
interface IFoo { def foo }
                     ~~~
")

test("
class Foo :: IFoo { def foo int }
interface IFoo { def foo bool }
", "
<stdin>:1:25: error: Function \"foo\" has a different return type than the function with the same name and argument types from interface \"IFoo\"
class Foo :: IFoo { def foo int }
                        ~~~
<stdin>:2:22: note: The function declaration is here
interface IFoo { def foo bool }
                     ~~~
")

test("
class Foo :: IFoo { var foo int }
interface IFoo { def foo bool }
", "
<stdin>:1:7: error: Type \"Foo\" is missing an implementation of function \"foo\" from interface \"IFoo\"
class Foo :: IFoo { var foo int }
      ~~~
<stdin>:2:22: note: The function declaration is here
interface IFoo { def foo bool }
                     ~~~
")

test("
class Foo {
  over foo
}
", "
<stdin>:2:8: error: \"foo\" is declared using \"over\" instead of \"def\" but does not override anything
  over foo
       ~~~
")

test("
class Foo {
  def foo
}

class Bar : Foo {
  def foo
}
", "
<stdin>:6:7: error: \"foo\" overrides another symbol with the same name but is declared using \"def\" instead of \"over\"
  def foo
      ~~~
<stdin>:2:7: note: The overridden declaration is here
  def foo
      ~~~
")

test("
class Foo {
  def new {}
}

class Bar : Foo {
  def new {}
}
", "
<stdin>:6:7: error: Constructors for derived types must start with a call to \"super\"
  def new {}
      ~~~
")

test("
class Foo {
  def new {}
}

class Bar : Foo {
  def new { super }
}
", "
")

test("
class Foo {
  def new(x int) {}
}

class Bar : Foo {
  def new { super }
}
", "
<stdin>:6:13: error: The function \"new\" must be called
  def new { super }
            ~~~~~
")

test("
class Foo {
  def new(x int) {}
}

class Bar : Foo {
  def new { super(1) }
}
", "
")

# Parser whitespace test
test("
var x = 0 ?
# Comment
1 :
# Comment
2
var y = z(
  # Comment
)
", "
<stdin>:1:9: error: Cannot convert from type \"int\" to type \"bool\" without a cast
var x = 0 ?
        ^
<stdin>:6:9: error: \"z\" is not declared
var y = z(
        ^
")

# Parser whitespace test
test("
def main {
  if 0
  {
  }
  else
  {
  }
}
", "
<stdin>:2:6: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  if 0
     ^
")

# Parser whitespace test
test("
def main(
  a int,
  b int
) int {
}
", "
<stdin>:1:5: error: All control paths for \"main\" must return a value of type \"int\"
def main(
    ~~~~
")

# Parser whitespace test
test("
var foo = a
  .b
  .c
", "
<stdin>:1:11: error: \"a\" is not declared
var foo = a
          ^
")

# Test for an operator overload resolution bug with integer promotion to double
test("
def foo(count int) {
  count + 0.0
  count += 0.0
}
", "
<stdin>:2:3: warning: Unused expression
  count + 0.0
  ~~~~~~~~~~~
<stdin>:3:12: error: Cannot convert from type \"double\" to type \"int\" without a cast
  count += 0.0
           ~~~
")

# Test for enum promotion to integer for comparison operators
test("
enum Foo {}
enum Bar {}

def foo(foo Foo, bar Bar) bool {
  return
    (foo < 0 || foo > 0 || foo <= 0 || foo >= 0 || foo == 0 || foo != 0) &&
    (0 < foo || 0 > foo || 0 <= foo || 0 >= foo || 0 == foo || 0 != foo) &&

    (foo < 0.0 || foo > 0.0 || foo <= 0.0 || foo >= 0.0 || foo == 0.0 || foo != 0.0) &&
    (0.0 < foo || 0.0 > foo || 0.0 <= foo || 0.0 >= foo || 0.0 == foo || 0.0 != foo) &&

    (foo < foo || foo > foo || foo <= foo || foo >= foo || foo == foo || foo != foo) &&
    (foo < bar || foo > bar || foo <= bar || foo >= bar || foo == bar || foo != bar) &&

    (foo < false || foo > false || foo <= false || foo >= false || foo == false || foo != false) &&
    (false < foo || false > foo || false <= foo || false >= foo || false == foo || false != foo)
}
", "
<stdin>:12:60: warning: Both sides of \"==\" are identical, is this a bug?
    (foo < foo || foo > foo || foo <= foo || foo >= foo || foo == foo || foo != foo) &&
                                                           ~~~~~~~~~~
<stdin>:12:74: warning: Both sides of \"!=\" are identical, is this a bug?
    (foo < foo || foo > foo || foo <= foo || foo >= foo || foo == foo || foo != foo) &&
                                                                         ~~~~~~~~~~
<stdin>:15:10: error: \"<=>\" is not declared on type \"Foo\"
    (foo < false || foo > false || foo <= false || foo >= false || foo == false || foo != false) &&
         ^
<stdin>:15:25: error: \"<=>\" is not declared on type \"Foo\"
    (foo < false || foo > false || foo <= false || foo >= false || foo == false || foo != false) &&
                        ^
<stdin>:15:40: error: \"<=>\" is not declared on type \"Foo\"
    (foo < false || foo > false || foo <= false || foo >= false || foo == false || foo != false) &&
                                       ~~
<stdin>:15:56: error: \"<=>\" is not declared on type \"Foo\"
    (foo < false || foo > false || foo <= false || foo >= false || foo == false || foo != false) &&
                                                       ~~
<stdin>:15:68: error: No common type for \"Foo\" and \"bool\"
    (foo < false || foo > false || foo <= false || foo >= false || foo == false || foo != false) &&
                                                                   ~~~~~~~~~~~~
<stdin>:15:84: error: No common type for \"Foo\" and \"bool\"
    (foo < false || foo > false || foo <= false || foo >= false || foo == false || foo != false) &&
                                                                                   ~~~~~~~~~~~~
<stdin>:16:12: error: \"<=>\" is not declared on type \"bool\"
    (false < foo || false > foo || false <= foo || false >= foo || false == foo || false != foo)
           ^
<stdin>:16:27: error: \"<=>\" is not declared on type \"bool\"
    (false < foo || false > foo || false <= foo || false >= foo || false == foo || false != foo)
                          ^
<stdin>:16:42: error: \"<=>\" is not declared on type \"bool\"
    (false < foo || false > foo || false <= foo || false >= foo || false == foo || false != foo)
                                         ~~
<stdin>:16:58: error: \"<=>\" is not declared on type \"bool\"
    (false < foo || false > foo || false <= foo || false >= foo || false == foo || false != foo)
                                                         ~~
<stdin>:16:68: error: No common type for \"bool\" and \"Foo\"
    (false < foo || false > foo || false <= foo || false >= foo || false == foo || false != foo)
                                                                   ~~~~~~~~~~~~
<stdin>:16:84: error: No common type for \"bool\" and \"Foo\"
    (false < foo || false > foo || false <= foo || false >= foo || false == foo || false != foo)
                                                                                   ~~~~~~~~~~~~
")

# Test for enum promotion to integer for other operators
test("
enum Foo {}
enum Bar {}

def foo(foo Foo, bar Bar) List<bool> {
  return [
    foo + 0, foo - 0, foo * 0, foo / 0, foo % 0, foo & 0, foo | 0, foo ^ 0, foo << 0, foo >> 0, foo <=> 0,
    0 + foo, 0 - foo, 0 * foo, 0 / foo, 0 % foo, 0 & foo, 0 | foo, 0 ^ foo, 0 << foo, 0 >> foo, 0 <=> foo,

    foo + 0.0, foo - 0.0, foo * 0.0, foo / 0.0, foo % 0.0, foo & 0.0, foo | 0.0, foo ^ 0.0, foo << 0.0, foo >> 0.0, foo <=> 0.0,
    0.0 + foo, 0.0 - foo, 0.0 * foo, 0.0 / foo, 0.0 % foo, 0.0 & foo, 0.0 | foo, 0.0 ^ foo, 0.0 << foo, 0.0 >> foo, 0.0 <=> foo,

    foo + foo, foo - foo, foo * foo, foo / foo, foo % foo, foo & foo, foo | foo, foo ^ foo, foo << foo, foo >> foo, foo <=> foo,
    foo + foo, foo - foo, foo * foo, foo / foo, foo % foo, foo & foo, foo | foo, foo ^ foo, foo << foo, foo >> foo, foo <=> foo,

    foo + bar, foo - bar, foo * bar, foo / bar, foo % bar, foo & bar, foo | bar, foo ^ bar, foo << bar, foo >> bar, foo <=> bar,
    bar + foo, bar - foo, bar * foo, bar / foo, bar % foo, bar & foo, bar | foo, bar ^ foo, bar << foo, bar >> foo, bar <=> foo,
  ]
}
", "
<stdin>:6:5: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + 0, foo - 0, foo * 0, foo / 0, foo % 0, foo & 0, foo | 0, foo ^ 0, foo << 0, foo >> 0, foo <=> 0,
    ~~~~~~~
<stdin>:6:14: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + 0, foo - 0, foo * 0, foo / 0, foo % 0, foo & 0, foo | 0, foo ^ 0, foo << 0, foo >> 0, foo <=> 0,
             ~~~~~~~
<stdin>:6:23: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + 0, foo - 0, foo * 0, foo / 0, foo % 0, foo & 0, foo | 0, foo ^ 0, foo << 0, foo >> 0, foo <=> 0,
                      ~~~~~~~
<stdin>:6:32: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + 0, foo - 0, foo * 0, foo / 0, foo % 0, foo & 0, foo | 0, foo ^ 0, foo << 0, foo >> 0, foo <=> 0,
                               ~~~~~~~
<stdin>:6:41: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + 0, foo - 0, foo * 0, foo / 0, foo % 0, foo & 0, foo | 0, foo ^ 0, foo << 0, foo >> 0, foo <=> 0,
                                        ~~~~~~~
<stdin>:6:50: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + 0, foo - 0, foo * 0, foo / 0, foo % 0, foo & 0, foo | 0, foo ^ 0, foo << 0, foo >> 0, foo <=> 0,
                                                 ~~~~~~~
<stdin>:6:59: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + 0, foo - 0, foo * 0, foo / 0, foo % 0, foo & 0, foo | 0, foo ^ 0, foo << 0, foo >> 0, foo <=> 0,
                                                          ~~~~~~~
<stdin>:6:68: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + 0, foo - 0, foo * 0, foo / 0, foo % 0, foo & 0, foo | 0, foo ^ 0, foo << 0, foo >> 0, foo <=> 0,
                                                                   ~~~~~~~
<stdin>:6:77: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + 0, foo - 0, foo * 0, foo / 0, foo % 0, foo & 0, foo | 0, foo ^ 0, foo << 0, foo >> 0, foo <=> 0,
                                                                            ~~~~~~~~
<stdin>:6:87: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + 0, foo - 0, foo * 0, foo / 0, foo % 0, foo & 0, foo | 0, foo ^ 0, foo << 0, foo >> 0, foo <=> 0,
                                                                                      ~~~~~~~~
<stdin>:6:97: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + 0, foo - 0, foo * 0, foo / 0, foo % 0, foo & 0, foo | 0, foo ^ 0, foo << 0, foo >> 0, foo <=> 0,
                                                                                                ~~~~~~~~~
<stdin>:7:5: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    0 + foo, 0 - foo, 0 * foo, 0 / foo, 0 % foo, 0 & foo, 0 | foo, 0 ^ foo, 0 << foo, 0 >> foo, 0 <=> foo,
    ~~~~~~~
<stdin>:7:14: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    0 + foo, 0 - foo, 0 * foo, 0 / foo, 0 % foo, 0 & foo, 0 | foo, 0 ^ foo, 0 << foo, 0 >> foo, 0 <=> foo,
             ~~~~~~~
<stdin>:7:23: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    0 + foo, 0 - foo, 0 * foo, 0 / foo, 0 % foo, 0 & foo, 0 | foo, 0 ^ foo, 0 << foo, 0 >> foo, 0 <=> foo,
                      ~~~~~~~
<stdin>:7:32: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    0 + foo, 0 - foo, 0 * foo, 0 / foo, 0 % foo, 0 & foo, 0 | foo, 0 ^ foo, 0 << foo, 0 >> foo, 0 <=> foo,
                               ~~~~~~~
<stdin>:7:41: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    0 + foo, 0 - foo, 0 * foo, 0 / foo, 0 % foo, 0 & foo, 0 | foo, 0 ^ foo, 0 << foo, 0 >> foo, 0 <=> foo,
                                        ~~~~~~~
<stdin>:7:50: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    0 + foo, 0 - foo, 0 * foo, 0 / foo, 0 % foo, 0 & foo, 0 | foo, 0 ^ foo, 0 << foo, 0 >> foo, 0 <=> foo,
                                                 ~~~~~~~
<stdin>:7:59: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    0 + foo, 0 - foo, 0 * foo, 0 / foo, 0 % foo, 0 & foo, 0 | foo, 0 ^ foo, 0 << foo, 0 >> foo, 0 <=> foo,
                                                          ~~~~~~~
<stdin>:7:68: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    0 + foo, 0 - foo, 0 * foo, 0 / foo, 0 % foo, 0 & foo, 0 | foo, 0 ^ foo, 0 << foo, 0 >> foo, 0 <=> foo,
                                                                   ~~~~~~~
<stdin>:7:77: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    0 + foo, 0 - foo, 0 * foo, 0 / foo, 0 % foo, 0 & foo, 0 | foo, 0 ^ foo, 0 << foo, 0 >> foo, 0 <=> foo,
                                                                            ~~~~~~~~
<stdin>:7:87: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    0 + foo, 0 - foo, 0 * foo, 0 / foo, 0 % foo, 0 & foo, 0 | foo, 0 ^ foo, 0 << foo, 0 >> foo, 0 <=> foo,
                                                                                      ~~~~~~~~
<stdin>:7:97: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    0 + foo, 0 - foo, 0 * foo, 0 / foo, 0 % foo, 0 & foo, 0 | foo, 0 ^ foo, 0 << foo, 0 >> foo, 0 <=> foo,
                                                                                                ~~~~~~~~~
<stdin>:9:5: error: Cannot convert from type \"double\" to type \"bool\" without a cast
    foo + 0.0, foo - 0.0, foo * 0.0, foo / 0.0, foo % 0.0, foo & 0.0, foo | 0.0, foo ^ 0.0, foo << 0.0, foo >> 0.0, foo <=> 0.0,
    ~~~~~~~~~
<stdin>:9:16: error: Cannot convert from type \"double\" to type \"bool\" without a cast
    foo + 0.0, foo - 0.0, foo * 0.0, foo / 0.0, foo % 0.0, foo & 0.0, foo | 0.0, foo ^ 0.0, foo << 0.0, foo >> 0.0, foo <=> 0.0,
               ~~~~~~~~~
<stdin>:9:27: error: Cannot convert from type \"double\" to type \"bool\" without a cast
    foo + 0.0, foo - 0.0, foo * 0.0, foo / 0.0, foo % 0.0, foo & 0.0, foo | 0.0, foo ^ 0.0, foo << 0.0, foo >> 0.0, foo <=> 0.0,
                          ~~~~~~~~~
<stdin>:9:38: error: Cannot convert from type \"double\" to type \"bool\" without a cast
    foo + 0.0, foo - 0.0, foo * 0.0, foo / 0.0, foo % 0.0, foo & 0.0, foo | 0.0, foo ^ 0.0, foo << 0.0, foo >> 0.0, foo <=> 0.0,
                                     ~~~~~~~~~
<stdin>:9:53: error: \"%\" is not declared on type \"double\"
    foo + 0.0, foo - 0.0, foo * 0.0, foo / 0.0, foo % 0.0, foo & 0.0, foo | 0.0, foo ^ 0.0, foo << 0.0, foo >> 0.0, foo <=> 0.0,
                                                    ^
<stdin>:9:64: error: \"&\" is not declared on type \"double\"
    foo + 0.0, foo - 0.0, foo * 0.0, foo / 0.0, foo % 0.0, foo & 0.0, foo | 0.0, foo ^ 0.0, foo << 0.0, foo >> 0.0, foo <=> 0.0,
                                                               ^
<stdin>:9:75: error: \"|\" is not declared on type \"double\"
    foo + 0.0, foo - 0.0, foo * 0.0, foo / 0.0, foo % 0.0, foo & 0.0, foo | 0.0, foo ^ 0.0, foo << 0.0, foo >> 0.0, foo <=> 0.0,
                                                                          ^
<stdin>:9:86: error: \"^\" is not declared on type \"double\"
    foo + 0.0, foo - 0.0, foo * 0.0, foo / 0.0, foo % 0.0, foo & 0.0, foo | 0.0, foo ^ 0.0, foo << 0.0, foo >> 0.0, foo <=> 0.0,
                                                                                     ^
<stdin>:9:97: error: \"<<\" is not declared on type \"double\"
    foo + 0.0, foo - 0.0, foo * 0.0, foo / 0.0, foo % 0.0, foo & 0.0, foo | 0.0, foo ^ 0.0, foo << 0.0, foo >> 0.0, foo <=> 0.0,
                                                                                                ~~
<stdin>:9:109: error: \">>\" is not declared on type \"double\"
    foo + 0.0, foo - 0.0, foo * 0.0, foo / 0.0, foo % 0.0, foo & 0.0, foo | 0.0, foo ^ 0.0, foo << 0.0, foo >> 0.0, foo <=> 0.0,
                                                                                                            ~~
<stdin>:9:117: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + 0.0, foo - 0.0, foo * 0.0, foo / 0.0, foo % 0.0, foo & 0.0, foo | 0.0, foo ^ 0.0, foo << 0.0, foo >> 0.0, foo <=> 0.0,
                                                                                                                    ~~~~~~~~~~~
<stdin>:10:5: error: Cannot convert from type \"double\" to type \"bool\" without a cast
    0.0 + foo, 0.0 - foo, 0.0 * foo, 0.0 / foo, 0.0 % foo, 0.0 & foo, 0.0 | foo, 0.0 ^ foo, 0.0 << foo, 0.0 >> foo, 0.0 <=> foo,
    ~~~~~~~~~
<stdin>:10:16: error: Cannot convert from type \"double\" to type \"bool\" without a cast
    0.0 + foo, 0.0 - foo, 0.0 * foo, 0.0 / foo, 0.0 % foo, 0.0 & foo, 0.0 | foo, 0.0 ^ foo, 0.0 << foo, 0.0 >> foo, 0.0 <=> foo,
               ~~~~~~~~~
<stdin>:10:27: error: Cannot convert from type \"double\" to type \"bool\" without a cast
    0.0 + foo, 0.0 - foo, 0.0 * foo, 0.0 / foo, 0.0 % foo, 0.0 & foo, 0.0 | foo, 0.0 ^ foo, 0.0 << foo, 0.0 >> foo, 0.0 <=> foo,
                          ~~~~~~~~~
<stdin>:10:38: error: Cannot convert from type \"double\" to type \"bool\" without a cast
    0.0 + foo, 0.0 - foo, 0.0 * foo, 0.0 / foo, 0.0 % foo, 0.0 & foo, 0.0 | foo, 0.0 ^ foo, 0.0 << foo, 0.0 >> foo, 0.0 <=> foo,
                                     ~~~~~~~~~
<stdin>:10:53: error: \"%\" is not declared on type \"double\"
    0.0 + foo, 0.0 - foo, 0.0 * foo, 0.0 / foo, 0.0 % foo, 0.0 & foo, 0.0 | foo, 0.0 ^ foo, 0.0 << foo, 0.0 >> foo, 0.0 <=> foo,
                                                    ^
<stdin>:10:64: error: \"&\" is not declared on type \"double\"
    0.0 + foo, 0.0 - foo, 0.0 * foo, 0.0 / foo, 0.0 % foo, 0.0 & foo, 0.0 | foo, 0.0 ^ foo, 0.0 << foo, 0.0 >> foo, 0.0 <=> foo,
                                                               ^
<stdin>:10:75: error: \"|\" is not declared on type \"double\"
    0.0 + foo, 0.0 - foo, 0.0 * foo, 0.0 / foo, 0.0 % foo, 0.0 & foo, 0.0 | foo, 0.0 ^ foo, 0.0 << foo, 0.0 >> foo, 0.0 <=> foo,
                                                                          ^
<stdin>:10:86: error: \"^\" is not declared on type \"double\"
    0.0 + foo, 0.0 - foo, 0.0 * foo, 0.0 / foo, 0.0 % foo, 0.0 & foo, 0.0 | foo, 0.0 ^ foo, 0.0 << foo, 0.0 >> foo, 0.0 <=> foo,
                                                                                     ^
<stdin>:10:97: error: \"<<\" is not declared on type \"double\"
    0.0 + foo, 0.0 - foo, 0.0 * foo, 0.0 / foo, 0.0 % foo, 0.0 & foo, 0.0 | foo, 0.0 ^ foo, 0.0 << foo, 0.0 >> foo, 0.0 <=> foo,
                                                                                                ~~
<stdin>:10:109: error: \">>\" is not declared on type \"double\"
    0.0 + foo, 0.0 - foo, 0.0 * foo, 0.0 / foo, 0.0 % foo, 0.0 & foo, 0.0 | foo, 0.0 ^ foo, 0.0 << foo, 0.0 >> foo, 0.0 <=> foo,
                                                                                                            ~~
<stdin>:10:117: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    0.0 + foo, 0.0 - foo, 0.0 * foo, 0.0 / foo, 0.0 % foo, 0.0 & foo, 0.0 | foo, 0.0 ^ foo, 0.0 << foo, 0.0 >> foo, 0.0 <=> foo,
                                                                                                                    ~~~~~~~~~~~
<stdin>:12:5: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + foo, foo - foo, foo * foo, foo / foo, foo % foo, foo & foo, foo | foo, foo ^ foo, foo << foo, foo >> foo, foo <=> foo,
    ~~~~~~~~~
<stdin>:12:16: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + foo, foo - foo, foo * foo, foo / foo, foo % foo, foo & foo, foo | foo, foo ^ foo, foo << foo, foo >> foo, foo <=> foo,
               ~~~~~~~~~
<stdin>:12:27: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + foo, foo - foo, foo * foo, foo / foo, foo % foo, foo & foo, foo | foo, foo ^ foo, foo << foo, foo >> foo, foo <=> foo,
                          ~~~~~~~~~
<stdin>:12:38: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + foo, foo - foo, foo * foo, foo / foo, foo % foo, foo & foo, foo | foo, foo ^ foo, foo << foo, foo >> foo, foo <=> foo,
                                     ~~~~~~~~~
<stdin>:12:49: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + foo, foo - foo, foo * foo, foo / foo, foo % foo, foo & foo, foo | foo, foo ^ foo, foo << foo, foo >> foo, foo <=> foo,
                                                ~~~~~~~~~
<stdin>:12:60: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + foo, foo - foo, foo * foo, foo / foo, foo % foo, foo & foo, foo | foo, foo ^ foo, foo << foo, foo >> foo, foo <=> foo,
                                                           ~~~~~~~~~
<stdin>:12:71: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + foo, foo - foo, foo * foo, foo / foo, foo % foo, foo & foo, foo | foo, foo ^ foo, foo << foo, foo >> foo, foo <=> foo,
                                                                      ~~~~~~~~~
<stdin>:12:82: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + foo, foo - foo, foo * foo, foo / foo, foo % foo, foo & foo, foo | foo, foo ^ foo, foo << foo, foo >> foo, foo <=> foo,
                                                                                 ~~~~~~~~~
<stdin>:12:93: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + foo, foo - foo, foo * foo, foo / foo, foo % foo, foo & foo, foo | foo, foo ^ foo, foo << foo, foo >> foo, foo <=> foo,
                                                                                            ~~~~~~~~~~
<stdin>:12:105: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + foo, foo - foo, foo * foo, foo / foo, foo % foo, foo & foo, foo | foo, foo ^ foo, foo << foo, foo >> foo, foo <=> foo,
                                                                                                        ~~~~~~~~~~
<stdin>:12:117: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + foo, foo - foo, foo * foo, foo / foo, foo % foo, foo & foo, foo | foo, foo ^ foo, foo << foo, foo >> foo, foo <=> foo,
                                                                                                                    ~~~~~~~~~~~
<stdin>:13:5: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + foo, foo - foo, foo * foo, foo / foo, foo % foo, foo & foo, foo | foo, foo ^ foo, foo << foo, foo >> foo, foo <=> foo,
    ~~~~~~~~~
<stdin>:13:16: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + foo, foo - foo, foo * foo, foo / foo, foo % foo, foo & foo, foo | foo, foo ^ foo, foo << foo, foo >> foo, foo <=> foo,
               ~~~~~~~~~
<stdin>:13:27: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + foo, foo - foo, foo * foo, foo / foo, foo % foo, foo & foo, foo | foo, foo ^ foo, foo << foo, foo >> foo, foo <=> foo,
                          ~~~~~~~~~
<stdin>:13:38: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + foo, foo - foo, foo * foo, foo / foo, foo % foo, foo & foo, foo | foo, foo ^ foo, foo << foo, foo >> foo, foo <=> foo,
                                     ~~~~~~~~~
<stdin>:13:49: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + foo, foo - foo, foo * foo, foo / foo, foo % foo, foo & foo, foo | foo, foo ^ foo, foo << foo, foo >> foo, foo <=> foo,
                                                ~~~~~~~~~
<stdin>:13:60: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + foo, foo - foo, foo * foo, foo / foo, foo % foo, foo & foo, foo | foo, foo ^ foo, foo << foo, foo >> foo, foo <=> foo,
                                                           ~~~~~~~~~
<stdin>:13:71: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + foo, foo - foo, foo * foo, foo / foo, foo % foo, foo & foo, foo | foo, foo ^ foo, foo << foo, foo >> foo, foo <=> foo,
                                                                      ~~~~~~~~~
<stdin>:13:82: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + foo, foo - foo, foo * foo, foo / foo, foo % foo, foo & foo, foo | foo, foo ^ foo, foo << foo, foo >> foo, foo <=> foo,
                                                                                 ~~~~~~~~~
<stdin>:13:93: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + foo, foo - foo, foo * foo, foo / foo, foo % foo, foo & foo, foo | foo, foo ^ foo, foo << foo, foo >> foo, foo <=> foo,
                                                                                            ~~~~~~~~~~
<stdin>:13:105: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + foo, foo - foo, foo * foo, foo / foo, foo % foo, foo & foo, foo | foo, foo ^ foo, foo << foo, foo >> foo, foo <=> foo,
                                                                                                        ~~~~~~~~~~
<stdin>:13:117: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + foo, foo - foo, foo * foo, foo / foo, foo % foo, foo & foo, foo | foo, foo ^ foo, foo << foo, foo >> foo, foo <=> foo,
                                                                                                                    ~~~~~~~~~~~
<stdin>:15:5: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + bar, foo - bar, foo * bar, foo / bar, foo % bar, foo & bar, foo | bar, foo ^ bar, foo << bar, foo >> bar, foo <=> bar,
    ~~~~~~~~~
<stdin>:15:16: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + bar, foo - bar, foo * bar, foo / bar, foo % bar, foo & bar, foo | bar, foo ^ bar, foo << bar, foo >> bar, foo <=> bar,
               ~~~~~~~~~
<stdin>:15:27: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + bar, foo - bar, foo * bar, foo / bar, foo % bar, foo & bar, foo | bar, foo ^ bar, foo << bar, foo >> bar, foo <=> bar,
                          ~~~~~~~~~
<stdin>:15:38: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + bar, foo - bar, foo * bar, foo / bar, foo % bar, foo & bar, foo | bar, foo ^ bar, foo << bar, foo >> bar, foo <=> bar,
                                     ~~~~~~~~~
<stdin>:15:49: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + bar, foo - bar, foo * bar, foo / bar, foo % bar, foo & bar, foo | bar, foo ^ bar, foo << bar, foo >> bar, foo <=> bar,
                                                ~~~~~~~~~
<stdin>:15:60: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + bar, foo - bar, foo * bar, foo / bar, foo % bar, foo & bar, foo | bar, foo ^ bar, foo << bar, foo >> bar, foo <=> bar,
                                                           ~~~~~~~~~
<stdin>:15:71: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + bar, foo - bar, foo * bar, foo / bar, foo % bar, foo & bar, foo | bar, foo ^ bar, foo << bar, foo >> bar, foo <=> bar,
                                                                      ~~~~~~~~~
<stdin>:15:82: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + bar, foo - bar, foo * bar, foo / bar, foo % bar, foo & bar, foo | bar, foo ^ bar, foo << bar, foo >> bar, foo <=> bar,
                                                                                 ~~~~~~~~~
<stdin>:15:93: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + bar, foo - bar, foo * bar, foo / bar, foo % bar, foo & bar, foo | bar, foo ^ bar, foo << bar, foo >> bar, foo <=> bar,
                                                                                            ~~~~~~~~~~
<stdin>:15:105: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + bar, foo - bar, foo * bar, foo / bar, foo % bar, foo & bar, foo | bar, foo ^ bar, foo << bar, foo >> bar, foo <=> bar,
                                                                                                        ~~~~~~~~~~
<stdin>:15:117: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    foo + bar, foo - bar, foo * bar, foo / bar, foo % bar, foo & bar, foo | bar, foo ^ bar, foo << bar, foo >> bar, foo <=> bar,
                                                                                                                    ~~~~~~~~~~~
<stdin>:16:5: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    bar + foo, bar - foo, bar * foo, bar / foo, bar % foo, bar & foo, bar | foo, bar ^ foo, bar << foo, bar >> foo, bar <=> foo,
    ~~~~~~~~~
<stdin>:16:16: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    bar + foo, bar - foo, bar * foo, bar / foo, bar % foo, bar & foo, bar | foo, bar ^ foo, bar << foo, bar >> foo, bar <=> foo,
               ~~~~~~~~~
<stdin>:16:27: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    bar + foo, bar - foo, bar * foo, bar / foo, bar % foo, bar & foo, bar | foo, bar ^ foo, bar << foo, bar >> foo, bar <=> foo,
                          ~~~~~~~~~
<stdin>:16:38: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    bar + foo, bar - foo, bar * foo, bar / foo, bar % foo, bar & foo, bar | foo, bar ^ foo, bar << foo, bar >> foo, bar <=> foo,
                                     ~~~~~~~~~
<stdin>:16:49: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    bar + foo, bar - foo, bar * foo, bar / foo, bar % foo, bar & foo, bar | foo, bar ^ foo, bar << foo, bar >> foo, bar <=> foo,
                                                ~~~~~~~~~
<stdin>:16:60: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    bar + foo, bar - foo, bar * foo, bar / foo, bar % foo, bar & foo, bar | foo, bar ^ foo, bar << foo, bar >> foo, bar <=> foo,
                                                           ~~~~~~~~~
<stdin>:16:71: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    bar + foo, bar - foo, bar * foo, bar / foo, bar % foo, bar & foo, bar | foo, bar ^ foo, bar << foo, bar >> foo, bar <=> foo,
                                                                      ~~~~~~~~~
<stdin>:16:82: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    bar + foo, bar - foo, bar * foo, bar / foo, bar % foo, bar & foo, bar | foo, bar ^ foo, bar << foo, bar >> foo, bar <=> foo,
                                                                                 ~~~~~~~~~
<stdin>:16:93: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    bar + foo, bar - foo, bar * foo, bar / foo, bar % foo, bar & foo, bar | foo, bar ^ foo, bar << foo, bar >> foo, bar <=> foo,
                                                                                            ~~~~~~~~~~
<stdin>:16:105: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    bar + foo, bar - foo, bar * foo, bar / foo, bar % foo, bar & foo, bar | foo, bar ^ foo, bar << foo, bar >> foo, bar <=> foo,
                                                                                                        ~~~~~~~~~~
<stdin>:16:117: error: Cannot convert from type \"int\" to type \"bool\" without a cast
    bar + foo, bar - foo, bar * foo, bar / foo, bar % foo, bar & foo, bar | foo, bar ^ foo, bar << foo, bar >> foo, bar <=> foo,
                                                                                                                    ~~~~~~~~~~~
")

# Test for recursive propagation of dynamic type context for list literals
test("
const foo dynamic = [1, [1, null]]
", "
")

# Test for recursive propagation of dynamic type context for map literals
test("
const foo dynamic = {
  \"a\": 1,
  \"b\": {
    \"c\": 1,
    \"d\": null
  }
}
", "
")

# Check for a crash due to a bug with nested guards
test("
if true {
  if FOO == .BAR {
  }
}

enum Foo {
  FOO
}

const FOO = Foo.FOO
", "
<stdin>:2:14: error: \"BAR\" is not declared on type \"Foo\"
  if FOO == .BAR {
             ~~~
")

# Check for a crash due to a bug with nested guards
test("
if true {
  if FOO == .BAR {
  } else {
  }
}

const FOO = Foo.FOO
", "
<stdin>:7:13: error: \"Foo\" is not declared
const FOO = Foo.FOO
            ~~~
")

# Check cyclic declarations involving lambdas
test("
# Cyclic declaration
const a = => a()
const b = (=> b() + 1)()
const c = => { c() }

# Not cyclic declarations
const d fn() = => d()
const e fn() = => { e() }
", "
<stdin>:2:7: error: Cyclic declaration of \"a\"
const a = => a()
      ^
<stdin>:3:7: error: Cyclic declaration of \"b\"
const b = (=> b() + 1)()
      ^
<stdin>:4:7: error: Cyclic declaration of \"c\"
const c = => { c() }
      ^
")

# Check equality operator warnings meant to prevent bugs, but don't warn on values that may be NaN
test("
def main(i int, d double, y dynamic, f fn() int, foo Foo) bool {
  return
    i + 2 == i + 2 && i + 2 != i + 2 ||
    d + 2 == d + 2 && d + 2 != d + 2 ||
    y + 2 == y + 2 && y + 2 != y + 2 ||
    f() + 2 == f() + 2 && f() + 2 != f() + 2 ||
    foo.i == foo.i && foo.i != foo.i ||
    foo.d == foo.d && foo.d != foo.d ||
    foo.y == foo.y && foo.y != foo.y ||
    foo.f() == foo.f() && foo.f() != foo.f()
}

class Foo {
  var i int
  var d double
  var y dynamic
  var f fn() int
}
", "
<stdin>:3:5: warning: Both sides of \"==\" are identical, is this a bug?
    i + 2 == i + 2 && i + 2 != i + 2 ||
    ~~~~~~~~~~~~~~
<stdin>:3:23: warning: Both sides of \"!=\" are identical, is this a bug?
    i + 2 == i + 2 && i + 2 != i + 2 ||
                      ~~~~~~~~~~~~~~
<stdin>:7:5: warning: Both sides of \"==\" are identical, is this a bug?
    foo.i == foo.i && foo.i != foo.i ||
    ~~~~~~~~~~~~~~
<stdin>:7:23: warning: Both sides of \"!=\" are identical, is this a bug?
    foo.i == foo.i && foo.i != foo.i ||
                      ~~~~~~~~~~~~~~
")

# Check logical boolean operator warnings meant to prevent bugs
test("
def main int {
  return
    (1 + 2 == 3 && 1 + 2 == 3 ? 1 : 0) +
    (1 + 2 == 3 || 1 + 2 == 3 ? 1 : 0) +
    (dynamic.foo && dynamic.foo ? 1 : 0) +
    (dynamic.foo || dynamic.foo ? 1 : 0) +
    (dynamic.bar() && dynamic.bar() ? 1 : 0) +
    (dynamic.bar() || dynamic.bar() ? 1 : 0) +
    (true ? 0 : 0) +
    (true ? dynamic.bar() : dynamic.bar())
}
", "
<stdin>:3:6: warning: Both sides of \"&&\" are identical, is this a bug?
    (1 + 2 == 3 && 1 + 2 == 3 ? 1 : 0) +
     ~~~~~~~~~~~~~~~~~~~~~~~~
<stdin>:4:6: warning: Both sides of \"||\" are identical, is this a bug?
    (1 + 2 == 3 || 1 + 2 == 3 ? 1 : 0) +
     ~~~~~~~~~~~~~~~~~~~~~~~~
<stdin>:5:6: warning: Both sides of \"&&\" are identical, is this a bug?
    (dynamic.foo && dynamic.foo ? 1 : 0) +
     ~~~~~~~~~~~~~~~~~~~~~~~~~~
<stdin>:6:6: warning: Both sides of \"||\" are identical, is this a bug?
    (dynamic.foo || dynamic.foo ? 1 : 0) +
     ~~~~~~~~~~~~~~~~~~~~~~~~~~
<stdin>:9:13: warning: Both sides of \":\" are identical, is this a bug?
    (true ? 0 : 0) +
            ~~~~~
<stdin>:10:13: warning: Both sides of \":\" are identical, is this a bug?
    (true ? dynamic.bar() : dynamic.bar())
            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
")

# Check warnings for no-op shifts, which potentially don't behave the same on int types as they do on dynamic types
test("
def main(i int, y dynamic) int {
  return
    i << 0 | i >> 0 | i >>> 0 |
    y << 0 | y >> 0 | y >>> 0
}
", "
<stdin>:3:23: warning: Shifting an integer by zero doesn't do anything, is this a bug?
    i << 0 | i >> 0 | i >>> 0 |
                      ~~~~~~~
")

# Make sure redundant inherited import/export annotations have appropriate warnings
test("
@import
class Foo {
  def foo
}

class Foo {
  @import
  def foo(x int)
}

@export
class Bar {
  def foo {}
}

class Bar {
  @export
  def foo(x int) {}
}

@rename(\"Baz\")
class Baz {
  def foo {}
}

class Baz {
  @rename(\"foo\")
  def foo(x int) {}
}
", "
<stdin>:7:3: warning: Redundant annotation \"@import\" on \"foo\" is already inherited from type \"Foo\"
  @import
  ~~~~~~~
<stdin>:17:3: warning: Redundant annotation \"@export\" on \"foo\" is already inherited from type \"Bar\"
  @export
  ~~~~~~~
")

test("
class Foo {
  def foo int {
    return this + that
  }
}

namespace Foo {
  def bar int {
    return this + that
  }
}
", "
<stdin>:3:12: error: \"this\" is not declared (use \"self\" to refer to the object instance)
    return this + that
           ~~~~
<stdin>:3:19: error: \"that\" is not declared
    return this + that
                  ~~~~
<stdin>:9:12: error: \"this\" is not declared
    return this + that
           ~~~~
<stdin>:9:19: error: \"that\" is not declared
    return this + that
                  ~~~~
")

  }
}
