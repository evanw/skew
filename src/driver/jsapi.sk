namespace Skew.API {
  def sourcesToJSON(sources List<Source>) dynamic {
    return sources.map<dynamic>(source => {
      return {
        "name": source.name,
        "contents": source.contents,
      }
    })
  }

  def diagnosticsToJSON(diagnostics List<Diagnostic>) dynamic {
    return diagnostics.map<dynamic>(diagnostic => {
      return {
        "kind": diagnostic.kind.toString.toLowerCase,
        "range": rangeToJSON(diagnostic.range),
        "text": diagnostic.text,
        "fixes": diagnostic.fixes == null ? [] : diagnostic.fixes.map<dynamic>(fix => ({
          "range": rangeToJSON(fix.range),
          "expected": fix.range.toString,
          "description": fix.description,
          "replacement": fix.replacement,
        }))
      }
    })
  }

  var rangeToJSON = (range Range) dynamic => {
    if range == null {
      return null
    }

    var source = range.source
    var start = source.indexToLineColumn(range.start)
    var end = source.indexToLineColumn(range.end)

    return {
      "source": source.name,
      "start": {
        "line": start.line,
        "column": start.column,
      },
      "end": {
        "line": end.line,
        "column": end.column,
      },
    }
  }

  def parseOptions(args dynamic, inputs List<Source>) CompilerOptions {
    if !(args.inputs is List<dynamic>) {
      throw dynamic.Error.new("Missing the required 'inputs' array")
    }

    var options = CompilerOptions.new
    var release = !!args.release
    options.foldAllConstants = !!args.foldAllConstants || release
    options.globalizeAllFunctions = !!args.globalizeAllFunctions || release
    options.inlineAllFunctions = !!args.inlineAllFunctions || release
    options.jsMangle = !!args.jsMangle || release
    options.jsMinify = !!args.jsMinify || release
    options.jsSourceMap = !!args.jsSourceMap
    options.outputDirectory = args.outputDirectory ? args.outputDirectory + "" : null
    options.outputFile = args.outputFile ? args.outputFile + "" : null
    options.stopAfterResolve = !!args.stopAfterResolve

    if args.defines {
      var defines = args.defines
      for key in dynamic.Object.keys(defines) as List<string> {
        options.define(key, defines[key] + "")
      }
    }

    if release {
      options.define("RELEASE", "true")
    }

    switch args.target {
      case "c#" { options.target = CSharpTarget.new }
      case "c++" { options.target = CPlusPlusTarget.new }
      case "js" { options.target = JavaScriptTarget.new }
      case "lisp-tree" { options.target = LispTreeTarget.new }
      default {
        if !options.createTargetFromExtension {
          throw dynamic.Error.new("Invalid target '\(args.target)'")
        }
      }
    }

    for i in 0..args.inputs.length {
      var input = args.inputs[i]
      inputs.append(Source.new(input.name + "", input.contents + ""))
    }

    return options
  }

  var createCompilerInstance fn() dynamic = => {
    var result CompilerResult = null
    var inputs List<Source> = null
    var log Log = null

    var handleCompile = (message dynamic) dynamic => {
      inputs = []
      log = Log.new
      result = compile(log, parseOptions(message, inputs), inputs)

      return {
        "type": "compile",
        "id": message.id,
        "outputs": sourcesToJSON(result.outputs),
        "log": {
          "text": log.toString,
          "diagnostics": diagnosticsToJSON(log.diagnostics),
        },
      }
    }

    var handleTooltipQuery = (message dynamic) dynamic => {
      var name string = message.source + ""
      var line int = message.line | 0
      var column int = message.column | 0
      var ignoreDiagnostics bool = !!message.ignoreDiagnostics
      var range Range = null
      var tooltip string = null
      var symbol string = null

      if inputs != null {
        for source in inputs {
          if source.name == name {
            var index = source.lineColumnToIndex(line, column)
            if index != -1 {
              # Search diagnostics first
              if !ignoreDiagnostics && log != null {
                for diagnostic in log.diagnostics {
                  if diagnostic.range != null && diagnostic.range.source == source && diagnostic.range.touches(index) {
                    tooltip = diagnostic.text
                    range = diagnostic.range
                    break
                  }
                }
              }

              # Search the syntax tree next
              if tooltip == null && result != null && result.global != null {
                var query = IDE.SymbolQuery.new(source, index)
                query.run(result.global)
                if query.symbol != null {
                  tooltip = query.generateTooltip
                  range = query.range
                  symbol = query.symbol.fullName
                }
              }
            }
            break
          }
        }
      }

      return {
        "type": "tooltip-query",
        "id": message.id,
        "source": name,
        "tooltip": tooltip,
        "range": rangeToJSON(range),
        "symbol": symbol,
      }
    }

    var handleDefinitionQuery = (message dynamic) dynamic => {
      var name string = message.source + ""
      var line int = message.line | 0
      var column int = message.column | 0
      var range Range = null
      var definition Range = null
      var symbol string = null

      if inputs != null {
        for source in inputs {
          if source.name == name {
            var index = source.lineColumnToIndex(line, column)
            if index != -1 && result != null && result.global != null {
              var query = IDE.SymbolQuery.new(source, index)
              query.run(result.global)
              if query.symbol != null {
                definition = query.symbol.range
                range = query.range
                symbol = query.symbol.fullName
              }
            }
            break
          }
        }
      }

      return {
        "type": "definition-query",
        "id": message.id,
        "source": name,
        "definition": rangeToJSON(definition),
        "range": rangeToJSON(range),
        "symbol": symbol,
      }
    }

    var handleSymbolsQuery = (message dynamic) dynamic => {
      var name string = message.source + ""
      var symbols List<dynamic> = null

      if inputs != null {
        for source in inputs {
          if source.name == name {
            if result != null && result.global != null {
              var query = IDE.SymbolsQuery.new(source)
              query.run(result.global)
              symbols = query.symbols.map<dynamic>(symbol => {
                return {
                  "name": symbol.name,
                  "kind": symbol.kind.toString,
                  "parent": symbol.parent?.name,
                  "fullName": symbol.fullName,
                  "range": rangeToJSON(symbol.range),
                }
              })
            }
            break
          }
        }
      }

      return {
        "type": "symbols-query",
        "id": message.id,
        "source": name,
        "symbols": symbols,
      }
    }

    var handleRenameQuery = (message dynamic) dynamic => {
      var name string = message.source + ""
      var line int = message.line | 0
      var column int = message.column | 0
      var ranges List<Range> = null

      if inputs != null {
        for source in inputs {
          if source.name == name {
            var index = source.lineColumnToIndex(line, column)
            if index != -1 && result != null && result.global != null {
              var renameQuery = IDE.RenameQuery.new(source, index)
              renameQuery.run(result.global)
              ranges = renameQuery.ranges
            }
            break
          }
        }
      }

      return {
        "type": "rename-query",
        "id": message.id,
        "source": name,
        "ranges": ranges.map<dynamic>(rangeToJSON),
      }
    }

    var handleMessage = (message dynamic) dynamic => {
      switch message.type {
        case "compile" { return handleCompile(message) }
        case "tooltip-query" { return handleTooltipQuery(message) }
        case "definition-query" { return handleDefinitionQuery(message) }
        case "symbols-query" { return handleSymbolsQuery(message) }
        case "rename-query" { return handleRenameQuery(message) }
        default { throw dynamic.Error.new("Unexpected message type '\(message.type)'") }
      }
    }

    return {
      "compile": handleCompile,
      "tooltipQuery": handleTooltipQuery,
      "definitionQuery": handleDefinitionQuery,
      "symbolsQuery": handleSymbolsQuery,
      "renameQuery": handleRenameQuery,
      "message": handleMessage,
    }
  }

  @entry
  def main {
    # Web Worker API
    if dynamic.typeof(dynamic.WorkerGlobalScope) != "undefined" && dynamic.self is dynamic.WorkerGlobalScope {
      var instance = createCompilerInstance()
      dynamic.onmessage = (event dynamic) => {
        dynamic.postMessage(instance.message(event.data))
      }
    }

    # JavaScript API
    else {
      if dynamic.typeof(dynamic.exports) != "undefined" {
        dynamic.exports.create = createCompilerInstance
      } else {
        (=> dynamic.this)().Skew = {
          "create": createCompilerInstance
        }
      }
    }
  }
}
