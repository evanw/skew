namespace Skew {
  class JavaScriptTarget : CompilerTarget {
    over name string { return "JavaScript" }
    over extension string { return "js" }
    over stopAfterResolve bool { return false }
    over supportsNestedTypes bool { return true }
    over removeSingletonInterfaces bool { return true }
    over stringEncoding Unicode.Encoding { return .UTF16 }
    over editOptions(options CompilerOptions) { options.define("TARGET", "JAVASCRIPT") }
    over includeSources(sources List<Source>) { sources.prepend(Source.new("<native-js>", NATIVE_LIBRARY_JS)) }
    over createEmitter(context PassContext) Emitter { return JavaScriptEmitter.new(context, context.options, context.cache) }
  }

  class JavaScriptEmitter : Emitter {
    enum BooleanSwap {
      SWAP
      NO_SWAP
    }

    enum ExtractGroupsMode {
      ALL_SYMBOLS
      ONLY_LOCAL_VARIABLES
      ONLY_INSTANCE_VARIABLES
    }

    class SymbolGroup {
      const symbols List<Symbol>
      const count int
    }

    enum AfterToken {
      AFTER_KEYWORD
      AFTER_PARENTHESIS
    }

    enum BracesMode {
      MUST_KEEP_BRACES
      CAN_OMIT_BRACES
    }

    enum SpecialVariable {
      NONE
      AS_STRING
      CREATE
      EXTENDS
      IS_BOOL
      IS_DOUBLE
      IS_INT
      IS_STRING
      MULTIPLY
      PROTOTYPE
    }

    const _context PassContext
    const _options CompilerOptions
    const _cache TypeCache
    const _isSpecialVariableNeeded IntMap<int> = {}
    const _loopLabels IntMap<VariableSymbol> = {}
    const _specialVariables IntMap<VariableSymbol> = {}
    var _global ObjectSymbol = null
    var _symbolsToExport List<Symbol> = []
    var _allSpecialVariables List<VariableSymbol> = null
    var _exportsNamespace ObjectSymbol = null
    var _enclosingFunction FunctionSymbol = null # This includes lambdas during patching but not during emission
    var _enclosingLoop Node = null
    var _namespacePrefix = ""
    var _previousNode Node = null
    var _previousSymbol Symbol = null

    # There's this stupid corner case in JavaScript syntax where a for-in loop
    # allows the variable to be initialized. That looks like this:
    #
    #   // This is valid JavaScript
    #   for (var x = 'y' in z) {}
    #
    # This means that the variable initializer in the for-in loop cannot be
    # initialized using an "in" expression without parenthesizing it first:
    #
    #   // This is invalid JavaScript
    #   for (var x = 'y' in z; x; x = !x) {}
    #
    #   // The initializer must be parenthesized to be valid JavaScript
    #   for (var x = ('y' in z); x; x = !x) {}
    #
    # Rather than parenthesizing all "in" expressions, this variable tracks
    # whether the current state is nested inside a for-in initializer and
    # only parenthesizes then.
    var _parenthesizeInExpressions = 0

    # Source map support
    var _currentColumn = 0
    var _currentLine = 0
    var _generator = SourceMapGenerator.new
    var _previousSource Source = null
    var _previousStart = 0
    var _sourceMap = false

    # A union-find data structure is used to quickly merge symbols into
    # groups. All local variables inside a function are merged with that
    # function. The map create a quick way of getting from a symbol to its
    # union/find index.
    const _allSymbols List<Symbol> = []
    const _localVariableUnionFind = UnionFind.new
    const _namingGroupIndexForSymbol IntMap<int> = {}
    const _symbolCounts IntMap<int> = {}
    var _nextSymbolName = 0

    # For minification
    var _mangle = false
    var _minify = false
    var _needsSemicolon = false
    var _newline = "\n"
    var _space = " "
    var _previousCodeUnit = '\0'

    # For tracking "this" vs "self"
    var _currentSelf VariableSymbol = null
    var _needsSelf = false

    over visit(global ObjectSymbol) {
      _mangle = _options.jsMangle
      _minify = _options.jsMinify
      _sourceMap = _options.jsSourceMap
      _global = global

      if _minify {
        _indentAmount = ""
        _newline = ""
        _space = ""
      }

      # Load special-cased variables
      for variable in global.variables {
        var special = _specialVariableMap.get(variable.name, .NONE)
        if special != .NONE {
          _specialVariables[special] = variable
        }
      }
      assert(SpecialVariable.AS_STRING in _specialVariables)
      assert(SpecialVariable.CREATE in _specialVariables)
      assert(SpecialVariable.EXTENDS in _specialVariables)
      assert(SpecialVariable.IS_BOOL in _specialVariables)
      assert(SpecialVariable.IS_DOUBLE in _specialVariables)
      assert(SpecialVariable.IS_INT in _specialVariables)
      assert(SpecialVariable.IS_STRING in _specialVariables)
      assert(SpecialVariable.MULTIPLY in _specialVariables)
      assert(SpecialVariable.PROTOTYPE in _specialVariables)

      # These don't need to be initialized
      _specialVariables[SpecialVariable.PROTOTYPE].value = null

      # Sort these so their order is deterministic
      _allSpecialVariables = _specialVariables.values
      _allSpecialVariables.sort(Symbol.SORT_VARIABLES_BY_ID)

      # Preprocess the code
      if _mangle {
        _liftGlobals(global)
      }
      if _options.inlineAllFunctions {
        _maybeInlineFunctions(global)
      }
      shakingPass(global, _cache.entryPointSymbol, .IGNORE_TYPES)
      _prepareGlobal(global)
      _convertLambdasToFunctions(global)
      var objects = _sortedObjects(global)

      # Make sure the "__create" variable is inserted when used even if "__extends" isn't used
      var create = _specialVariables[SpecialVariable.CREATE]
      if create in global.variables {
        _isSpecialVariableNeeded[create.id] = 0
      }

      # The entire body of code is wrapped in a closure for safety
      _emit(_indent + "(function(" + (_exportsNamespace != null ? _mangleName(_exportsNamespace) : "") + ")" + _space + "{" + _newline + "")
      _increaseIndent

      # Emit special-cased variables that must come first
      for variable in _allSpecialVariables {
        if variable.id in _isSpecialVariableNeeded {
          if variable.value != null && variable.value.kind == .LAMBDA {
            _emitFunction(_convertLambdaToFunction(variable))
          } else {
            _emitVariable(variable)
          }
        }
      }

      # Emit objects and functions
      for object in objects {
        _emitObject(object)
      }

      # Emit variables
      var statement = Node.createVariables
      for object in objects {
        _namespacePrefix = ""
        for o = object; o.kind != .OBJECT_GLOBAL; o = o.parent.asObjectSymbol {
          _namespacePrefix = _mangleName(o) + "." + _namespacePrefix
        }
        for variable in object.variables {
          if !(variable in _allSpecialVariables) {
            if _mangle && _namespacePrefix == "" && !variable.isImportedOrExported {
              statement.appendChild(Node.createVariable(variable))
            } else {
              _emitVariable(variable)
            }
          }
        }
      }
      _namespacePrefix = ""

      # Group adjacent variables into a single statement during mangling
      if statement.hasChildren {
        _emitNewlineBeforeSymbol(statement.firstChild.symbol)
        _emitStatement(statement)
        _emitNewlineAfterSymbol(statement.firstChild.symbol)
        for child = statement.firstChild; child != null; child = child.nextSibling {
          child.removeChildren
        }
      }

      # Emit entry point
      var entryPointSymbol = _cache.entryPointSymbol
      if entryPointSymbol != null {
        var type = entryPointSymbol.resolvedType
        var callText = _fullName(entryPointSymbol) + (type.argumentTypes.isEmpty ? "()" : "(process.argv.slice(2))")
        _emitSemicolonIfNeeded
        _emit(_newline + _indent + (type.returnType == _cache.intType ? "process.exit(" + callText + ")" : callText))
        _emitSemicolonAfterStatement
      }

      # End the closure wrapping everything
      _decreaseIndent
      _emit(_indent + "})(" + (_exportsNamespace != null ? "this" : "") + ");\n")

      var codeName = _options.outputDirectory != null ? _options.outputDirectory + "/compiled.js" : _options.outputFile
      var mapName = codeName != null ? codeName + ".map" : null

      # Obfuscate the sourceMappingURL so it's not incorrectly picked up as the
      # sourceMappingURL for the compiled JavaScript compiler file
      if _sourceMap {
        _emit("/")
        _emit("/# sourceMappingURL=" + splitPath(mapName).entry + "\n")
      }

      _createSource(codeName, .ALWAYS_EMIT)

      # Create the source map
      if _sourceMap {
        _emit(_generator.toString)
        _createSource(mapName, .ALWAYS_EMIT)
      }
    }

    over _emit(text string) {
      if _minify || _sourceMap {
        var n = text.count
        for i in 0..n {
          if text[i] == '\n' {
            _currentColumn = 0
            _currentLine++
          } else {
            _currentColumn++
          }
        }
        if n != 0 {
          _previousCodeUnit = text[n - 1]
        }
      }
      _code.append(text)
    }

    def _liftGlobals(global ObjectSymbol) {
      var globalObjects List<ObjectSymbol> = []
      var globalFunctions List<FunctionSymbol> = []
      var globalVariables List<VariableSymbol> = []

      _liftGlobals(global, globalObjects, globalFunctions, globalVariables)

      for object in globalObjects { object.parent = global }
      for function in globalFunctions { function.parent = global }
      for variable in globalVariables { variable.parent = global }

      global.objects.append(globalObjects)
      global.functions.append(globalFunctions)
      global.variables.append(globalVariables)
    }

    def _liftGlobals(symbol ObjectSymbol, globalObjects List<ObjectSymbol>, globalFunctions List<FunctionSymbol>, globalVariables List<VariableSymbol>) {
      var shouldLiftGlobals = symbol.parent != null

      # Scan over child objects
      symbol.objects.removeIf(object => {
        _liftGlobals(object, globalObjects, globalFunctions, globalVariables)
        if shouldLiftGlobals && !object.isImportedOrExported {
          globalObjects.append(object)
          return true
        }
        return false
      })

      symbol.functions.removeIf(function => {
        if shouldLiftGlobals && function.kind == .FUNCTION_GLOBAL && !function.isImportedOrExported {
          globalFunctions.append(function)
          return true
        }
        return false
      })

      # Scan over child variables
      symbol.variables.removeIf(variable => {
        if shouldLiftGlobals && variable.kind == .VARIABLE_GLOBAL && !variable.isImportedOrExported {
          globalVariables.append(variable)
          return true
        }
        return false
      })
    }

    def _collectInlineableFunctions(symbol ObjectSymbol, listAppends List<Node>, mapInserts List<Node>) {
      for object in symbol.objects {
        _collectInlineableFunctions(object, listAppends, mapInserts)
      }

      for function in symbol.functions {
        if function.block == null || !function.block.hasTwoChildren {
          continue
        }

        var arguments = function.arguments

        # "foo([], 0)" => "[0]" where "foo" is "def foo(a, b) { a.push(b); return a }"
        if arguments.count == 2 {
          var first = function.block.firstChild
          var second = function.block.lastChild
          if first.kind == .EXPRESSION && first.expressionValue.kind == .CALL &&
              second.kind == .RETURN && second.returnValue != null {
            var call = first.expressionValue
            var callValue = call.callValue
            if call.hasTwoChildren && callValue.kind == .DOT && callValue.asString == "push" &&
                _isReferenceTo(callValue.dotTarget, arguments[0]) &&
                _isReferenceTo(call.lastChild, arguments[1]) &&
                _isReferenceTo(second.returnValue, arguments[0]) {
              for callSite in _context.callGraph.callInfoForSymbol(function).callSites {
                if callSite != null && callSite.callNode.kind == .CALL {
                  assert(callSite.callNode.symbol == function)
                  listAppends.append(callSite.callNode)
                }
              }
            }
          }
        }

        # "foo({}, 0, 1)" => "{0: 1}" where "foo" is "def foo(a, b, c) { a[b] = c; return a }"
        else if arguments.count == 3 {
          var keyType = arguments[1].resolvedType
          var first = function.block.firstChild
          var second = function.block.lastChild
          if (keyType == .DYNAMIC || _cache.isEquivalentToInt(keyType) || _cache.isEquivalentToString(keyType)) &&
              first.kind == .EXPRESSION && first.expressionValue.kind == .ASSIGN_INDEX &&
              second.kind == .RETURN && second.returnValue != null {
            var assign = first.expressionValue
            if _isReferenceTo(assign.assignIndexLeft, arguments[0]) &&
                _isReferenceTo(assign.assignIndexCenter, arguments[1]) &&
                _isReferenceTo(assign.assignIndexRight, arguments[2]) &&
                _isReferenceTo(second.returnValue, arguments[0]) {
              for callSite in _context.callGraph.callInfoForSymbol(function).callSites {
                if callSite != null && callSite.callNode.kind == .CALL {
                  assert(callSite.callNode.symbol == function)
                  mapInserts.append(callSite.callNode)
                }
              }
            }
          }
        }
      }
    }

    # This uses iteration until fixed point to avoid dependence on inlining order
    def _maybeInlineFunctions(global ObjectSymbol) {
      var listAppends List<Node> = []
      var mapInserts List<Node> = []
      _collectInlineableFunctions(global, listAppends, mapInserts)

      # List append fixed point
      var changed = true
      while changed {
        changed = false
        for i in 0..listAppends.count {
          var node = listAppends[i]

          # This will be null if it was already inlined
          if node == null {
            continue
          }

          var firstArgument = node.callValue.nextSibling
          var secondArgument = firstArgument.nextSibling

          # List expressions are sometimes casted
          if firstArgument.kind == .CAST {
            firstArgument = firstArgument.castValue
          }

          # Only check when the inputs are constants
          if firstArgument.kind == .INITIALIZER_LIST {
            node.become(firstArgument.remove.appendChild(secondArgument.remove))
            listAppends[i] = null
            changed = true
          }
        }
      }

      # Map insert fixed point
      changed = true
      while changed {
        changed = false
        for i in 0..mapInserts.count {
          var node = mapInserts[i]

          # This will be null if it was already inlined
          if node == null {
            continue
          }

          var firstArgument = node.callValue.nextSibling
          var secondArgument = firstArgument.nextSibling
          var thirdArgument = secondArgument.nextSibling

          # Map expressions are sometimes casted
          if firstArgument.kind == .CAST {
            firstArgument = firstArgument.castValue
          }

          # Only check when the inputs are constants
          if firstArgument.kind == .INITIALIZER_MAP && (secondArgument.isInt || secondArgument.isString) {
            node.become(firstArgument.remove.appendChild(Node.createPair(secondArgument.remove, thirdArgument.remove).withType(.DYNAMIC)))
            mapInserts[i] = null
            changed = true
          }
        }
      }
    }

    def _prepareGlobal(global ObjectSymbol) {
      # Lower certain stuff into JavaScript (for example, "x as bool" becomes "!!x")
      _patchObject(global)
      _exportSymbols

      # Skip everything below if we aren't mangling
      if !_mangle {
        return
      }

      # These will be culled by tree shaking regardless of whether they are needed
      for variable in _allSpecialVariables {
        if variable.id in _isSpecialVariableNeeded {
          _allocateNamingGroupIndex(variable)
          _patchNode(variable.value)
        }
      }

      # Rename symbols based on frequency for better compression
      _renameSymbols
    }

    def _convertLambdaToFunction(variable VariableSymbol) FunctionSymbol {
      var function = variable.value.symbol.asFunctionSymbol
      function.kind = .FUNCTION_GLOBAL
      function.parent = variable.parent
      function.name = variable.name
      if function.block.parent != null {
        function.block.remove
      }
      return function
    }

    def _convertLambdasToFunctions(symbol ObjectSymbol) {
      for object in symbol.objects {
        _convertLambdasToFunctions(object)
      }

      symbol.variables.removeIf(variable => {
        if variable.kind == .VARIABLE_GLOBAL && variable.isConst && !variable.isExported && variable.value != null && variable.value.kind == .LAMBDA {
          symbol.functions.append(_convertLambdaToFunction(variable))
          return true
        }
        return false
      })
    }

    def _allocateNamingGroupIndex(symbol Symbol) {
      if _mangle && !(symbol.id in _namingGroupIndexForSymbol) {
        var index = _localVariableUnionFind.allocate
        _namingGroupIndexForSymbol[symbol.id] = index
        _allSymbols.append(symbol)

        # Explicitly add function arguments since they won't be reached by
        # normal tree traversal
        if symbol.kind.isFunction {
          var this = symbol.asFunctionSymbol.this
          if this != null {
            _allocateNamingGroupIndex(this)
          }
          for argument in symbol.asFunctionSymbol.arguments {
            _allocateNamingGroupIndex(argument)
          }
        }
      }
    }

    def _renameSymbols {
      # This holds the groups used for naming. Unioning two labels using
      # this object will cause both groups of symbols to have the same name.
      var namingGroupsUnionFind = UnionFind.new.allocate(_allSymbols.count)

      # These are optional and only reduce the number of generated names
      var order List<int> = []
      _aliasLocalVariables(namingGroupsUnionFind, order)
      _aliasUnrelatedProperties(namingGroupsUnionFind, order)

      # Ensure all overridden symbols have the same generated name. This is
      # manditory for correctness, otherwise virtual functions break.
      var namingGroupMap IntMap<int> = {}
      for symbol in _allSymbols {
        if symbol.kind.isFunction {
          var function = symbol.asFunctionSymbol
          assert(function.id in _namingGroupIndexForSymbol)
          var id = namingGroupMap.get(function.namingGroup, -1)
          if id == -1 {
            namingGroupMap[function.namingGroup] = _namingGroupIndexForSymbol[function.id]
          } else {
            namingGroupsUnionFind.union(id, _namingGroupIndexForSymbol[function.id])
          }
        }
      }

      # Collect all reserved names together into one big set for querying
      var reservedNames StringMap<int> = _isKeyword.clone
      for symbol in _allSymbols {
        if !_shouldRenameSymbol(symbol) {
          reservedNames[symbol.name] = 0
        }
      }

      # Everything that should have the same name is now grouped together.
      # Generate and assign names to all internal symbols, but use shorter
      # names for more frequently used symbols.
      var sortedGroups List<SymbolGroup> = []
      for group in _extractGroups(namingGroupsUnionFind, .ALL_SYMBOLS) {
        var count = 0
        for symbol in group {
          if _shouldRenameSymbol(symbol) {
            count += _symbolCounts.get(symbol.id, 0)
          }
        }
        sortedGroups.append(SymbolGroup.new(group, count))
      }

      # Create a total order to make builds deterministic when maps use hashing
      sortedGroups.sort((a, b) => {
        var difference = b.count <=> a.count
        if difference == 0 {
          difference = b.symbols.count <=> a.symbols.count
          for i = 0; difference == 0 && i < a.symbols.count; i++ {
            difference = a.symbols[i].id <=> b.symbols[i].id
          }
        }
        return difference
      })

      for group in sortedGroups {
        var name = ""
        for symbol in group.symbols {
          if _shouldRenameSymbol(symbol) {
            if name == "" {
              name = _generateSymbolName(reservedNames)
            }
            symbol.name = name
          }
        }
      }
    }

    # Merge local variables from different functions together in the order
    # they were declared. This will cause every argument list to use the same
    # variables in the same order, which should offer better gzip:
    #
    #   function d(a, b) {}
    #   function e(a, b, c) {}
    #
    def _aliasLocalVariables(unionFind UnionFind, order List<int>) {
      _zipTogetherInOrder(unionFind, order, _extractGroups(_localVariableUnionFind, .ONLY_LOCAL_VARIABLES))
    }

    # Merge all related types together into naming groups. This ensures names
    # will be unique within a subclass hierarchy allowing names to be
    # duplicated in separate subclass hierarchies.
    def _aliasUnrelatedProperties(unionFind UnionFind, order List<int>) {
      var relatedTypesUnionFind = UnionFind.new.allocate(_allSymbols.count)
      for i in 0.._allSymbols.count {
        var symbol = _allSymbols[i]
        if symbol.kind == .OBJECT_CLASS {
          var baseClass = symbol.asObjectSymbol.baseClass
          if baseClass != null {
            relatedTypesUnionFind.union(i, _namingGroupIndexForSymbol[baseClass.id])
          }
          for variable in symbol.asObjectSymbol.variables {
            relatedTypesUnionFind.union(i, _namingGroupIndexForSymbol[variable.id])
          }
        }
      }
      _zipTogetherInOrder(unionFind, order, _extractGroups(relatedTypesUnionFind, .ONLY_INSTANCE_VARIABLES))
    }

    def _zipTogetherInOrder(unionFind UnionFind, order List<int>, groups List<List<Symbol>>) {
      for group in groups {
        for i in 0..group.count {
          var symbol = group[i]
          var index = _namingGroupIndexForSymbol[symbol.id]
          if i >= order.count {
            order.append(index)
          } else {
            unionFind.union(index, order[i])
          }
        }
      }
    }

    def _generateSymbolName(reservedNames StringMap<int>) string {
      while true {
        var name = _numberToName(_nextSymbolName)
        _nextSymbolName++
        if !(name in reservedNames) {
          return name
        }
      }
    }

    def _extractGroups(unionFind UnionFind, mode ExtractGroupsMode) List<List<Symbol>> {
      var labelToGroup IntMap<List<Symbol>> = {}
      for symbol in _allSymbols {
        if mode == .ONLY_LOCAL_VARIABLES && !symbol.kind.isLocalOrArgumentVariable ||
            mode == .ONLY_INSTANCE_VARIABLES && symbol.kind != .VARIABLE_INSTANCE {
          continue
        }
        assert(symbol.id in _namingGroupIndexForSymbol)
        var label = unionFind.find(_namingGroupIndexForSymbol[symbol.id])
        var group = labelToGroup.get(label, null)
        if group == null {
          group = []
          labelToGroup[label] = group
        }
        group.append(symbol)
      }

      # Sort each resulting group to make builds deterministic when maps use hashing
      var groups = labelToGroup.values
      for group in groups {
        group.sort(Symbol.SORT_BY_ID)
      }
      return groups
    }

    def _addMapping(range Range) {
      if _sourceMap && range != null {
        var source = range.source
        var start = range.start

        if _previousSource != source || _previousStart != start {
          var location = source.indexToLineColumn(start)
          _generator.addMapping(source, location.line, location.column, _currentLine, _currentColumn)
          _previousStart = start
          _previousSource = source
        }
      }
    }

    def _emitSemicolonAfterStatement {
      if !_minify {
        _emit(";\n")
      } else {
        _needsSemicolon = true
      }
    }

    def _emitSemicolonIfNeeded {
      if _needsSemicolon {
        _emit(";")
        _needsSemicolon = false
      }
      _maybeEmitMinifedNewline
    }

    # Lots of text editors choke up on long lines, so add a newline every now
    # and then for usability's sake
    def _maybeEmitMinifedNewline {
      if _minify && _currentColumn > 1024 {
        _emit("\n")
      }
    }

    def _emitNewlineBeforeSymbol(symbol Symbol) {
      _emitSemicolonIfNeeded
      if !_minify && _previousSymbol != null &&
          (!_previousSymbol.kind.isObject || !symbol.kind.isObject || symbol.comments != null || _previousSymbol.kind.isEnumOrFlags || symbol.kind.isEnumOrFlags) &&
          (!_previousSymbol.kind.isVariable || !symbol.kind.isVariable || symbol.comments != null) {
        _emit("\n")
      }
      _previousSymbol = null
      _addMapping(symbol.range)
    }

    def _emitNewlineAfterSymbol(symbol Symbol) {
      _previousSymbol = symbol
    }

    def _emitNewlineBeforeStatement(node Node) {
      if !_minify && _previousNode != null && (node.comments != null || !_isCompactNodeKind(_previousNode.kind) || !_isCompactNodeKind(node.kind)) {
        _emit("\n")
      } else {
        _maybeEmitMinifedNewline
      }
      _previousNode = null
    }

    def _emitNewlineAfterStatement(node Node) {
      _previousNode = node
    }

    def _emitComments(comments List<Comment>) {
      if comments != null && !_minify {
        for comment in comments {
          for line in comment.lines {
            _emit(_indent + "//" + line + "\n")
          }
          if comment.hasGapBelow {
            _emit("\n")
          }
        }
      }
    }

    def _emitObject(symbol ObjectSymbol) {
      if symbol.isImported {
        return
      }

      var foundPrimaryConstructor = false
      _namespacePrefix = symbol.parent != null ? _computeNamespacePrefix(symbol.parent.asObjectSymbol) : ""

      switch symbol.kind {
        case .OBJECT_NAMESPACE, .OBJECT_INTERFACE, .OBJECT_WRAPPED {
          if symbol.forwardTo == null && symbol != _exportsNamespace {
            _emitNewlineBeforeSymbol(symbol)
            _emitComments(symbol.comments)
            _emit(_indent + (_namespacePrefix == "" ? "var " : _namespacePrefix) + _mangleName(symbol) + _space + "=" + _space + "{}")
            _emitSemicolonAfterStatement
            _emitNewlineAfterSymbol(symbol)
          }
        }

        case .OBJECT_ENUM, .OBJECT_FLAGS {
          _emitNewlineBeforeSymbol(symbol)
          _emitComments(symbol.comments)
          _emit(_indent + (_namespacePrefix == "" ? "var " : _namespacePrefix) + _mangleName(symbol) + _space + "=" + _space + "{")
          _increaseIndent
          var isFirst = true
          for variable in symbol.variables {
            if variable.kind == .VARIABLE_ENUM_OR_FLAGS {
              if isFirst {
                isFirst = false
              } else {
                _emit(",")
              }
              _emit(_newline)
              _emitNewlineBeforeSymbol(variable)
              _emitComments(variable.comments)
              _emit(_indent + _mangleName(variable) + ":" + _space)
              _emitExpression(variable.value, .COMMA)
              _emitNewlineAfterSymbol(variable)
            }
          }
          _decreaseIndent
          if !isFirst && !_minify {
            _emit("\n" + _indent)
          }
          _emit("}")
          _emitSemicolonAfterStatement
          _emitNewlineAfterSymbol(symbol)
        }

        case .OBJECT_CLASS {
          var variable = _specialVariables[SpecialVariable.EXTENDS]
          for function in symbol.functions {
            if function.isPrimaryConstructor {
              if function.comments == null && symbol.comments != null {
                function.comments = symbol.comments
              }
              _emitFunction(function)
              if symbol.baseClass != null || symbol.kind == .OBJECT_CLASS && symbol.extends != null {
                if !_minify {
                  _emit("\n" + _indent)
                }
                _emitSemicolonIfNeeded
                _addMapping(variable.range)
                _emit(_mangleName(variable) + "(" + _fullName(symbol) + "," + _space)
                if symbol.baseClass != null {
                  _emit(_fullName(symbol.baseClass))
                } else {
                  assert(symbol.kind == .OBJECT_CLASS && symbol.extends != null)
                  _emitExpression(symbol.extends, .LOWEST)
                }
                _emit(")")
                _emitSemicolonAfterStatement
              }
              foundPrimaryConstructor = true
              break
            }
          }

          # Emit a namespace if the class is never constructed
          if !foundPrimaryConstructor {
            _emitNewlineBeforeSymbol(symbol)
            _emit(_indent + (_namespacePrefix == "" && !symbol.isExported ? "var " : _namespacePrefix) + _mangleName(symbol) + _space + "=" + _space + "{}")
            _emitSemicolonAfterStatement
          }
        }
      }

      if symbol.kind != .OBJECT_GLOBAL {
        _namespacePrefix += _mangleName(symbol) + "."
      }

      if symbol.usePrototypeCache {
        _emitSemicolonIfNeeded
        _emit(_newline + _indent + _mangleName(_specialVariables[SpecialVariable.PROTOTYPE]) + _space + "=" + _space + _fullName(symbol) + ".prototype")
        _emitSemicolonAfterStatement
      }

      # Ignore instance functions if the class is never constructed
      for function in symbol.functions {
        if foundPrimaryConstructor ? !function.isPrimaryConstructor : function.kind == .FUNCTION_GLOBAL {
          _emitFunction(function)
        }
      }
    }

    def _emitArgumentList(arguments List<VariableSymbol>) {
      for argument in arguments {
        if argument != arguments.first {
          _emit("," + _space)
        }
        _addMapping(argument.range)
        _emit(_mangleName(argument))
      }
    }

    def _emitFunction(symbol FunctionSymbol) {
      if symbol.block == null {
        return
      }

      _emitNewlineBeforeSymbol(symbol)
      _emitComments(symbol.comments)

      var isExpression = _namespacePrefix != "" || symbol.isExported
      var name = _mangleName(symbol.isPrimaryConstructor ? symbol.parent : symbol)

      if isExpression {
        _emit(_indent + (
          symbol.kind != .FUNCTION_INSTANCE ? _namespacePrefix :
          symbol.parent.usePrototypeCache ? _mangleName(_specialVariables[SpecialVariable.PROTOTYPE]) + "." :
          _namespacePrefix + "prototype.") + name + _space + "=" + _space + "function(")
      } else {
        _emit(_indent + "function " + name + "(")
      }

      _emitArgumentList(symbol.arguments)
      _emit(")" + _space + "{" + _newline)
      _increaseIndent
      _enclosingFunction = symbol
      _emitStatements(symbol.block)
      _enclosingFunction = null
      _decreaseIndent
      _emit(_indent + "}")
      if isExpression {
        _emitSemicolonAfterStatement
      } else {
        _needsSemicolon = false
        _emit(_newline)
      }
      _emitNewlineAfterSymbol(symbol)

      # Secondary constructors need the same prototype as the primary constructor
      if symbol.kind == .FUNCTION_CONSTRUCTOR && !symbol.isPrimaryConstructor {
        _emitSemicolonIfNeeded
        _emit(_newline + _indent + _fullName(symbol) + ".prototype" + _space + "=" + _space + (
          symbol.parent.usePrototypeCache ? _mangleName(_specialVariables[SpecialVariable.PROTOTYPE]) :
          _fullName(symbol.parent) + ".prototype"))
        _emitSemicolonAfterStatement
      }
    }

    def _emitVariable(symbol VariableSymbol) {
      if symbol.isImported {
        return
      }

      if symbol.kind != .VARIABLE_INSTANCE && symbol.kind != .VARIABLE_ENUM_OR_FLAGS && (symbol.value != null || _namespacePrefix == "" || symbol.kind.isLocalOrArgumentVariable) {
        _emitNewlineBeforeSymbol(symbol)
        _emitComments(symbol.comments)
        _emit(_indent + (_namespacePrefix == "" || symbol.kind.isLocalOrArgumentVariable ? "var " : _namespacePrefix) + _mangleName(symbol))

        if symbol.value != null {
          _emit(_space + "=" + _space)
          _emitExpression(symbol.value, .COMMA)
        }

        _emitSemicolonAfterStatement
        _emitNewlineAfterSymbol(symbol)
      }
    }

    def _emitStatements(node Node) {
      _previousNode = null

      for child = node.firstChild; child != null; child = child.nextSibling {
        _emitSemicolonIfNeeded
        _emitNewlineBeforeStatement(child)
        _addMapping(child.range)
        _emitComments(child.comments)
        _emitStatement(child)
        _emitNewlineAfterStatement(child)
      }

      _previousNode = null
    }

    def _emitBlock(node Node, after AfterToken, mode BracesMode) {
      var shouldMinify = mode == .CAN_OMIT_BRACES && _minify
      _addMapping(node.range)
      if shouldMinify && !node.hasChildren {
        _emit(";")
      } else if shouldMinify && node.hasOneChild && node.firstChild.kind != .COMMENT_BLOCK {
        if after == .AFTER_KEYWORD {
          _emit(" ")
        }
        _emitStatement(node.firstChild)
      } else {
        _emit(_space + "{" + _newline)
        if node.hasChildren {
          _increaseIndent
          _emitStatements(node)
          _decreaseIndent
        }
        _emit(_indent + "}")
        _needsSemicolon = false
      }
    }

    def _emitVariables(node Node) {
      _emit("var ")
      for child = node.firstChild; child != null; child = child.nextSibling {
        if child.previousSibling != null {
          _emit("," + _space)
        }
        var symbol = child.symbol.asVariableSymbol
        _emit(_mangleName(symbol))
        if symbol.value != null {
          _emit(_space + "=" + _space)
          _emitExpression(symbol.value, .COMMA)
        }
      }
    }

    def _canRemoveSpaceBeforeKeyword(node Node) bool {
      var kind = node.kind
      return
        kind.isUnary && !kind.isUnaryPostfix ||
        node.isString ||
        node.isNumberLessThanZero ||
        kind.isInitializer ||
        (kind == .HOOK || kind == .SEQUENCE) && _canRemoveSpaceBeforeKeyword(node.firstChild)
    }

    def _emitSpaceBeforeKeyword(node Node) {
      if !_minify || !_canRemoveSpaceBeforeKeyword(node) {
        _emit(" ")
      }
    }

    def _emitStatement(node Node) {
      switch node.kind {
        case .COMMENT_BLOCK {}

        case .VARIABLES {
          _emit(_indent)
          _emitVariables(node)
          _emitSemicolonAfterStatement
        }

        case .EXPRESSION {
          _emit(_indent)
          _emitExpression(node.expressionValue, .LOWEST)
          _emitSemicolonAfterStatement
        }

        case .BREAK {
          var label = _loopLabels.get(node.id, null)
          _emit(_indent + "break")
          if label != null {
            _emit(" " + _mangleName(label))
          }
          _emitSemicolonAfterStatement
        }

        case .CONTINUE {
          _emit(_indent + "continue")
          _emitSemicolonAfterStatement
        }

        case .RETURN {
          _emit(_indent + "return")
          var value = node.returnValue
          if value != null {
            _emitSpaceBeforeKeyword(value)
            _emitExpression(value, .LOWEST)
          }
          _emitSemicolonAfterStatement
        }

        case .THROW {
          var value = node.throwValue
          _emit(_indent + "throw")
          _emitSpaceBeforeKeyword(value)
          _emitExpression(value, .LOWEST)
          _emitSemicolonAfterStatement
        }

        case .FOR {
          var setup = node.forSetup
          var test = node.forTest
          var update = node.forUpdate
          _emit(_indent)
          _emitLoopLabel(node)
          _emit("for" + _space + "(")
          if !setup.isEmptySequence {
            _parenthesizeInExpressions++
            if setup.kind == .VARIABLES {
              _emitVariables(setup)
            } else {
              _emitExpression(setup, .LOWEST)
            }
            _parenthesizeInExpressions--
          }
          _emit(";")
          if !test.isEmptySequence {
            _emit(_space)
            _emitExpression(test, .LOWEST)
          }
          _emit(";")
          if !update.isEmptySequence {
            _emit(_space)
            _emitExpression(update, .LOWEST)
          }
          _emit(")")
          _emitBlock(node.forBlock, .AFTER_PARENTHESIS, .CAN_OMIT_BRACES)
          _emit(_newline)
        }

        case .FOREACH {
          _emit(_indent)
          _emitLoopLabel(node)
          _emit("for" + _space + "(var " + _mangleName(node.symbol) + " in ")
          _emitExpression(node.foreachValue, .LOWEST)
          _emit(")")
          _emitBlock(node.foreachBlock, .AFTER_PARENTHESIS, .CAN_OMIT_BRACES)
          _emit(_newline)
        }

        case .IF {
          _emit(_indent)
          _emitIf(node)
          _emit(_newline)
        }

        case .SWITCH {
          var switchValue = node.switchValue
          _emit(_indent + "switch" + _space + "(")
          _emitExpression(switchValue, .LOWEST)
          _emit(")" + _space + "{" + _newline)
          _increaseIndent
          for child = switchValue.nextSibling; child != null; child = child.nextSibling {
            var block = child.caseBlock
            _emitSemicolonIfNeeded
            if child.previousSibling != switchValue {
              _emit(_newline)
            }
            _emitComments(child.comments)
            if child.hasOneChild {
              _emit(_indent + "default:")
            } else {
              for value = child.firstChild; value != block; value = value.nextSibling {
                if value.previousSibling != null {
                  _emit(_newline)
                }
                _emitComments(value.comments)
                _emit(_indent + "case")
                _emitSpaceBeforeKeyword(value)
                _emitExpression(value, .LOWEST)
                _emit(":")
              }
            }
            if !_minify {
              _emit(" {\n")
              _increaseIndent
            }
            _emitStatements(block)
            if block.hasControlFlowAtEnd {
              _emitSemicolonIfNeeded
              _emit(_indent + "break")
              _emitSemicolonAfterStatement
            }
            if !_minify {
              _decreaseIndent
              _emit(_indent + "}\n")
            }
          }
          _decreaseIndent
          _emit(_indent + "}" + _newline)
          _needsSemicolon = false
        }

        case .TRY {
          var tryBlock = node.tryBlock
          var finallyBlock = node.finallyBlock
          _emit(_indent + "try")
          _emitBlock(tryBlock, .AFTER_KEYWORD, .MUST_KEEP_BRACES)
          _emit(_newline)
          for child = tryBlock.nextSibling; child != finallyBlock; child = child.nextSibling {
            _emit(_newline)
            _emitComments(child.comments)
            _emit(_indent + "catch" + _space + "(" + _mangleName(child.symbol) + ")")
            _emitBlock(child.catchBlock, .AFTER_KEYWORD, .MUST_KEEP_BRACES)
            _emit(_newline)
          }
          if finallyBlock != null {
            _emit(_newline)
            _emitComments(finallyBlock.comments)
            _emit(_indent + "finally")
            _emitBlock(finallyBlock, .AFTER_KEYWORD, .MUST_KEEP_BRACES)
            _emit(_newline)
          }
        }

        case .WHILE {
          _emit(_indent)
          _emitLoopLabel(node)
          _emit("while" + _space + "(")
          _emitExpression(node.whileTest, .LOWEST)
          _emit(")")
          _emitBlock(node.whileBlock, .AFTER_PARENTHESIS, .CAN_OMIT_BRACES)
          _emit(_newline)
        }

        default {
          assert(false)
        }
      }
    }

    def _emitLoopLabel(node Node) {
      var label = _loopLabels.get(node.id, null)
      if label != null {
        _emit(_mangleName(label) + ":" + _space)
      }
    }

    def _emitIf(node Node) {
      var trueBlock = node.ifTrue
      var falseBlock = node.ifFalse
      _emit("if" + _space + "(")
      _emitExpression(node.ifTest, .LOWEST)
      _emit(")")

      # Make sure to always keep braces to avoid the dangling "else" case
      # "if (a) if (b) c; else d; else e;"
      # "if (a) { if (b) if (c) d; else e; } else f;"
      # "if (a) { if (b) c; else if (d) e; } else f;"
      # "if (a) { while (true) if (b) break; } else c;"
      var braces = BracesMode.CAN_OMIT_BRACES
      if falseBlock != null {
        var statement = trueBlock.blockStatement
        if statement != null && (statement.kind == .IF ||
            statement.kind == .FOR && statement.forBlock.blockStatement != null ||
            statement.kind == .FOREACH && statement.foreachBlock.blockStatement != null ||
            statement.kind == .WHILE && statement.whileBlock.blockStatement != null) {
          braces = .MUST_KEEP_BRACES
        }
      }
      _emitBlock(node.ifTrue, .AFTER_PARENTHESIS, braces)

      if falseBlock != null {
        var singleIf = _singleIf(falseBlock)
        _emitSemicolonIfNeeded
        _emit(_newline + _newline)
        _emitComments(falseBlock.comments)
        if singleIf != null {
          _emitComments(singleIf.comments)
        }
        _emit(_indent + "else")

        if singleIf != null {
          _emit(" ")
          _emitIf(singleIf)
        } else {
          _emitBlock(falseBlock, .AFTER_KEYWORD, .CAN_OMIT_BRACES)
        }
      }
    }

    def _emitContent(content Content) {
      switch content.kind {
        case .BOOL { _emit(content.asBool.toString) }
        case .INT { _emit(content.asInt.toString) }
        case .DOUBLE {
          var value = content.asDouble
          var text =
            value.isNaN ? "NaN" :
            value == Math.INFINITY ? "Infinity" :
            value == -Math.INFINITY ? "-Infinity" :

            # The C# implementation of double.ToString() uses an uppercase "E"
            TARGET == .CSHARP ? value.toString.toLowerCase :
            value.toString

          # "0.123" => ".123"
          # "-0.123" => "-.123"
          if _minify {
            if text.startsWith("0.") && text != "0." {
              text = text.slice(1)
            } else if text.startsWith("-0.") && text != "-0." {
              text = "-" + text.slice(2)
            }
          }

          _emit(text)
        }
        case .STRING { _emit(quoteString(content.asString, .SHORTEST, .OCTAL_WORKAROUND)) }
      }
    }

    def _emitCommaSeparatedExpressions(from Node, to Node) {
      while from != to {
        _emitExpression(from, .COMMA)
        from = from.nextSibling
        if from != to {
          _emit("," + _space)
          _maybeEmitMinifedNewline
        }
      }
    }

    # Calling a function in an expression that starts with something like "function(){}()"
    # must be wrapped in parentheses to avoid looking like a function statement
    def _lambdaMayNeedParentheses(node Node) bool {
      var parent = node.parent
      if parent == null {
        return false # Expression statements always have parents
      }
      switch parent.kind {
        case .CALL { return node == parent.callValue && _lambdaMayNeedParentheses(parent) }
        case .DOT { return _lambdaMayNeedParentheses(parent) }
        case .INDEX { return node == parent.indexLeft && _lambdaMayNeedParentheses(parent) }
        case .ASSIGN_INDEX { return node == parent.assignIndexLeft && _lambdaMayNeedParentheses(parent) }
        default {
          if parent.kind.isBinary { return node == parent.binaryLeft && _lambdaMayNeedParentheses(parent) }
          return true # Not sure, wrap to be safe
        }
      }
    }

    # Returns true if the provided call node must be parenthesized due to being inside a dot expression
    def _checkForDotParentOfCall(node Node) bool {
      assert(node.kind == .CALL)
      var p = node.parent
      while p != null {
        switch p.kind {
          case .CAST, .PARAMETERIZE { p = p.parent }
          case .DOT { return true }
          default { break }
        }
      }
      return false
    }

    def _emitExpression(node Node, precedence Precedence) {
      var kind = node.kind
      _addMapping(node.range)

      switch kind {
        case .TYPE {
          _emit(_fullName(node.resolvedType.symbol))
        }

        case .NULL {
          _emit("null")
        }

        case .NAME {
          var symbol = node.symbol
          _emit(symbol != null ? _fullName(symbol) : node.asString)
        }

        case .DOT {
          _emitExpression(node.dotTarget, .MEMBER)
          _emit("." + (node.symbol != null ? _mangleName(node.symbol) : node.asString))
        }

        case .CONSTANT {
          var wrap = precedence == .MEMBER && (node.isInt || node.isDouble && (node.asDouble.isFinite || node.asDouble < 0))
          if wrap {
            _emit("(")
          }

          # Prevent "x - -1" from becoming "x--1"
          if _minify && node.isNumberLessThanZero && _previousCodeUnit == '-' {
            _emit(" ")
          }

          _emitContent(node.content)

          if wrap {
            _emit(")")
          }
        }

        case .CALL {
          var value = node.callValue
          var call = value.kind == .SUPER
          var isKeyword = value.kind == .NAME && value.symbol == null && value.asString in _keywordCallMap
          var parenthesize = isKeyword && Precedence.UNARY_POSTFIX < precedence
          var wrap = value.kind == .LAMBDA && _lambdaMayNeedParentheses(node)
          var isNew = false

          if parenthesize {
            _emit("(")
          }

          if wrap {
            _emit("(")
          }

          if !call && node.symbol != null && node.symbol.kind == .FUNCTION_CONSTRUCTOR {
            _emit("new " + _fullName(node.symbol))
            isNew = true
          } else if !call && value.kind == .DOT && value.asString == "new" {
            _emit("new ")
            _emitExpression(value.dotTarget, .MEMBER)
            isNew = true
          } else {
            _emitExpression(value, .UNARY_POSTFIX)
            if call {
              _emit(".call")
            }
          }

          if wrap {
            _emit(")")
          }

          # Omit parentheses during mangling when possible
          if !isNew || !_mangle || call || value.nextSibling != null || _checkForDotParentOfCall(node) {
            _emit(isKeyword ? " " : "(")

            if call {
              _emit(_mangleName(_enclosingFunction.this))
            }

            for child = value.nextSibling; child != null; child = child.nextSibling {
              if call || child.previousSibling != value {
                _emit("," + _space)
                _maybeEmitMinifedNewline
              }
              _emitExpression(child, .COMMA)
            }

            if !isKeyword {
              _emit(")")
            }
          }

          if parenthesize {
            _emit(")")
          }
        }

        case .INITIALIZER_LIST, .INITIALIZER_MAP {
          var useBraces = kind == .INITIALIZER_MAP
          var isIndented = false

          if !_minify {
            for child = node.firstChild; child != null; child = child.nextSibling {
              if child.comments != null {
                isIndented = true
                break
              }
            }
          }

          _emit(useBraces ? "{" : "[")
          if isIndented {
            _increaseIndent
          }

          for child = node.firstChild; child != null; child = child.nextSibling {
            if child.previousSibling != null {
              _emit("," + (isIndented ? "" : _space))
              _maybeEmitMinifedNewline
            }
            if isIndented {
              _emit("\n")
              _emitComments(child.comments)
              _emit(_indent)
            }
            _emitExpression(child, .COMMA)
          }

          if isIndented {
            _decreaseIndent
            _emit("\n" + _indent)
          }
          _emit(useBraces ? "}" : "]")
        }

        case .PAIR {
          _emitExpression(node.firstValue, .LOWEST)
          _emit(":" + _space)
          _emitExpression(node.secondValue, .LOWEST)
        }

        case .INDEX {
          _emitExpression(node.indexLeft, .UNARY_POSTFIX)
          _emit("[")
          _emitExpression(node.indexRight, .LOWEST)
          _emit("]")
        }

        case .ASSIGN_INDEX {
          if Precedence.ASSIGN < precedence {
            _emit("(")
          }
          _emitExpression(node.assignIndexLeft, .UNARY_POSTFIX)
          _emit("[")
          _emitExpression(node.assignIndexCenter, .LOWEST)
          _emit("]" + _space + "=" + _space + "")
          _emitExpression(node.assignIndexRight, .ASSIGN)
          if Precedence.ASSIGN < precedence {
            _emit(")")
          }
        }

        case .CAST {
          _emitExpression(node.castValue, precedence)
        }

        case .PARAMETERIZE {
          _emitExpression(node.parameterizeValue, precedence)
        }

        case .SEQUENCE {
          if Precedence.COMMA <= precedence {
            _emit("(")
          }
          _emitCommaSeparatedExpressions(node.firstChild, null)
          if Precedence.COMMA <= precedence {
            _emit(")")
          }
        }

        case .SUPER {
          _emit(_fullName(node.symbol))
        }

        case .HOOK {
          if Precedence.ASSIGN < precedence {
            _emit("(")
          }
          _emitExpression(node.hookTest, .LOGICAL_OR)
          _emit(_space + "?" + _space)
          _emitExpression(node.hookTrue, .ASSIGN)
          _emit(_space + ":")

          var last = node.hookFalse
          var comments = last.comments
          if comments != null {
            _emit(_newline)
            _increaseIndent
            _emitComments(comments)
            _emit(_indent)
            _emitExpression(last, .ASSIGN)
            _decreaseIndent
          } else {
            _emit(_space)
            _emitExpression(last, .ASSIGN)
          }

          if Precedence.ASSIGN < precedence {
            _emit(")")
          }
        }

        case .LAMBDA {
          var symbol = node.symbol.asFunctionSymbol
          _emit("function(")
          _emitArgumentList(symbol.arguments)
          _emit(")")
          _emitBlock(symbol.block, .AFTER_PARENTHESIS, .MUST_KEEP_BRACES)
        }

        case .COMPLEMENT, .NEGATIVE, .NOT, .POSITIVE, .POSTFIX_DECREMENT, .POSTFIX_INCREMENT, .PREFIX_DECREMENT, .PREFIX_INCREMENT {
          var value = node.unaryValue
          var info = operatorInfo[kind]
          if info.precedence < precedence {
            _emit("(")
          }

          if kind.isUnaryPostfix {
            _emitExpression(value, info.precedence)
            _emit(info.text)
          }

          else {
            # Prevent "x - -1" from becoming "x--1"
            if _minify && (kind == .POSITIVE || kind == .NEGATIVE || kind == .PREFIX_INCREMENT || kind == .PREFIX_DECREMENT) && info.text[0] == _previousCodeUnit {
              _emit(" ")
            }

            _emit(info.text)
            _emitExpression(value, info.precedence)
          }

          if info.precedence < precedence {
            _emit(")")
          }
        }

        case .TYPE_CHECK {
          var type = node.typeCheckType
          var resolvedType = type.resolvedType
          if resolvedType.isWrapped {
            resolvedType = _cache.unwrappedType(resolvedType)
          }
          if resolvedType.kind == .SYMBOL || type.kind != .TYPE {
            if Precedence.COMPARE < precedence {
              _emit("(")
            }
            _emitExpression(node.typeCheckValue, Precedence.COMPARE)
            _emit(" instanceof ")
            if resolvedType.kind == .SYMBOL {
              _emit(_fullName(resolvedType.symbol))
            } else {
              _emitExpression(type, Precedence.COMPARE)
            }
            if Precedence.COMPARE < precedence {
              _emit(")")
            }
          } else {
            _emitExpression(node.typeCheckValue, precedence)
          }
        }

        default {
          if kind.isBinary {
            var info = operatorInfo[kind]
            var left = node.binaryLeft
            var right = node.binaryRight
            var extraEquals = left.resolvedType == .DYNAMIC || right.resolvedType == .DYNAMIC ? "=" : ""
            var needsParentheses = info.precedence < precedence || kind == .IN && _parenthesizeInExpressions != 0

            if needsParentheses {
              _emit("(")
            }
            _emitExpression(node.binaryLeft, info.precedence.incrementIfRightAssociative(info.associativity))

            # Always emit spaces around keyword operators, even when minifying
            var comments = _minify ? null : right.comments
            _emit(kind == .IN ? (left.isString ? _space : " ") + "in" + (comments != null ? "" : " ") :
              _space + (kind == .EQUAL ? "==" + extraEquals : kind == .NOT_EQUAL ? "!=" + extraEquals : info.text))

            if comments != null {
              _emit(_newline)
              _increaseIndent
              _emitComments(comments)
              _emit(_indent)
              _emitExpression(right, info.precedence.incrementIfLeftAssociative(info.associativity))
              _decreaseIndent
            } else {
              if kind != .IN { _emit(_space) }
              _emitExpression(right, info.precedence.incrementIfLeftAssociative(info.associativity))
            }

            if needsParentheses {
              _emit(")")
            }
          }

          else {
            assert(false)
          }
        }
      }
    }

    def _patchObject(symbol ObjectSymbol) {
      _allocateNamingGroupIndex(symbol)

      # Subclasses need the extension stub
      if !symbol.isImported && (symbol.baseClass != null || symbol.kind == .OBJECT_CLASS && symbol.extends != null) {
        _specialVariable(.EXTENDS)
        _specialVariable(.CREATE)
      }

      # Scan over child objects
      for object in symbol.objects {
        _patchObject(object)

        if symbol == _global && object.isExported {
          _symbolsToExport.append(object)
        }
      }

      # Scan over child functions
      var isPrimaryConstructor = true
      var prototypeCount = 0
      for function in symbol.functions {
        var block = function.block
        var this = function.this
        _allocateNamingGroupIndex(function)

        # Check to see if we need an explicit "self" parameter while patching the block
        _needsSelf = false
        _currentSelf = this
        _enclosingFunction = function
        _patchNode(block)
        _enclosingFunction = null

        # Only insert the "self" variable if required to handle capture inside lambdas
        if _needsSelf {
          _unionVariableWithFunction(this, function)
          if block != null {
            this.kind = .VARIABLE_LOCAL
            this.value = Node.createName("this").withType(.DYNAMIC)
            var variable = Node.createVariable(this)
            var merged = false

            # When mangling, add the "self" variable to an existing variable statement if present
            if _mangle && block.hasChildren {
              var firstChild = block.firstChild
              if firstChild.kind == .VARIABLES {
                firstChild.prependChild(variable)
                merged = true
              } else if firstChild.kind == .FOR {
                if firstChild.forSetup.kind == .VARIABLES {
                  firstChild.forSetup.prependChild(variable)
                  merged = true
                } else if firstChild.forSetup.isEmptySequence {
                  firstChild.forSetup.replaceWith(Node.createVariables.appendChild(variable))
                  merged = true
                }
              }
            }

            if !merged {
              block.prependChild(Node.createVariables.appendChild(variable))
            }
          }
        } else if this != null {
          this.name = "this"
          this.flags |= .IS_EXPORTED
        }

        for argument in function.arguments {
          _allocateNamingGroupIndex(argument)
          _unionVariableWithFunction(argument, function)
        }

        # Rename extra constructors overloads so they don't conflict
        if function.kind == .FUNCTION_CONSTRUCTOR && isPrimaryConstructor {
          function.flags |= .IS_PRIMARY_CONSTRUCTOR
          isPrimaryConstructor = false
        }

        # Mark the prototype variable as needed when the prototype is used
        else if _mangle && (function.kind == .FUNCTION_INSTANCE || function.kind == .FUNCTION_CONSTRUCTOR && !isPrimaryConstructor) {
          if ++prototypeCount == 2 {
            var variable = _specialVariable(.PROTOTYPE)
            _symbolCounts[variable.id] = _symbolCounts.get(variable.id, 0) + 1
            symbol.flags |= .USE_PROTOTYPE_CACHE
          }
        }

        if symbol == _global && function.isExported {
          _symbolsToExport.append(function)
        }
      }

      # Scan over child variables
      for variable in symbol.variables {
        _allocateNamingGroupIndex(variable)
        _patchNode(variable.value)

        if symbol == _global && variable.isExported {
          _symbolsToExport.append(variable)
        }
      }
    }

    def _exportSymbols {
      if _symbolsToExport.isEmpty {
        return
      }

      _exportsNamespace = ObjectSymbol.new(.OBJECT_NAMESPACE, _global.scope.generateName("exports"))
      _exportsNamespace.resolvedType = Type.new(.SYMBOL, _exportsNamespace)
      _exportsNamespace.state = .INITIALIZED
      _exportsNamespace.scope = ObjectScope.new(_global.scope, _exportsNamespace)
      _exportsNamespace.parent = _global
      _global.objects.append(_exportsNamespace)
      _allocateNamingGroupIndex(_exportsNamespace)

      for symbol in _symbolsToExport {
        assert(symbol.parent != null)
        assert(symbol.parent.kind.isObject)

        var oldParent = symbol.parent.asObjectSymbol
        symbol.parent = _exportsNamespace

        if symbol.kind.isObject {
          oldParent.objects.removeOne(symbol.asObjectSymbol)
          _exportsNamespace.objects.append(symbol.asObjectSymbol)
        }

        else if symbol.kind.isFunction {
          oldParent.functions.removeOne(symbol.asFunctionSymbol)
          _exportsNamespace.functions.append(symbol.asFunctionSymbol)
        }

        else if symbol.kind.isVariable {
          oldParent.variables.removeOne(symbol.asVariableSymbol)
          _exportsNamespace.variables.append(symbol.asVariableSymbol)
        }

        else {
          assert(false)
        }
      }
    }

    def _createIntBinary(kind NodeKind, left Node, right Node) Node {
      if kind == .MULTIPLY {
        return Node.createSymbolCall(_specialVariable(.MULTIPLY)).appendChild(left).appendChild(right)
      }
      return _wrapWithIntCast(Node.createBinary(kind, left, right).withType(_cache.intType))
    }

    def _wrapWithNot(node Node) Node {
      return Node.createUnary(.NOT, node).withType(_cache.boolType).withRange(node.range)
    }

    def _wrapWithIntCast(node Node) Node {
      return Node.createBinary(.BITWISE_OR, node, _cache.createInt(0)).withType(_cache.intType).withRange(node.range)
    }

    def _removeIntCast(node Node) {
      if node.kind == .BITWISE_OR && node.binaryRight.isInt && node.binaryRight.asInt == 0 {
        node.replaceWith(node.binaryLeft.remove)
      }
    }

    def _patchUnaryArithmetic(node Node) {
      if node.resolvedType == _cache.intType && !_alwaysConvertsOperandsToInt(node.parent) {
        var value = node.unaryValue
        if value.resolvedType == _cache.intType {
          if value.isInt {
            value.content = IntContent.new(-value.asInt)
            node.become(value.remove)
          } else {
            node.become(_wrapWithIntCast(node.cloneAndStealChildren))
          }
        }
      }
    }

    def _patchBinaryArithmetic(node Node) {
      # Make sure arithmetic integer operators don't emit doubles outside the
      # integer range. Allowing this causes JIT slowdowns due to extra checks
      # during compilation and potential deoptimizations during execution.
      # Special-case the integer "%" operator where the right operand may be
      # "0" since that generates "NaN" which is not representable as an int.
      if node.resolvedType == _cache.intType && !_alwaysConvertsOperandsToInt(node.parent) && (
          node.kind != .REMAINDER && node.kind != .UNSIGNED_SHIFT_RIGHT || !node.binaryRight.isInt || node.binaryRight.asInt == 0) {
        var left = node.binaryLeft
        var right = node.binaryRight
        if left.resolvedType == _cache.intType && right.resolvedType == _cache.intType {
          node.become(_createIntBinary(node.kind, left.remove, right.remove).withRange(node.range))
        }
      }
    }

    def _patchTypeCheck(node Node) {
      var value = node.typeCheckValue
      var type = _cache.unwrappedType(node.typeCheckType.resolvedType)

      if type == _cache.boolType {
        node.become(Node.createSymbolCall(_specialVariable(.IS_BOOL)).appendChild(value.remove))
      }

      else if _cache.isInteger(type) {
        node.become(Node.createSymbolCall(_specialVariable(.IS_INT)).appendChild(value.remove))
      }

      else if type == _cache.doubleType {
        node.become(Node.createSymbolCall(_specialVariable(.IS_DOUBLE)).appendChild(value.remove))
      }

      else if type == _cache.stringType {
        node.become(Node.createSymbolCall(_specialVariable(.IS_STRING)).appendChild(value.remove))
      }

      else if type.kind == .LAMBDA {
        node.typeCheckType.replaceWith(Node.createName("Function").withType(.DYNAMIC))
      }
    }

    # Group each variable inside the function with the function itself so that
    # they can be renamed together and won't cause any collisions inside the
    # function
    def _unionVariableWithFunction(symbol Symbol, function Symbol) {
      if _mangle && function != null {
        assert(symbol.id in _namingGroupIndexForSymbol)
        assert(function.id in _namingGroupIndexForSymbol)
        _localVariableUnionFind.union(
          _namingGroupIndexForSymbol[symbol.id],
          _namingGroupIndexForSymbol[function.id])
      }
    }

    def _patchNode(node Node) {
      if node == null {
        return
      }

      var oldEnclosingFunction = _enclosingFunction
      var oldLoop = _enclosingLoop
      var symbol = node.symbol
      var kind = node.kind

      if _mangle && symbol != null {
        _allocateNamingGroupIndex(symbol)
        _symbolCounts[symbol.id] = _symbolCounts.get(symbol.id, 0) + 1
      }

      if kind == .LAMBDA {
        _enclosingFunction = symbol.asFunctionSymbol
      } else if kind.isLoop {
        _enclosingLoop = node
      }

      if kind == .CAST {
        _patchNode(node.castValue)
      } else {
        for child = node.firstChild; child != null; child = child.nextSibling {
          _patchNode(child)
        }
      }

      if kind == .LAMBDA {
        _enclosingFunction = oldEnclosingFunction
      } else if kind.isLoop {
        _enclosingLoop = oldLoop
      }

      # Split this into a separate function because this function is hot and V8 doesn't
      # optimize it otherwise (it's optimized "too many times" whatever that means)
      _patchNodeHelper(node)
    }

    def _patchNodeHelper(node Node) {
      switch node.kind {
        case .ADD, .SUBTRACT, .MULTIPLY, .DIVIDE, .REMAINDER, .UNSIGNED_SHIFT_RIGHT { _patchBinaryArithmetic(node) }
        case .BREAK { _patchBreak(node) }
        case .CAST { _patchCast(node) }
        case .FOREACH { _unionVariableWithFunction(node.symbol, _enclosingFunction) }
        case .LAMBDA { _patchLambda(node) }
        case .NAME { _patchName(node) }
        case .NEGATIVE { _patchUnaryArithmetic(node) }
        case .TRY { _patchTry(node) }
        case .TYPE_CHECK { _patchTypeCheck(node) }
        case .VARIABLE { _unionVariableWithFunction(node.symbol, _enclosingFunction) }
      }

      if _mangle {
        switch node.kind {
          case .ASSIGN_INDEX { _peepholeMangleAssignIndex(node) }
          case .BLOCK { _peepholeMangleBlock(node) }
          case .CALL { _peepholeMangleCall(node) }
          case .CONSTANT { _peepholeMangleConstant(node) }
          case .FOR { _peepholeMangleFor(node) }
          case .HOOK { _peepholeMangleHook(node) }
          case .IF { _peepholeMangleIf(node) }
          case .INDEX { _peepholeMangleIndex(node) }
          case .PAIR { _peepholeManglePair(node) }
          case .WHILE { _peepholeMangleWhile(node) }
          default { if node.kind.isBinary { _peepholeMangleBinary(node) } }
        }
      }
    }

    def _peepholeManglePair(node Node) {
      if _isIdentifierString(node.firstValue) {
        node.firstValue.kind = .NAME
      }
    }

    def _peepholeMangleConstant(node Node) {
      switch node.content.kind {
        case .BOOL {
          node.become(_wrapWithNot(_cache.createInt(node.asBool ? 0 : 1).withRange(node.range)))
        }

        case .INT {
          var value = node.asInt

          # "-2147483648" => "1 << 31"
          if value != 0 {
            var count = value.toString.count
            var shift = 0

            # Count zero bits
            while (value & 1) == 0 {
              value >>>= 1
              shift++
            }

            # Do the substitution if it makes sense
            if shift != 0 && value.toString.count + 2 + shift.toString.count < count {
              node.become(Node.createBinary(.SHIFT_LEFT, _cache.createInt(value), _cache.createInt(shift)).withType(_cache.intType).withRange(node.range))
            }
          }
        }

        case .DOUBLE {
          var value = node.asDouble
          var reciprocal = 1 / value

          # Shorten long reciprocals (don't replace multiplication with division
          # because that's not numerically identical). These should be constant-
          # folded by the JIT at compile-time.
          #
          #   "x * 0.3333333333333333" => "x * (1 / 3)"
          #
          for i in 1..10 {
            if reciprocal * i == ((reciprocal * i) as int) && value.toString.count >= 10 {
              node.become(Node.createBinary(.DIVIDE, _cache.createDouble(i), _cache.createDouble(reciprocal * i)).withType(_cache.doubleType).withRange(node.range))
              break
            }
          }
        }
      }
    }

    def _patchName(node Node) {
      if node.symbol != null && node.symbol == _currentSelf && _enclosingFunction != null && _enclosingFunction.kind == .FUNCTION_LOCAL {
        _needsSelf = true
      }
    }

    def _peepholeMangleCall(node Node) {
      var value = node.callValue
      var parent = node.parent

      # "x + y.toString()" => "x + y" where "x" is a string
      # "x.toString() + ''" => "x + ''"
      if value.nextSibling == null && value.kind == .DOT && value.asString == "toString" &&
          value.symbol != null && value.symbol.isImportedOrExported && parent.kind == .ADD && (
            node == parent.binaryRight && _cache.isEquivalentToString(parent.binaryLeft.resolvedType) || parent.binaryRight.isString) {
        node.become(value.dotTarget.remove)
      }
    }

    # The "break" statement inside a switch should break out of the enclosing
    # loop:
    #
    #   while true {
    #     switch x {
    #       case 0 {
    #         break
    #       }
    #     }
    #   }
    #
    # becomes:
    #
    #   label: while (true) {
    #     switch (x) {
    #       case 0: {
    #         break label;
    #       }
    #     }
    #   }
    #
    def _patchBreak(node Node) {
      var loop = _enclosingLoop
      for parent = node.parent; parent != loop; parent = parent.parent {
        if parent.kind == .SWITCH {
          var label = _loopLabels.get(loop.id, null)
          if label == null {
            label = VariableSymbol.new(.VARIABLE_LOCAL, _enclosingFunction.scope.generateName("label"))
            _allocateNamingGroupIndex(label)
            _unionVariableWithFunction(label, _enclosingFunction)
            _loopLabels[loop.id] = label
          }
          _loopLabels[node.id] = label
          break
        }
      }
    }

    def _patchLambda(node Node) {
      var function = node.symbol.asFunctionSymbol
      for argument in function.arguments {
        _allocateNamingGroupIndex(argument)
        _unionVariableWithFunction(argument, function)
      }
      _unionVariableWithFunction(function, _enclosingFunction)
    }

    def _recursiveSubstituteSymbol(node Node, old Symbol, new Symbol) {
      if node.symbol == old {
        node.symbol = new
      }

      for child = node.firstChild; child != null; child = child.nextSibling {
        _recursiveSubstituteSymbol(child, old, new)
      }
    }

    def _patchTry(node Node) {
      if node.hasChildren && !node.hasOneChild {
        var tryBlock = node.tryBlock
        var finallyBlock = node.finallyBlock
        var firstCatch = finallyBlock != null ? finallyBlock.previousSibling : node.lastChild
        var variable = VariableSymbol.new(.VARIABLE_LOCAL, firstCatch.kind == .CATCH && firstCatch.symbol != null ?
          firstCatch.symbol.name : _enclosingFunction.scope.generateName("e"))
        variable.resolvedType = .DYNAMIC
        var block = Node.createBlock.appendChild(Node.createThrow(Node.createSymbolReference(variable)))

        # Iterate backwards over the catch blocks
        for child = firstCatch, previous = child.previousSibling; child != tryBlock; child = previous, previous = child.previousSibling {
          var catchBlock = child.remove.catchBlock.remove

          # Substitute the variable into the contents of the block
          if child.symbol != null {
            _recursiveSubstituteSymbol(catchBlock, child.symbol, variable)
          }

          # Build up the chain of tests in reverse
          if child.symbol != null && child.symbol.resolvedType != .DYNAMIC {
            var test = Node.createTypeCheck(Node.createSymbolReference(variable), Node.createType(child.symbol.resolvedType)).withType(_cache.boolType)
            block = Node.createBlock.appendChild(catchBlock.hasChildren
              ? Node.createIf(test, catchBlock, block)
              : Node.createIf(_wrapWithNot(test), block, null))
          } else {
            block = catchBlock
          }
        }

        node.insertChildAfter(tryBlock, Node.createCatch(variable, block))

        # Make sure the new variable name is mangled
        _allocateNamingGroupIndex(variable)
        _unionVariableWithFunction(variable, _enclosingFunction)
      }
    }

    def _peepholeMangleBinary(node Node) {
      var kind = node.kind
      var left = node.binaryLeft
      var right = node.binaryRight

      # "(a, b) || c" => "a, b || c"
      # "(a, b) && c" => "a, b && c"
      if (kind == .LOGICAL_OR || kind == .LOGICAL_AND) && left.kind == .SEQUENCE {
        var binary = Node.createBinary(kind, left.lastChild.cloneAndStealChildren, right.remove).withType(.DYNAMIC)
        _peepholeMangleBinary(binary)
        left.lastChild.replaceWith(binary)
        node.become(left.remove)
      }

      # "a + (b + c)" => "(a + b) + c"
      else if kind.isBinaryAssociative && right.kind == kind {
        while true {
          node.rotateBinaryRightToLeft
          node = node.binaryLeft
          if !node.kind.isBinaryAssociative || node.binaryRight.kind != node.kind {
            break
          }
        }
      }

      else if (kind == .GREATER_THAN_OR_EQUAL || kind == .LESS_THAN_OR_EQUAL) && _cache.isEquivalentToInt(left.resolvedType) && _cache.isEquivalentToInt(right.resolvedType) {
        if left.isInt {
          var value = left.asInt

          # "2 >= a" => "3 > a"
          if node.kind == .GREATER_THAN_OR_EQUAL && _canIncrement(value) {
            left.content = IntContent.new(value + 1)
            node.kind = .GREATER_THAN
          }

          # "2 <= a" => "1 < a"
          else if node.kind == .LESS_THAN_OR_EQUAL && _canDecrement(value) {
            left.content = IntContent.new(value - 1)
            node.kind = .LESS_THAN
          }
        } else if right.isInt {
          var value = right.asInt

          # "a >= 2" => "a > 1"
          if node.kind == .GREATER_THAN_OR_EQUAL && _canDecrement(value) {
            right.content = IntContent.new(value - 1)
            node.kind = .GREATER_THAN
          }

          # "a <= 2" => "a < 3"
          else if node.kind == .LESS_THAN_OR_EQUAL && _canIncrement(value) {
            right.content = IntContent.new(value + 1)
            node.kind = .LESS_THAN
          }
        }
      }
    }

    # Simplifies the node assuming it's used in a boolean context. Note that
    # this may replace the passed-in node, which will then need to be queried
    # again if it's needed for further stuff.
    def _peepholeMangleBoolean(node Node, canSwap BooleanSwap) BooleanSwap {
      var kind = node.kind

      if kind == .EQUAL || kind == .NOT_EQUAL {
        var left = node.binaryLeft
        var right = node.binaryRight
        var replacement = _isFalsy(right) ? left : _isFalsy(left) ? right : null

        # "if (a != 0) b;" => "if (a) b;"
        if replacement != null {

          # This minification is not valid for strings and doubles because
          # they both have multiple falsy values (NaN and 0, null, and "")
          if left.resolvedType != null && left.resolvedType != .DYNAMIC && !_cache.isEquivalentToDouble(left.resolvedType) && !_cache.isEquivalentToString(left.resolvedType) &&
              right.resolvedType != null && right.resolvedType != .DYNAMIC && !_cache.isEquivalentToDouble(right.resolvedType) && !_cache.isEquivalentToString(right.resolvedType) {
            replacement.remove
            node.become(kind == .EQUAL ? _wrapWithNot(replacement) : replacement)
          }
        }

        else if _cache.isInteger(left.resolvedType) && _cache.isInteger(right.resolvedType) && (kind == .NOT_EQUAL || kind == .EQUAL && canSwap == .SWAP) {

          # "if (a != -1) c;" => "if (~a) c;"
          # "if (a == -1) c; else d;" => "if (~a) d; else c;"
          if right.isInt && right.asInt == -1 {
            node.become(Node.createUnary(.COMPLEMENT, left.remove).withType(_cache.intType))
          }

          # "if (-1 != b) c;" => "if (~b) c;"
          # "if (-1 == b) c; else d;" => "if (~b) d; else c;"
          else if left.isInt && left.asInt == -1 {
            node.become(Node.createUnary(.COMPLEMENT, right.remove).withType(_cache.intType))
          }

          # "if (a != b) c;" => "if (a ^ b) c;"
          # "if (a == b) c; else d;" => "if (a ^ b) d; else c;"
          # "if ((a + b | 0) != (c + d | 0)) e;" => "if (a + b ^ c + d) e;"
          else {
            node.kind = .BITWISE_XOR
            _removeIntCast(node.binaryLeft)
            _removeIntCast(node.binaryRight)
          }

          return kind == .EQUAL ? .SWAP : .NO_SWAP
        }
      }

      # "if (a != 0 || b != 0) c;" => "if (a || b) c;"
      else if kind == .LOGICAL_AND || kind == .LOGICAL_OR {
        _peepholeMangleBoolean(node.binaryLeft, .NO_SWAP)
        _peepholeMangleBoolean(node.binaryRight, .NO_SWAP)
      }

      # "if (!a) b; else c;" => "if (a) c; else b;"
      # "a == 0 ? b : c;" => "a ? c : b;"
      # This is not an "else if" check since EQUAL may be turned into NOT above
      if node.kind == .NOT && canSwap == .SWAP {
        node.become(node.unaryValue.remove)
        return .SWAP
      }

      # "if (a, !b) c; else d;" => "if (a, b) d; else c;"
      if node.kind == .SEQUENCE {
        return _peepholeMangleBoolean(node.lastChild, canSwap)
      }

      return .NO_SWAP
    }

    def _peepholeMangleIf(node Node) {
      var test = node.ifTest
      var trueBlock = node.ifTrue
      var falseBlock = node.ifFalse
      var trueStatement = trueBlock.blockStatement
      var swapped = _peepholeMangleBoolean(test, falseBlock != null || trueStatement != null && trueStatement.kind == .EXPRESSION ? .SWAP : .NO_SWAP)

      # "if (a) b; else ;" => "if (a) b;"
      if falseBlock != null && !falseBlock.hasChildren {
        falseBlock.remove
        falseBlock = null
      }

      if falseBlock != null {
        var falseStatement = falseBlock.blockStatement

        # "if (!a) b; else c;" => "if (a) c; else b;"
        if swapped == .SWAP {
          var block = trueBlock
          trueBlock = falseBlock
          falseBlock = block
          var statement = trueStatement
          trueStatement = falseStatement
          falseStatement = statement
          trueBlock.swapWith(falseBlock)
        }

        if trueStatement != null && falseStatement != null {

          # "if (a) b; else c;" => "a ? b : c;"
          if trueStatement.kind == .EXPRESSION && falseStatement.kind == .EXPRESSION {
            var hook = Node.createHook(test.remove, trueStatement.expressionValue.remove, falseStatement.expressionValue.remove).withType(.DYNAMIC)
            _peepholeMangleHook(hook)
            node.become(Node.createExpression(hook))
          }

          # "if (a) return b; else return c;" => "return a ? b : c;"
          else if trueStatement.kind == .RETURN && falseStatement.kind == .RETURN {
            var trueValue = trueStatement.returnValue
            var falseValue = falseStatement.returnValue
            if trueValue != null && falseValue != null {
              var hook = Node.createHook(test.remove, trueValue.remove, falseValue.remove).withType(.DYNAMIC)
              _peepholeMangleHook(hook)
              node.become(Node.createReturn(hook))
            }
          }
        }
      }

      # "if (a) b;" => "a && b;"
      # "if (!a) b;" => "a || b;"
      else if trueStatement != null && trueStatement.kind == .EXPRESSION {
        var binary = Node.createBinary(swapped == .SWAP ? .LOGICAL_OR : .LOGICAL_AND, test.remove, trueStatement.expressionValue.remove).withType(.DYNAMIC)
        _peepholeMangleBinary(binary)
        node.become(Node.createExpression(binary))
      }

      # "if (a) if (b) c;" => "if (a && b) c;"
      else {
        var singleIf = _singleIf(trueBlock)
        if singleIf != null && singleIf.ifFalse == null {
          var block = singleIf.ifTrue
          test.replaceWith(Node.createBinary(.LOGICAL_AND, test.cloneAndStealChildren, singleIf.ifTest.remove).withType(.DYNAMIC))
          trueBlock.replaceWith(block.remove)
        }
      }
    }

    def _peepholeMangleWhile(node Node) {
      var test = node.whileTest
      var block = node.whileBlock
      _peepholeMangleBoolean(test.remove, .NO_SWAP)

      # "while (a) {}" => "for (; a;) {}"
      var loop = Node.createFor(Node.createSequence.withType(.DYNAMIC), test, Node.createSequence.withType(.DYNAMIC), block.remove).withRange(node.range)
      _peepholeMangleFor(loop)
      node.become(loop)
    }

    def _peepholeMangleFor(node Node) {
      var test = node.forTest
      _peepholeMangleBoolean(test, .NO_SWAP)

      # "for (; true;) {}" => "for (;;) {}"
      if test.kind == .NOT && test.unaryValue.isInt && test.unaryValue.asInt == 0 {
        var empty = Node.createSequence.withType(.DYNAMIC)
        test.replaceWith(empty)
        test = empty
      }

      # "for (a;;) if (b) break;" => "for (a; b;) {}"
      if node.forUpdate.isEmptySequence {
        var statement = node.forBlock.blockStatement
        if statement != null && statement.kind == .IF && statement.ifFalse == null {
          var branch = statement.ifTrue.blockStatement
          if branch != null && branch.kind == .BREAK {
            var condition = statement.remove.ifTest.remove
            condition.invertBooleanCondition(_cache)
            if test.isEmptySequence {
              test.replaceWith(condition)
            } else {
              condition = Node.createBinary(.LOGICAL_AND, test.cloneAndStealChildren, condition).withType(.DYNAMIC)
              _peepholeMangleBinary(condition)
              test.become(condition)
            }
          }
        }
      }
    }

    def _peepholeMangleHook(node Node) {
      var test = node.hookTest
      var trueValue = node.hookTrue
      var falseValue = node.hookFalse
      var swapped = _peepholeMangleBoolean(test, .SWAP)

      # "!a ? b : c;" => "a ? c : b;"
      if swapped == .SWAP {
        var temp = trueValue
        trueValue = falseValue
        falseValue = temp
        trueValue.swapWith(falseValue)
      }

      # "a.b ? c : null" => "a.b && c"
      if falseValue.kind == .CAST && falseValue.castValue.kind == .NULL && test.resolvedType != null && test.resolvedType != .DYNAMIC && test.resolvedType.isReference {
        node.become(Node.createBinary(.LOGICAL_AND, test.remove, trueValue.remove).withType(node.resolvedType))
        return
      }

      # "a ? a : b" => "a || b"
      # "a = b ? a : c" => "(a = b) || c"
      if test.looksTheSameAs(trueValue) && test.hasNoSideEffects ||
          test.kind.isBinaryAssign && test.binaryLeft.looksTheSameAs(trueValue) && test.binaryLeft.hasNoSideEffects {
        node.become(Node.createBinary(.LOGICAL_OR, test.remove, falseValue.remove).withType(node.resolvedType))
        return
      }

      # "a ? b : a" => "a && b"
      if test.looksTheSameAs(falseValue) && test.hasNoSideEffects {
        node.become(Node.createBinary(.LOGICAL_AND, test.remove, trueValue.remove).withType(node.resolvedType))
        return
      }

      # "a ? b : b" => "a, b"
      if trueValue.looksTheSameAs(falseValue) {
        node.become(test.hasNoSideEffects ? trueValue.remove : Node.createSequence(test.remove, trueValue.remove))
        return
      }

      # Collapse partially-identical hook expressions
      if falseValue.kind == .HOOK {
        var falseTest = falseValue.hookTest
        var falseTrueValue = falseValue.hookTrue
        var falseFalseValue = falseValue.hookFalse

        # "a ? b : c ? b : d" => "a || c ? b : d"
        # "a ? b : c || d ? b : e" => "a || c || d ? b : e"
        if trueValue.looksTheSameAs(falseTrueValue) {
          var both = Node.createBinary(.LOGICAL_OR, test.cloneAndStealChildren, falseTest.remove).withType(.DYNAMIC)
          _peepholeMangleBinary(both)
          test.replaceWith(both)
          falseValue.replaceWith(falseFalseValue.remove)
          _peepholeMangleHook(node)
          return
        }
      }

      # Collapse partially-identical binary expressions
      if trueValue.kind == falseValue.kind && trueValue.kind.isBinary {
        var trueLeft = trueValue.binaryLeft
        var trueRight = trueValue.binaryRight
        var falseLeft = falseValue.binaryLeft
        var falseRight = falseValue.binaryRight

        # "a ? b = c : b = d;" => "b = a ? c : d;"
        if trueLeft.looksTheSameAs(falseLeft) {
          var hook = Node.createHook(test.remove, trueRight.remove, falseRight.remove).withType(.DYNAMIC)
          _peepholeMangleHook(hook)
          node.become(Node.createBinary(trueValue.kind, trueLeft.remove, hook).withType(node.resolvedType))
        }

        # "a ? b + 100 : c + 100;" => "(a ? b + c) + 100;"
        else if trueRight.looksTheSameAs(falseRight) && !trueValue.kind.isBinaryAssign {
          var hook = Node.createHook(test.remove, trueLeft.remove, falseLeft.remove).withType(.DYNAMIC)
          _peepholeMangleHook(hook)
          node.become(Node.createBinary(trueValue.kind, hook, trueRight.remove).withType(node.resolvedType))
        }
      }

      # "(a, b) ? c : d" => "a, b ? c : d"
      if test.kind == .SEQUENCE {
        node.prependChild(test.remove.lastChild.remove)
        test.appendChild(node.cloneAndStealChildren)
        node.become(test)
      }
    }

    def _peepholeMangleAssignIndex(node Node) {
      var left = node.assignIndexLeft
      var center = node.assignIndexCenter
      var right = node.assignIndexRight

      if _isIdentifierString(center) {
        node.become(Node.createBinary(.ASSIGN, Node.createDot(left.remove, center.asString)
            .withRange(Range.span(left.range, center.range)).withType(.DYNAMIC), right.remove)
          .withRange(node.range).withType(node.resolvedType))
      }
    }

    def _peepholeMangleIndex(node Node) {
      var left = node.indexLeft
      var right = node.indexRight

      if _isIdentifierString(right) {
        node.become(Node.createDot(left.remove, right.asString).withRange(node.range).withType(node.resolvedType))
      }
    }

    def _peepholeMangleBlock(node Node) {
      for child = node.firstChild, next Node = null; child != null; child = next {
        var previous = child.previousSibling
        next = child.nextSibling

        switch child.kind {
          # Make sure we entirely remove blocks only containing comment blocks
          case .COMMENT_BLOCK {
            child.remove
          }

          # "var a; var b;" => "var a, b;"
          case .VARIABLES {
            if previous != null && previous.kind == .VARIABLES {
              child.replaceWith(previous.remove.appendChildrenFrom(child))
            }
          }

          # "a; b; c;" => "a, b, c;"
          case .EXPRESSION {
            if child.expressionValue.hasNoSideEffects {
              child.remove
            } else if previous != null && previous.kind == .EXPRESSION {
              var sequence = Node.createSequence(previous.remove.expressionValue.remove, child.expressionValue.remove)
              child.become(Node.createExpression(sequence))
            }
          }

          case .RETURN {
            while previous != null {
              # "if (a) return b; return c;" => "return a ? b : c;"
              if child.returnValue != null && previous.kind == .IF && previous.ifFalse == null {
                var statement = previous.ifTrue.blockStatement
                if statement != null && statement.kind == .RETURN && statement.returnValue != null {
                  var hook = Node.createHook(previous.remove.ifTest.remove, statement.returnValue.remove, child.returnValue.remove).withType(.DYNAMIC)
                  _peepholeMangleHook(hook)
                  child.become(Node.createReturn(hook))
                } else {
                  break
                }
              }

              # "a; return b;" => "return a, b;"
              else if child.returnValue != null && previous.kind == .EXPRESSION {
                var sequence = Node.createSequence(previous.remove.expressionValue.remove, child.returnValue.remove)
                child.become(Node.createReturn(sequence))
              }

              else {
                break
              }

              previous = child.previousSibling
            }
          }

          case .IF {
            while previous != null {
              # "if (a) b; if (c) b;" => "if (a || c) b;"
              if child.ifFalse == null && previous.kind == .IF && previous.ifFalse == null && previous.ifTrue.looksTheSameAs(child.ifTrue) {
                child.ifTest.replaceWith(Node.createBinary(.LOGICAL_OR, previous.remove.ifTest.remove, child.ifTest.cloneAndStealChildren).withType(.DYNAMIC))
              }

              # "a; if (b) c;" => "if (a, b) c;"
              else if previous.kind == .EXPRESSION {
                var sequence = Node.createSequence(previous.remove.expressionValue.remove, child.ifTest.cloneAndStealChildren)
                child.ifTest.replaceWith(sequence)
              }

              else {
                break
              }

              previous = child.previousSibling
            }

            # "void foo() { if (a) return; b(); c() }" => "void foo() { if (!a) { b(); c() } }"
            # "while (a) { if (b) continue; c(); d() }" => "while (a) { if (!b) { c(); d() } }"
            if child.ifFalse == null {
              var trueBlock = child.ifTrue
              if trueBlock.hasChildren {
                var statement = trueBlock.lastChild
                if (statement.kind == .RETURN && statement.returnValue == null || statement.kind == .CONTINUE) && _isJumpImplied(node, statement.kind) {
                  var block Node

                  # If the if statement block without the jump is empty, then flip
                  # the condition of the if statement and reuse the block. Otherwise,
                  # create an else branch for the if statement and use that block.
                  statement.remove
                  if !trueBlock.hasChildren {
                    child.ifTest.invertBooleanCondition(_cache)
                    block = trueBlock
                  } else if next != null {
                    block = Node.createBlock
                    child.appendChild(block)
                    assert(block == child.ifFalse)
                  } else {
                    return # Returning here is fine because this is the last child
                  }

                  # Move the rest of this block into the block for the if statement
                  while child.nextSibling != null {
                    block.appendChild(child.nextSibling.remove)
                  }
                  _peepholeMangleBlock(block)
                  _peepholeMangleIf(child)

                  # "a(); if (b) return; c();" => "a(); if (!b) c();" => "a(); !b && c();" => "a(), !b && c();"
                  if child.kind == .EXPRESSION && previous != null && previous.kind == .EXPRESSION {
                    var sequence = Node.createSequence(previous.remove.expressionValue.remove, child.expressionValue.remove)
                    child.become(Node.createExpression(sequence))
                  }
                  return
                }
              }
            }
          }

          case .FOR {
            var setup = child.forSetup

            # "var a; for (;;) {}" => "for (var a;;) {}"
            if previous != null && setup.isEmptySequence && previous.kind == .VARIABLES {
              setup.replaceWith(previous.remove.appendChildrenFrom(setup))
            }

            # "var a; for (var b;;) {}" => "for (var a, b;;) {}"
            else if previous != null && setup.kind == .VARIABLES && previous.kind == .VARIABLES {
              setup.replaceWith(previous.remove.appendChildrenFrom(setup))
            }

            # "a; for (b;;) {}" => "for (a, b;;) {}"
            else if previous != null && setup.kind.isExpression && previous.kind == .EXPRESSION {
              setup.replaceWith(Node.createSequence(previous.remove.expressionValue.remove, setup.cloneAndStealChildren))
            }
          }

          case .SWITCH {
            var switchValue = child.switchValue
            var defaultCase = child.defaultCase

            if defaultCase != null {
              var hasFlowAtEnd = false

              # See if any non-default case will flow past the end of the switch block
              for caseChild = switchValue.nextSibling; caseChild != defaultCase; caseChild = caseChild.nextSibling {
                if caseChild.caseBlock.hasControlFlowAtEnd {
                  hasFlowAtEnd = true
                }
              }

              # "switch (a) { case b: return; default: c; break; }" => "switch (a) { case b: return; } c;"
              if !hasFlowAtEnd {
                node.insertChildrenAfterFrom(defaultCase.caseBlock, child)
                next = child.nextSibling
                defaultCase.remove
                defaultCase = null
              }
            }

            # "switch (a) {}" => "a;"
            if child.hasOneChild {
              next = Node.createExpression(switchValue.remove)
              child.replaceWith(next)
              continue
            }

            # "switch (a) { case b: c; break; }" => "if (a == b) c;"
            else if child.hasTwoChildren {
              var singleCase = child.lastChild
              if singleCase.hasTwoChildren {
                var value = singleCase.firstChild
                next = Node.createIf(Node.createBinary(.EQUAL, switchValue.remove, value.remove).withType(_cache.boolType), singleCase.caseBlock.remove, null)
                _peepholeMangleIf(next)
                child.replaceWith(next)
                continue
              }
            }

            # "switch (a) { case b: c; break; default: d; break; }" => "if (a == b) c; else d;"
            else if child.hasThreeChildren {
              var firstCase = switchValue.nextSibling
              var secondCase = child.lastChild
              if firstCase.hasTwoChildren && secondCase.hasOneChild {
                var value = firstCase.firstChild
                next = Node.createIf(Node.createBinary(.EQUAL, switchValue.remove, value.remove).withType(_cache.boolType), firstCase.caseBlock.remove, secondCase.caseBlock.remove)
                _peepholeMangleIf(next)
                child.replaceWith(next)
                continue
              }
            }

            # Optimize specific patterns of switch statements
            if switchValue.kind == .NAME && defaultCase == null {
              _peepholeMangleSwitchCases(child)
            }
          }
        }
      }
    }

    # "switch (a) { case 0: return 0; case 1: return 1; case 2: return 2; }" => "if (a >= 0 && a <= 2) return a"
    # "switch (a) { case 0: return 1; case 1: return 2; case 2: return 3; }" => "if (a >= 0 && a <= 2) return a + 1"
    def _peepholeMangleSwitchCases(node Node) {
      var switchValue = node.switchValue
      var firstCase = switchValue.nextSibling
      if !_cache.isEquivalentToInt(switchValue.resolvedType) {
        return
      }

      var sharedDelta = 0
      var count = 0
      var min = 0
      var max = 0

      for child = firstCase; child != null; child = child.nextSibling {
        var singleStatement = child.caseBlock.blockStatement
        if !child.hasTwoChildren || singleStatement == null || singleStatement.kind != .RETURN {
          return
        }

        var caseValue = child.firstChild
        var returnValue = singleStatement.returnValue
        if !caseValue.isInt || returnValue == null || !returnValue.isInt {
          return
        }

        var caseInt = caseValue.asInt
        var returnInt = returnValue.asInt
        var delta = returnInt - caseInt
        if count == 0 {
          sharedDelta = delta
          min = caseInt
          max = caseInt
        } else if delta != sharedDelta {
          return
        } else {
          min = Math.min(min, caseInt)
          max = Math.max(max, caseInt)
        }

        count++
      }

      # Make sure the pattern is matched
      if count == 0 {
        return
      }

      var block = Node.createBlock.appendChild(Node.createReturn(
        sharedDelta > 0 ? _createIntBinary(.ADD, switchValue.remove, _cache.createInt(sharedDelta)) :
        sharedDelta < 0 ? _createIntBinary(.SUBTRACT, switchValue.remove, _cache.createInt(-sharedDelta)) :
        switchValue.remove))

      # Replace the large "switch" statement with a smaller "if" statement if the entire range is covered
      if max - min == count - 1 {
        var lower = Node.createBinary(.GREATER_THAN_OR_EQUAL, switchValue.clone, _cache.createInt(min)).withType(_cache.boolType)
        var upper = Node.createBinary(.LESS_THAN_OR_EQUAL, switchValue.clone, _cache.createInt(max)).withType(_cache.boolType)

        # Convert ">=" and "<=" to ">" and "<" where possible
        _peepholeMangleBinary(lower)
        _peepholeMangleBinary(upper)

        node.replaceWith(Node.createIf(Node.createBinary(.LOGICAL_AND, lower, upper).withType(_cache.boolType), block, null))
      }

      # Just combine everything into one case
      else {
        var combined = Node.createCase
        for child = firstCase; child != null; child = child.nextSibling {
          combined.appendChild(child.firstChild.remove)
        }
        node.replaceWith(Node.createSwitch(switchValue.clone).appendChild(combined.appendChild(block)))
      }
    }

    def _patchCast(node Node) {
      var value = node.castValue
      var type = node.resolvedType
      var valueType = value.resolvedType

      # Wrapping should be transparent in the emitted code
      if type.isWrapped || valueType.isWrapped {
        return
      }

      # Cast to bool
      if type == _cache.boolType {
        if valueType != _cache.boolType {
          node.become(_wrapWithNot(_wrapWithNot(value.remove)))
        }
      }

      # Cast to int
      else if _cache.isInteger(type) {
        if !_cache.isInteger(valueType) && !_alwaysConvertsOperandsToInt(node.parent) {
          node.become(_wrapWithIntCast(value.remove))
        } else if value.isInt {
          node.become(value.remove.withType(node.resolvedType))
        }
      }

      # Cast to double
      else if type == _cache.doubleType {
        if !_cache.isNumeric(valueType) {
          node.become(Node.createUnary(.POSITIVE, value.remove).withRange(node.range).withType(_cache.doubleType))
        }
      }

      # Cast to string
      else if type == _cache.stringType {
        if valueType != _cache.stringType && valueType != .NULL {
          node.become(Node.createSymbolCall(_specialVariable(.AS_STRING)).appendChild(value.remove))
        }
      }
    }

    def _specialVariable(name SpecialVariable) VariableSymbol {
      assert(name in _specialVariables)
      var variable = _specialVariables[name]
      _isSpecialVariableNeeded[variable.id] = 0
      return variable
    }
  }

  namespace JavaScriptEmitter {
    def _isReferenceTo(node Node, symbol Symbol) bool {
      if node.kind == .CAST {
        node = node.castValue
      }
      return node.kind == .NAME && node.symbol == symbol
    }

    def _isJumpImplied(node Node, kind NodeKind) bool {
      assert(node.kind == .BLOCK)
      assert(kind == .RETURN || kind == .CONTINUE)
      var parent = node.parent
      if kind == .RETURN && (parent == null || parent.kind == .LAMBDA) || kind == .CONTINUE && parent != null && parent.kind.isLoop {
        return true
      }
      if parent != null && parent.kind == .IF && parent.nextSibling == null {
        return _isJumpImplied(parent.parent, kind)
      }
      return false
    }

    def _canIncrement(value int) bool {
      return value < 0x7FFFFFFF
    }

    def _canDecrement(value int) bool {
      return value >= -0x7FFFFFFF
    }

    def _isIdentifierString(node Node) bool {
      if node.isString {
        var value = node.asString
        for i in 0..value.count {
          var c = value[i]
          if (c < 'A' || c > 'Z') && (c < 'a' || c > 'z') && c != '_' && c != '$' && (i == 0 || c < '0' || c > '9') {
            return false
          }
        }
        return value != "" && !(value in _isKeyword)
      }
      return false
    }

    def _singleIf(block Node) Node {
      if block == null {
        return null
      }
      var statement = block.blockStatement
      if statement != null && statement.kind == .IF {
        return statement
      }
      return null
    }

    const _first = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$"
    const _rest = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$0123456789"

    def _numberToName(number int) string {
      var name = _first.get(number % _first.count)
      number = number / _first.count
      while number > 0 {
        number--
        name += _rest.get(number % _rest.count)
        number = number / _rest.count
      }
      return name
    }

    def _isCompactNodeKind(kind NodeKind) bool {
      return kind == .EXPRESSION || kind == .VARIABLES || kind.isJump
    }

    def _isFalsy(node Node) bool {
      switch node.kind {
        case .NULL { return true }
        case .CAST { return _isFalsy(node.castValue) }
        case .CONSTANT {
          var content = node.content
          switch content.kind {
            case .INT { return content.asInt == 0 }
            case .DOUBLE { return content.asDouble == 0 || content.asDouble.isNaN }
            case .STRING { return content.asString == "" }
          }
        }
      }
      return false
    }

    def _fullName(symbol Symbol) string {
      var parent = symbol.parent
      if parent != null && parent.kind != .OBJECT_GLOBAL {
        var enclosingName = _fullName(parent)
        if symbol.isPrimaryConstructor || symbol.isImported && symbol.kind == .FUNCTION_CONSTRUCTOR {
          return enclosingName
        }
        assert(symbol.kind != .OVERLOADED_INSTANCE)
        if symbol.kind == .FUNCTION_INSTANCE {
          enclosingName += ".prototype"
        }
        return enclosingName + "." + _mangleName(symbol)
      }
      return _mangleName(symbol)
    }

    def _shouldRenameSymbol(symbol Symbol) bool {
      # Don't rename annotations since "@rename" is used for renaming and is identified by name
      return !symbol.isImportedOrExported && !symbol.isRenamed && !symbol.isPrimaryConstructor &&
        symbol.kind != .FUNCTION_ANNOTATION && symbol.kind != .OBJECT_GLOBAL && symbol.kind != .FUNCTION_LOCAL
    }

    def _mangleName(symbol Symbol) string {
      symbol = symbol.forwarded

      if symbol.isPrimaryConstructor {
        symbol = symbol.parent
      }
      if !symbol.isImportedOrExported && (symbol.name in _isKeyword ||
          symbol.parent != null && symbol.parent.kind == .OBJECT_CLASS && !symbol.kind.isOnInstances && symbol.name in _isFunctionProperty) {
        return "$" + symbol.name
      }
      return symbol.name
    }

    def _computeNamespacePrefix(symbol ObjectSymbol) string {
      assert(symbol.kind.isObject)
      return symbol.kind == .OBJECT_GLOBAL ? "" : _computeNamespacePrefix(symbol.parent.asObjectSymbol) + _mangleName(symbol) + "."
    }

    def _alwaysConvertsOperandsToInt(node Node) bool {
      if node != null {
        switch node.kind {
          case
            .ASSIGN_BITWISE_AND, .ASSIGN_BITWISE_OR, .ASSIGN_BITWISE_XOR,
            .ASSIGN_SHIFT_LEFT, .ASSIGN_SHIFT_RIGHT, .BITWISE_AND, .BITWISE_OR,
            .BITWISE_XOR, .COMPLEMENT, .SHIFT_LEFT, .SHIFT_RIGHT {
            return true
          }
        }
      }
      return false
    }

    const _isFunctionProperty = {
      "apply": 0,
      "call": 0,
      "length": 0,
      "name": 0,
    }

    const _isKeyword = {
      "arguments": 0,
      "await": 0,
      "Boolean": 0,
      "break": 0,
      "case": 0,
      "catch": 0,
      "class": 0,
      "const": 0,
      "constructor": 0,
      "continue": 0,
      "Date": 0,
      "debugger": 0,
      "default": 0,
      "delete": 0,
      "do": 0,
      "double": 0,
      "else": 0,
      "enum": 0,
      "eval": 0,
      "export": 0,
      "extends": 0,
      "false": 0,
      "finally": 0,
      "float": 0,
      "for": 0,
      "function": 0,
      "Function": 0,
      "if": 0,
      "implements": 0,
      "import": 0,
      "in": 0,
      "instanceof": 0,
      "int": 0,
      "interface": 0,
      "let": 0,
      "new": 0,
      "null": 0,
      "Number": 0,
      "Object": 0,
      "package": 0,
      "private": 0,
      "protected": 0,
      "public": 0,
      "return": 0,
      "static": 0,
      "String": 0,
      "super": 0,
      "switch": 0,
      "this": 0,
      "throw": 0,
      "true": 0,
      "try": 0,
      "typeof": 0,
      "var": 0,
      "void": 0,
      "while": 0,
      "with": 0,
      "yield": 0,
    }

    const _keywordCallMap = {
      "delete": 0,
      "typeof": 0,
      "void": 0,
    }

    const _specialVariableMap = {
      "__asString": SpecialVariable.AS_STRING,
      "__create": SpecialVariable.CREATE,
      "__extends": SpecialVariable.EXTENDS,
      "__imul": SpecialVariable.MULTIPLY,
      "__isBool": SpecialVariable.IS_BOOL,
      "__isDouble": SpecialVariable.IS_DOUBLE,
      "__isInt": SpecialVariable.IS_INT,
      "__isString": SpecialVariable.IS_STRING,
      "__prototype": SpecialVariable.PROTOTYPE,
    }
  }
}
