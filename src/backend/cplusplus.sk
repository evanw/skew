namespace Skew {
  class CPlusPlusTarget : CompilerTarget {
    over name string { return "C++" }
    over extension string { return "cpp" }
    over stopAfterResolve bool { return false }
    over requiresIntegerSwitchStatements bool { return true }
    over supportsListForeach bool { return true }
    over needsLambdaLifting bool { return true }
    over stringEncoding Unicode.Encoding { return .UTF8 }
    over editOptions(options CompilerOptions) { options.define("TARGET", "CPLUSPLUS") }
    over includeSources(sources List<Source>) { sources.prepend(Source.new("<native-cpp>", NATIVE_LIBRARY_CPP)) }
    over createEmitter(context PassContext) Emitter { return CPlusPlusEmitter.new(context.options, context.cache) }
  }

  class CPlusPlusEmitter : Emitter {
    const _options CompilerOptions
    const _cache TypeCache
    var _previousNode Node = null
    var _previousSymbol Symbol = null
    var _namespaceStack List<Symbol> = []
    var _symbolsCheckedForInclude IntMap<int> = {}
    var _includeNames StringMap<int> = {}
    var _loopLabels IntMap<VariableSymbol> = {}
    var _enclosingFunction FunctionSymbol = null

    over visit(global ObjectSymbol) {
      # Generate the entry point
      var entryPoint = _cache.entryPointSymbol
      if entryPoint != null {
        entryPoint.name = "main"

        # The entry point must not be in a namespace
        if entryPoint.parent != global {
          entryPoint.parent.asObjectSymbol.functions.removeOne(entryPoint)
          entryPoint.parent = global
          global.functions.append(entryPoint)
        }

        # The entry point in C++ takes an array, not a list
        if entryPoint.arguments.count == 1 {
          var argument = entryPoint.arguments.first
          var argc = VariableSymbol.new(.VARIABLE_ARGUMENT, entryPoint.scope.generateName("argc"))
          var argv = VariableSymbol.new(.VARIABLE_ARGUMENT, entryPoint.scope.generateName("argv"))
          argc.initializeWithType(_cache.intType)
          argv.type = Node.createName("char**").withType(.DYNAMIC)
          argv.resolvedType = .DYNAMIC
          argv.state = .INITIALIZED
          entryPoint.arguments = [argc, argv]
          entryPoint.resolvedType.argumentTypes = [argc.resolvedType, argv.resolvedType]

          # Create the list from the array
          if entryPoint.block != null {
            var advance = Node.createName("*\(argv.name)++").withType(.DYNAMIC)
            var block = Node.createBlock.appendChild(Node.createExpression(Node.createCall(Node.createDot(
              Node.createSymbolReference(argument), "append").withType(.DYNAMIC)).withType(.DYNAMIC).appendChild(advance)))
            var check = Node.createIf(advance.clone, Node.createBlock.appendChild(
              Node.createWhile(Node.createName("*\(argv.name)").withType(.DYNAMIC), block)), null)
            argument.kind = .VARIABLE_LOCAL
            argument.value = Node.createCall(Node.createDot(Node.createType(argument.resolvedType), "new").withType(.DYNAMIC)).withType(.DYNAMIC)
            entryPoint.block.prependChild(check)
            entryPoint.block.prependChild(Node.createVariables.appendChild(Node.createVariable(argument)))
          }
        }
      }

      # Avoid emitting unnecessary stuff
      shakingPass(global, _cache.entryPointSymbol, .USE_TYPES)
      _markVirtualFunctions(global)

      # Nested types in C++ can't be forward declared
      var sorted = _sortedObjects(global)
      for symbol in sorted {
        _moveNestedObjectToEnclosingNamespace(symbol)
      }

      # Emit code in passes to deal with C++'s forward declarations
      for symbol in sorted {
        _declareObject(symbol)
      }
      for symbol in sorted {
        _defineObject(symbol)
      }
      _adjustNamespace(null)
      for symbol in sorted {
        if !symbol.isImported {
          for variable in symbol.variables {
            if variable.kind == .VARIABLE_GLOBAL {
              _emitVariable(variable, .IMPLEMENT)
            }
          }
        }
      }
      _adjustNamespace(null)
      for symbol in sorted {
        if !symbol.isImported {
          for function in symbol.functions {
            _emitFunction(function, .IMPLEMENT)
          }
        }
      }
      _finalizeEmittedFile
      _createSource(_options.outputFile, .ALWAYS_EMIT)
    }

    enum CodeMode {
      DECLARE
      DEFINE
      IMPLEMENT
    }

    def _emitNewlineBeforeSymbol(symbol Symbol, mode CodeMode) {
      if _previousSymbol != null &&
          (!_previousSymbol.kind.isVariable || !symbol.kind.isVariable || symbol.comments != null) &&
          (mode != .DEFINE || !_previousSymbol.kind.isFunction || !symbol.kind.isFunction || symbol.comments != null) &&
          (mode != .DECLARE || _previousSymbol.kind != .OBJECT_CLASS || symbol.kind != .OBJECT_CLASS) {
        _emit("\n")
      }
      _previousSymbol = null
    }

    def _emitNewlineAfterSymbol(symbol Symbol) {
      _previousSymbol = symbol
    }

    def _emitNewlineBeforeStatement(node Node) {
      if _previousNode != null && (node.comments != null || !_isCompactNodeKind(_previousNode.kind) || !_isCompactNodeKind(node.kind)) {
        _emit("\n")
      }
      _previousNode = null
    }

    def _emitNewlineAfterStatement(node Node) {
      _previousNode = node
    }

    def _adjustNamespace(symbol Symbol) {
      # Get the namespace chain for this symbol
      var symbols List<Symbol> = []
      while symbol != null && symbol.kind != .OBJECT_GLOBAL {
        if symbol.kind == .OBJECT_NAMESPACE || symbol.kind == .OBJECT_WRAPPED {
          symbols.prepend(symbol)
        }
        symbol = symbol.parent
      }

      # Find the intersection
      var limit = Math.min(_namespaceStack.count, symbols.count)
      var i = 0
      while i < limit {
        if _namespaceStack[i] != symbols[i] {
          break
        }
        i++
      }

      # Leave the old namespace
      while _namespaceStack.count > i {
        var object = _namespaceStack.takeLast
        _decreaseIndent
        _emit(_indent + "}\n")
        _emitNewlineAfterSymbol(object)
      }

      # Enter the new namespace
      while _namespaceStack.count < symbols.count {
        var object = symbols[_namespaceStack.count]
        _emitNewlineBeforeSymbol(object, .DEFINE)
        _emit(_indent + "namespace " + _mangleName(object) + " {\n")
        _increaseIndent
        _namespaceStack.append(object)
      }
    }

    def _emitComments(comments List<string>) {
      if comments != null {
        for comment in comments {
          _emit(_indent + "//" + comment)
        }
      }
    }

    def _moveNestedObjectToEnclosingNamespace(symbol ObjectSymbol) {
      var parent = symbol.parent
      while parent != null && parent.kind == .OBJECT_CLASS {
        parent = parent.parent
      }
      symbol.parent = parent
    }

    def _declareObject(symbol ObjectSymbol) {
      if symbol.isImported {
        return
      }

      switch symbol.kind {
        case .OBJECT_ENUM, .OBJECT_FLAGS {
          _adjustNamespace(symbol)
          _emitNewlineBeforeSymbol(symbol, .DECLARE)
          if symbol.kind == .OBJECT_FLAGS {
            _emit(_indent + "struct " + _mangleName(symbol) + " {\n")
            _increaseIndent
            _emit(_indent + "enum {\n")
          } else {
            _emit(_indent + "enum struct " + _mangleName(symbol) + " {\n")
          }
          _increaseIndent
          for variable in symbol.variables {
            _emitVariable(variable, .DECLARE)
          }
          _decreaseIndent
          if symbol.kind == .OBJECT_FLAGS {
            _emit(_indent + "};\n")
            _decreaseIndent
          }
          _emit(_indent + "};\n")
          _emitNewlineAfterSymbol(symbol)
        }

        case .OBJECT_CLASS, .OBJECT_INTERFACE {
          _adjustNamespace(symbol)
          _emitNewlineBeforeSymbol(symbol, .DECLARE)
          _emitTypeParameters(symbol.parameters)
          _emit(_indent + "struct " + _mangleName(symbol) + ";\n")
          _emitNewlineAfterSymbol(symbol)
        }
      }
    }

    def _defineObject(symbol ObjectSymbol) {
      if symbol.isImported {
        return
      }

      switch symbol.kind {
        case .OBJECT_CLASS, .OBJECT_INTERFACE {
          _adjustNamespace(symbol)
          _emitNewlineBeforeSymbol(symbol, .DEFINE)
          _emitComments(symbol.comments)
          _emitTypeParameters(symbol.parameters)
          _emit(_indent + "struct " + _mangleName(symbol))
          if symbol.extends != null || symbol.implements != null {
            _emit(" : ")
            if symbol.extends != null {
              _emitExpressionOrType(symbol.extends, symbol.baseType, .BARE)
            }
            if symbol.implements != null {
              for node in symbol.implements {
                if node != symbol.implements.first || symbol.extends != null {
                  _emit(", ")
                }
                _emitExpressionOrType(node, node.resolvedType, .BARE)
              }
            }
          }
          _emit(" {\n")
          _increaseIndent
          for function in symbol.functions {
            _emitFunction(function, .DEFINE)
          }
          for variable in symbol.variables {
            _emitVariable(variable, .DEFINE)
          }
          _decreaseIndent
          _emit(_indent + "};\n")
          _emitNewlineAfterSymbol(symbol)
        }

        case .OBJECT_NAMESPACE, .OBJECT_WRAPPED {
          _adjustNamespace(symbol)
          for function in symbol.functions {
            _emitFunction(function, .DEFINE)
          }
        }
      }
    }

    def _emitFunction(symbol FunctionSymbol, mode CodeMode) {
      var parent = symbol.parent.asObjectSymbol
      var block = symbol.block

      if symbol.isImported || mode == .IMPLEMENT && block == null {
        return
      }

      # We can't use lambdas in C++ since they don't have the right semantics so no variable insertion is needed
      if symbol.this != null {
        symbol.this.name = "this"
        symbol.this.flags |= .IS_EXPORTED
      }

      _enclosingFunction = symbol
      _emitNewlineBeforeSymbol(symbol, mode)
      _emitComments(symbol.comments)
      if mode == .IMPLEMENT {
        _emitTypeParameters(parent.parameters) # TODO: Merge these with the ones on the symbol when symbols have both
      }
      _emitTypeParameters(symbol.parameters)
      _emit(_indent)
      if mode == .DEFINE && symbol.kind == .FUNCTION_GLOBAL && symbol.parent.kind == .OBJECT_CLASS {
        _emit("static ")
      }
      if symbol.kind != .FUNCTION_CONSTRUCTOR {
        if mode == .DEFINE && (symbol.isVirtual || block == null) {
          _emit("virtual ")
        }
        _emitExpressionOrType(symbol.returnType, symbol.resolvedType.returnType, .DECLARATION)
      }
      if mode == .IMPLEMENT && parent.kind != .OBJECT_GLOBAL {
        _emit(_fullName(parent))
        if parent.parameters != null {
          _emit("<")
          for parameter in parent.parameters {
            if parameter != parent.parameters.first {
              _emit(", ")
            }
            _emit(_mangleName(parameter))
          }
          _emit(">")
        }
        _emit("::")
      }
      _emit(_mangleName(symbol))
      _emitArgumentList(symbol)

      if mode == .IMPLEMENT {
        # Move the super constructor call out of the function body
        if symbol.kind == .FUNCTION_CONSTRUCTOR && block.hasChildren {
          var first = block.firstChild
          if first.kind == .EXPRESSION {
            var call = first.expressionValue
            if call.kind == .CALL && call.callValue.kind == .SUPER {
              _emit(" : ")
              first.remove
              _emitExpression(call, .LOWEST)
            }
          }
        }

        _emitBlock(block)
        _emit("\n")
      }

      else {
        if symbol.overridden != null && symbol.kind != .FUNCTION_CONSTRUCTOR {
          _emit(" override")
        }
        if block == null {
          _emit(" = 0")
        }
        _emit(";\n")
      }

      _emitNewlineAfterSymbol(symbol)
      _enclosingFunction = null
    }

    def _emitTypeParameters(parameters List<ParameterSymbol>) {
      if parameters != null {
        _emit(_indent + "template <")
        for parameter in parameters {
          if parameter != parameters.first {
            _emit(", ")
          }
          _emit("typename " + _mangleName(parameter))
        }
        _emit(">\n")
      }
    }

    def _emitArgumentList(symbol FunctionSymbol) {
      _emit("(")
      for argument in symbol.arguments {
        if argument != symbol.arguments.first {
          _emit(", ")
        }
        _emitExpressionOrType(argument.type, argument.resolvedType, .DECLARATION)
        _emit(_mangleName(argument))
      }
      _emit(")")
    }

    def _emitVariable(symbol VariableSymbol, mode CodeMode) {
      if symbol.isImported {
        return
      }

      # C++ can't forward-declare variables without also giving them external linkage
      var avoidFullName = symbol.kind == .VARIABLE_GLOBAL && symbol.parent.kind != .OBJECT_CLASS
      if mode == .IMPLEMENT && symbol.kind != .VARIABLE_LOCAL {
        _adjustNamespace(avoidFullName ? symbol.parent : null)
      }

      _emitNewlineBeforeSymbol(symbol, mode)
      if symbol.kind == .VARIABLE_ENUM_OR_FLAGS {
        _emit(_indent + _mangleName(symbol) + " = \(symbol.value.asInt),\n")
      } else {
        _emit(_indent)
        if mode == .DEFINE && symbol.kind == .VARIABLE_GLOBAL && symbol.parent.kind == .OBJECT_CLASS {
          _emit("static ")
        }
        _emitType(symbol.resolvedType, .DECLARATION)
        if mode == .DEFINE {
          _emit(_mangleName(symbol))
        } else {
          _emit(avoidFullName ? _mangleName(symbol) : _fullName(symbol))
          if symbol.value != null {
            _emit(" = ")
            _emitExpression(symbol.value, .ASSIGN)
          }
        }
        _emit(";\n")
      }
      _emitNewlineAfterSymbol(symbol)
    }

    def _emitStatements(node Node) {
      _previousNode = null

      for child = node.firstChild; child != null; child = child.nextSibling {
        _emitNewlineBeforeStatement(child)
        _emitComments(child.comments)
        _emitStatement(child)
        _emitNewlineAfterStatement(child)
      }

      _previousNode = null
    }

    def _emitBlock(node Node) {
      _emit(" {\n")
      _increaseIndent
      _emitStatements(node)
      _decreaseIndent
      _emit(_indent + "}")
    }

    def _scanForSwitchBreak(node Node, loop Node) {
      if node.kind == .BREAK {
        for parent = node.parent; parent != loop; parent = parent.parent {
          if parent.kind == .SWITCH {
            var label = _loopLabels.get(loop.id, null)
            if label == null {
              label = VariableSymbol.new(.VARIABLE_LOCAL, _enclosingFunction.scope.generateName("label"))
              _loopLabels[loop.id] = label
            }
            _loopLabels[node.id] = label
            break
          }
        }
      }

      # Stop at nested loops since those will be tested later
      else if node == loop || !node.kind.isLoop {
        for child = node.firstChild; child != null; child = child.nextSibling {
          _scanForSwitchBreak(child, loop)
        }
      }
    }

    def _emitStatement(node Node) {
      if node.kind.isLoop {
        _scanForSwitchBreak(node, node)
      }

      switch node.kind {
        case .VARIABLES {
          for child = node.firstChild; child != null; child = child.nextSibling {
            _emitVariable(child.symbol.asVariableSymbol, .IMPLEMENT)
          }
        }

        case .EXPRESSION {
          _emit(_indent)
          _emitExpression(node.expressionValue, .LOWEST)
          _emit(";\n")
        }

        case .BREAK {
          var label = _loopLabels.get(node.id, null)
          if label != null {
            _emit(_indent + "goto " + _mangleName(label) + ";\n")
          } else {
            _emit(_indent + "break;\n")
          }
        }

        case .CONTINUE {
          _emit(_indent + "continue;\n")
        }

        case .IF {
          _emit(_indent)
          _emitIf(node)
          _emit("\n")
        }

        case .SWITCH {
          var switchValue = node.switchValue
          _emit(_indent + "switch (")
          _emitExpression(switchValue, .LOWEST)
          _emit(") {\n")
          _increaseIndent
          for child = switchValue.nextSibling; child != null; child = child.nextSibling {
            var block = child.caseBlock
            if child.previousSibling != switchValue {
              _emit("\n")
            }
            if child.hasOneChild {
              _emit(_indent + "default:")
            } else {
              for value = child.firstChild; value != block; value = value.nextSibling {
                if value.previousSibling != null {
                  _emit("\n")
                }
                _emit(_indent + "case ")
                _emitExpression(value, .LOWEST)
                _emit(":")
              }
            }
            _emit(" {\n")
            _increaseIndent
            _emitStatements(block)
            if block.hasControlFlowAtEnd {
              _emit(_indent + "break;\n")
            }
            _decreaseIndent
            _emit(_indent + "}\n")
          }
          _decreaseIndent
          _emit(_indent + "}\n")
        }

        case .RETURN {
          _emit(_indent + "return")
          var value = node.returnValue
          if value != null {
            _emit(" ")
            _emitExpression(value, .LOWEST)
          }
          _emit(";\n")
        }

        case .THROW {
          _emit(_indent + "throw ")
          _emitExpression(node.throwValue, .LOWEST)
          _emit(";\n")
        }

        case .FOR {
          var setup = node.forSetup
          var test = node.forTest
          var update = node.forUpdate
          _emit(_indent + "for (")
          if !setup.isEmptySequence {
            if setup.kind == .VARIABLES {
              _emitType(setup.firstChild.symbol.asVariableSymbol.resolvedType, .DECLARATION)
              for child = setup.firstChild; child != null; child = child.nextSibling {
                var symbol = child.symbol.asVariableSymbol
                assert(child.kind == .VARIABLE)
                if child.previousSibling != null {
                  _emit(", ")
                  if _isReferenceType(symbol.resolvedType) {
                    _emit("*")
                  }
                }
                _emit(_mangleName(symbol) + " = ")
                _emitExpression(symbol.value, .COMMA)
              }
            } else {
              _emitExpression(setup, .LOWEST)
            }
          }
          _emit("; ")
          if !test.isEmptySequence {
            _emitExpression(test, .LOWEST)
          }
          _emit("; ")
          if !update.isEmptySequence {
            _emitExpression(update, .LOWEST)
          }
          _emit(")")
          _emitBlock(node.forBlock)
          _emit("\n")
        }

        case .TRY {
          var tryBlock = node.tryBlock
          var finallyBlock = node.finallyBlock
          _emit(_indent + "try")
          _emitBlock(tryBlock)
          _emit("\n")

          for child = tryBlock.nextSibling; child != finallyBlock; child = child.nextSibling {
            if child.comments != null {
              _emit("\n")
              _emitComments(child.comments)
            }
            _emit(_indent + "catch")
            if child.symbol != null {
              _emit(" (")
              _emitType(child.symbol.resolvedType, .DECLARATION)
              _emit(_mangleName(child.symbol) + ")")
            } else {
              _emit(" (...)")
            }
            _emitBlock(child.catchBlock)
            _emit("\n")
          }

          if finallyBlock != null {
            if finallyBlock.comments != null {
              _emit("\n")
              _emitComments(finallyBlock.comments)
            }
            _emit(_indent + "finally")
            _emitBlock(finallyBlock)
            _emit("\n")
          }
        }

        case .WHILE {
          _emit(_indent + "while (")
          _emitExpression(node.whileTest, .LOWEST)
          _emit(")")
          _emitBlock(node.whileBlock)
          _emit("\n")
        }

        case .FOREACH {
          var symbol = node.symbol.asVariableSymbol
          var value = node.foreachValue
          _emit(_indent + "for (")
          _emitType(symbol.resolvedType, .DECLARATION)
          _emit(_mangleName(symbol) + " : ")
          if _isReferenceType(value.resolvedType) {
            _emit("*")
            _emitExpression(value, .UNARY_PREFIX)
          } else {
            _emitExpression(value, .LOWEST)
          }
          _emit(")")
          _emitBlock(node.foreachBlock)
          _emit("\n")
        }

        default {
          assert(false)
        }
      }

      if node.kind.isLoop {
        var label = _loopLabels.get(node.id, null)
        if label != null {
          _emit(_indent + _mangleName(label) + (node.nextSibling != null ? ":\n" : ":;\n"))
        }
      }
    }

    def _emitIf(node Node) {
      _emit("if (")
      _emitExpression(node.ifTest, .LOWEST)
      _emit(")")
      _emitBlock(node.ifTrue)

      var block = node.ifFalse
      if block != null {
        var singleIf = block.hasOneChild && block.firstChild.kind == .IF ? block.firstChild : null
        _emit("\n\n")
        _emitComments(block.comments)
        if singleIf != null {
          _emitComments(singleIf.comments)
        }
        _emit(_indent + "else")

        if singleIf != null {
          _emit(" ")
          _emitIf(singleIf)
        } else {
          _emitBlock(block)
        }
      }
    }

    def _emitContent(content Content) {
      switch content.kind {
        case .BOOL { _emit(content.asBool.toString) }
        case .INT { _emit(content.asInt.toString) }
        case .DOUBLE {
          var value = content.asDouble
          if !value.isFinite {
            _includeNames["<math.h>"] = 0
          }
          _emit(
            value.isNaN ? "NAN" :
            value == Math.INFINITY ? "INFINITY" :
            value == -Math.INFINITY ? "-INFINITY" :
            doubleToStringWithDot(value))
        }
        case .STRING { _emit(quoteString(content.asString, .DOUBLE, .OCTAL_WORKAROUND) + "_s") }
      }
    }

    def _emitCommaSeparatedExpressions(from Node, to Node) {
      while from != to {
        _emitExpression(from, .COMMA)
        from = from.nextSibling
        if from != to {
          _emit(", ")
        }
      }
    }

    def _emitExpression(node Node, precedence Precedence) {
      var kind = node.kind
      var symbol = node.symbol

      if symbol != null {
        _handleSymbol(symbol)
      }

      switch kind {
        case .TYPE, .LAMBDA_TYPE {
          _emitType(node.resolvedType, .BARE)
        }

        case .NULL {
          _emit("nullptr")
        }

        case .NAME {
          _emit(symbol != null ? _fullName(symbol) : node.asString)
        }

        case .DOT {
          var target = node.dotTarget
          var type = target.resolvedType
          _emitExpression(target, .MEMBER)
          _emit((type != null && _isReferenceType(type) ? "->" : ".") + (symbol != null ? _mangleName(symbol) : node.asString))
        }

        case .CONSTANT {
          if node.resolvedType.isEnumOrFlags {
            _emit("(")
            _emitType(node.resolvedType, .NORMAL)
            _emit(")")
          }
          _emitContent(node.content)
        }

        case .CALL {
          var value = node.callValue
          var wrap = false

          if value.kind == .SUPER {
            _emit(_fullName(symbol))
          }

          else if symbol != null && symbol.kind == .FUNCTION_CONSTRUCTOR {
            wrap = precedence == Precedence.MEMBER
            if wrap {
              _emit("(")
            }
            _emit("new ")
            _emitType(node.resolvedType, .BARE)
          }

          else if value.kind == .DOT && value.asString == "new" {
            _emit("new ")
            _emitExpression(value.dotTarget, .MEMBER)
          }

          else {
            _emitExpression(value, .UNARY_POSTFIX)
          }

          _emit("(")
          _emitCommaSeparatedExpressions(node.firstChild.nextSibling, null)
          _emit(")")

          if wrap {
            _emit(")")
          }
        }

        case .CAST {
          var resolvedType = node.resolvedType
          var type = node.castType
          var value = node.castValue

          if value.kind == .NULL && node.resolvedType == _cache.stringType {
            _emit("string()")
          }

          else if type.kind == .TYPE && type.resolvedType == .DYNAMIC {
            _emitExpression(value, precedence)
          }

          # Automatically promote integer literals to doubles instead of using a cast
          else if _cache.isEquivalentToDouble(resolvedType) && value.isInt {
            _emitExpression(_cache.createDouble(value.asInt), precedence)
          }

          # Only emit a cast if the underlying types are different
          else if _unwrappedType(value.resolvedType) != _unwrappedType(type.resolvedType) || type.resolvedType == .DYNAMIC {
            if Precedence.UNARY_POSTFIX < precedence {
              _emit("(")
            }
            _emit("(")
            _emitExpressionOrType(type, resolvedType, .NORMAL)
            _emit(")")
            _emitExpression(value, .UNARY_POSTFIX)
            if Precedence.UNARY_POSTFIX < precedence {
              _emit(")")
            }
          }

          # Otherwise, pretend the cast isn't there
          else {
            _emitExpression(value, precedence)
          }
        }

        case .INDEX {
          var left = node.indexLeft
          if _isReferenceType(left.resolvedType) {
            _emit("(*")
            _emitExpression(left, .UNARY_PREFIX)
            _emit(")")
          } else {
            _emitExpression(left, .UNARY_POSTFIX)
          }
          _emit("[")
          _emitExpression(node.indexRight, .LOWEST)
          _emit("]")
        }

        case .ASSIGN_INDEX {
          var left = node.assignIndexLeft
          if Precedence.ASSIGN < precedence {
            _emit("(")
          }
          if _isReferenceType(left.resolvedType) {
            _emit("(*")
            _emitExpression(left, .UNARY_PREFIX)
            _emit(")")
          } else {
            _emitExpression(left, .UNARY_POSTFIX)
          }
          _emit("[")
          _emitExpression(node.assignIndexCenter, .LOWEST)
          _emit("] = ")
          _emitExpression(node.assignIndexRight, .ASSIGN)
          if Precedence.ASSIGN < precedence {
            _emit(")")
          }
        }

        case .PARAMETERIZE {
          var value = node.parameterizeValue
          if value.isType {
            _emitType(node.resolvedType, .NORMAL)
          } else {
            _emitExpression(value, precedence)
            _emit("<")
            for child = value.nextSibling; child != null; child = child.nextSibling {
              if child.previousSibling != value {
                _emit(", ")
              }
              _emitType(child.resolvedType, .NORMAL)
            }
            _emit(">")
          }
        }

        case .SEQUENCE {
          if Precedence.COMMA <= precedence {
            _emit("(")
          }
          _emitCommaSeparatedExpressions(node.firstChild, null)
          if Precedence.COMMA <= precedence {
            _emit(")")
          }
        }

        case .HOOK {
          if Precedence.ASSIGN < precedence {
            _emit("(")
          }
          _emitExpression(node.hookTest, .LOGICAL_OR)
          _emit(" ? ")
          _emitExpression(node.hookTrue, .ASSIGN)
          _emit(" : ")
          _emitExpression(node.hookFalse, .ASSIGN)
          if Precedence.ASSIGN < precedence {
            _emit(")")
          }
        }

        case .INITIALIZER_LIST, .INITIALIZER_MAP {
          _emit("new ")
          _emitType(node.resolvedType, .BARE)
          if node.hasChildren {
            _emit("({")
            _emitCommaSeparatedExpressions(node.firstChild, null)
            _emit("})")
          } else {
            _emit("()")
          }
        }

        case .PAIR {
          _includeNames["<utility>"] = 0
          _emit("std::make_pair(")
          _emitCommaSeparatedExpressions(node.firstChild, null)
          _emit(")")
        }

        case .COMPLEMENT, .NEGATIVE, .NOT, .POSITIVE, .POSTFIX_DECREMENT, .POSTFIX_INCREMENT, .PREFIX_DECREMENT, .PREFIX_INCREMENT {
          var value = node.unaryValue
          var info = operatorInfo[kind]
          if info.precedence < precedence {
            _emit("(")
          }
          if !kind.isUnaryPostfix {
            _emit(info.text)
          }
          _emitExpression(value, info.precedence)
          if kind.isUnaryPostfix {
            _emit(info.text)
          }
          if info.precedence < precedence {
            _emit(")")
          }
        }

        default {
          if kind.isBinary {
            # Clang warns about "&&" inside "||" or "&" inside "|" without parentheses
            var parent = node.parent
            if parent != null && (
                parent.kind == .LOGICAL_OR && kind == .LOGICAL_AND ||
                parent.kind == .BITWISE_OR && kind == .BITWISE_AND) {
              precedence = .MEMBER
            }

            var info = operatorInfo[kind]
            if info.precedence < precedence {
              _emit("(")
            }
            _emitExpression(node.binaryLeft, info.precedence.incrementIfRightAssociative(info.associativity))
            _emit(" " + info.text + " ")
            _emitExpression(node.binaryRight, info.precedence.incrementIfLeftAssociative(info.associativity))
            if info.precedence < precedence {
              _emit(")")
            }
          }

          else {
            assert(false)
          }
        }
      }
    }

    enum CppEmitMode {
      BARE
      NORMAL
      DECLARATION
    }

    def _emitExpressionOrType(node Node, type Type, mode CppEmitMode) {
      if node != null && (type == null || type == .DYNAMIC) {
        _emitExpression(node, .LOWEST)
        if mode == .DECLARATION {
          _emit(" ")
        }
      } else {
        _emitType(type, mode)
      }
    }

    def _emitType(type Type, mode CppEmitMode) {
      if type == null {
        _emit("void")
      }

      else {
        type = _unwrappedType(type)

        if type == .DYNAMIC {
          _emit("void")
        }

        else if type.kind == .LAMBDA {
          var hasReturnType = type.returnType != null
          var argumentCount = type.argumentTypes.count
          _emit((hasReturnType ? "Fn" : "FnVoid") + "\(argumentCount)")
          if hasReturnType || argumentCount != 0 {
            _emit("<")
            if hasReturnType {
              _emitType(type.returnType, .NORMAL)
            }
            for i in 0..argumentCount {
              if i != 0 || hasReturnType {
                _emit(", ")
              }
              _emitType(type.argumentTypes[i], .NORMAL)
            }
            _emit(">")
          }
        }

        else {
          assert(type.kind == .SYMBOL)
          _handleSymbol(type.symbol)
          _emit(_fullName(type.symbol))

          if type.isParameterized {
            _emit("<")
            for i in 0..type.substitutions.count {
              if i != 0 {
                _emit(", ")
              }
              _emitType(type.substitutions[i], .NORMAL)
            }
            _emit(">")
          }
        }
      }

      if type != null && _isReferenceType(type) && mode != .BARE {
        _emit(" *")
      } else if mode == .DECLARATION {
        _emit(" ")
      }
    }

    def _unwrappedType(type Type) Type {
      return type.isFlags ? _cache.intType : _cache.unwrappedType(type)
    }

    def _isReferenceType(type Type) bool {
      return type.isReference && type != _cache.stringType
    }

    def _finalizeEmittedFile {
      var includes = _includeNames.keys

      if !includes.isEmpty {
        includes.sort((a, b) => a <=> b)
        for include in includes {
          _emitPrefix("#include " + (include.startsWith("<") && include.endsWith(">") ? include : "\"" + include + "\"") + "\n")
        }
        _emitPrefix("\n")
      }

      _adjustNamespace(null)
      _previousSymbol = null
      _symbolsCheckedForInclude = {}
      _includeNames = {}
    }

    def _handleSymbol(symbol Symbol) {
      if !symbol.kind.isLocal && !(symbol.id in _symbolsCheckedForInclude) {
        _symbolsCheckedForInclude[symbol.id] = 0

        if symbol.annotations != null {
          for annotation in symbol.annotations {
            if annotation.symbol != null && annotation.symbol.fullName == "include" {
              var value = annotation.annotationValue
              if value.childCount == 2 {
                _includeNames[value.lastChild.asString] = 0
              }
            }
          }
        }

        if symbol.parent != null {
          _handleSymbol(symbol.parent)
        }
      }
    }
  }

  namespace CPlusPlusEmitter {
    def _isCompactNodeKind(kind NodeKind) bool {
      return kind == .EXPRESSION || kind == .VARIABLES || kind.isJump
    }

    def _fullName(symbol Symbol) string {
      var parent = symbol.parent
      if parent != null && parent.kind != .OBJECT_GLOBAL && !symbol.kind.isParameter {
        return _fullName(parent) + "::" + _mangleName(symbol)
      }
      return _mangleName(symbol)
    }

    def _mangleName(symbol Symbol) string {
      symbol = symbol.forwarded
      if symbol.kind == .FUNCTION_CONSTRUCTOR {
        return _mangleName(symbol.parent)
      }
      if !symbol.isImportedOrExported && symbol.name in _isKeyword {
        return "_" + symbol.name
      }
      return symbol.name
    }

    const _isKeyword = {
      "alignas": 0,
      "alignof": 0,
      "and": 0,
      "and_eq": 0,
      "asm": 0,
      "auto": 0,
      "bitand": 0,
      "bitor": 0,
      "bool": 0,
      "break": 0,
      "case": 0,
      "catch": 0,
      "char": 0,
      "char16_t": 0,
      "char32_t": 0,
      "class": 0,
      "compl": 0,
      "const": 0,
      "const_cast": 0,
      "constexpr": 0,
      "continue": 0,
      "decltype": 0,
      "default": 0,
      "delete": 0,
      "do": 0,
      "double": 0,
      "dynamic_cast": 0,
      "else": 0,
      "enum": 0,
      "explicit": 0,
      "export": 0,
      "extern": 0,
      "false": 0,
      "float": 0,
      "for": 0,
      "friend": 0,
      "goto": 0,
      "if": 0,
      "INFINITY": 0,
      "inline": 0,
      "int": 0,
      "long": 0,
      "mutable": 0,
      "namespace": 0,
      "NAN": 0,
      "new": 0,
      "noexcept": 0,
      "not": 0,
      "not_eq": 0,
      "NULL": 0,
      "nullptr": 0,
      "operator": 0,
      "or": 0,
      "or_eq": 0,
      "private": 0,
      "protected": 0,
      "public": 0,
      "register": 0,
      "reinterpret_cast": 0,
      "return": 0,
      "short": 0,
      "signed": 0,
      "sizeof": 0,
      "static": 0,
      "static_assert": 0,
      "static_cast": 0,
      "struct": 0,
      "switch": 0,
      "template": 0,
      "this": 0,
      "thread_local": 0,
      "throw": 0,
      "true": 0,
      "try": 0,
      "typedef": 0,
      "typeid": 0,
      "typename": 0,
      "union": 0,
      "unsigned": 0,
      "using": 0,
      "virtual": 0,
      "void": 0,
      "volatile": 0,
      "wchar_t": 0,
      "while": 0,
      "xor": 0,
      "xor_eq": 0,
    }
  }
}
