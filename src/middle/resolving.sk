namespace Skew {
  enum PassKind {
    RESOLVING
  }

  class ResolvingPass : Pass {
    over kind PassKind {
      return .RESOLVING
    }

    over run(context PassContext) {
      context.cache.loadGlobals(context.log, context.global)
      if !context.log.hasErrors {
        Resolving.Resolver.new(context.global, context.options, context.options.defines.clone, context.cache, context.log).resolve
      }
    }
  }
}

namespace Skew.Resolving {
  enum ConversionKind {
    IMPLICIT
    EXPLICIT
  }

  enum SymbolStatistic {
    READ
    WRITE
  }

  class LocalVariableStatistics {
    var symbol VariableSymbol
    var readCount = 0
    var writeCount = 0
  }

  class Resolver {
    const _global ObjectSymbol
    const _options CompilerOptions
    const _defines StringMap<Define>
    const _cache TypeCache
    const _log Log
    const _foreachLoops List<Node> = []
    const _localVariableStatistics IntMap<LocalVariableStatistics> = {}
    const _controlFlow = ControlFlowAnalyzer.new
    var _constantFolder Folding.ConstantFolder = null
    var _isMergingGuards = true

    def resolve {
      _constantFolder = Folding.ConstantFolder.new(_cache, _options, symbol => _initializeSymbol(symbol))
      _initializeGlobals
      _iterativelyMergeGuards
      _resolveGlobal
      _removeObsoleteFunctions(_global)
    }

    # Put the guts of the function inside another function because V8 doesn't
    # optimize functions with try-catch statements
    def _initializeSymbolSwitch(symbol Symbol) {
      switch symbol.kind {
        case .OBJECT_CLASS, .OBJECT_ENUM, .OBJECT_GLOBAL, .OBJECT_INTERFACE, .OBJECT_NAMESPACE, .OBJECT_WRAPPED {
          _initializeObject(symbol.asObjectSymbol)
        }

        case .FUNCTION_ANNOTATION, .FUNCTION_CONSTRUCTOR, .FUNCTION_GLOBAL, .FUNCTION_INSTANCE, .FUNCTION_LOCAL {
          _initializeFunction(symbol.asFunctionSymbol)
        }

        case .VARIABLE_ARGUMENT, .VARIABLE_ENUM, .VARIABLE_GLOBAL, .VARIABLE_INSTANCE, .VARIABLE_LOCAL {
          _initializeVariable(symbol.asVariableSymbol)
        }

        case .PARAMETER_FUNCTION, .PARAMETER_OBJECT {
          _initializeParameter(symbol.asParameterSymbol)
        }

        case .OVERLOADED_ANNOTATION, .OVERLOADED_GLOBAL, .OVERLOADED_INSTANCE {
          _initializeOverloadedFunction(symbol.asOverloadedFunctionSymbol)
        }

        default {
          assert(false)
        }
      }
    }

    def _initializeSymbol(symbol Symbol) {
      # The scope should have been set by the merging pass (or by this pass for local variables)
      assert(symbol.scope != null)

      # Only initialize the symbol once
      if symbol.state == .UNINITIALIZED {
        symbol.state = .INITIALIZING

        try {
          _initializeSymbolSwitch(symbol)
        }

        # If guard merging failed, reset the type so we'll try again next time
        catch failure GuardMergingFailure {
          symbol.state = .UNINITIALIZED
          throw failure
        }

        assert(symbol.resolvedType != null)
        symbol.state = .INITIALIZED

        if symbol.kind.isFunction {
          var function = symbol.asFunctionSymbol
          var overloaded = function.overloaded

          # After initializing a function symbol, ensure the entire overload set is initialized
          if overloaded != null && overloaded.state == .UNINITIALIZED {
            _initializeSymbol(overloaded)
          }
        }
      }

      # Detect cyclic symbol references such as "foo foo;"
      else if symbol.state == .INITIALIZING {
        _log.semanticErrorCyclicDeclaration(symbol.range, symbol.name)
        symbol.resolvedType = .DYNAMIC
      }
    }

    def _validateEntryPoint(symbol FunctionSymbol) {
      # Detect duplicate entry points
      if _cache.entryPointSymbol != null {
        _log.semanticErrorDuplicateEntryPoint(symbol.range, _cache.entryPointSymbol.range)
        return
      }

      _cache.entryPointSymbol = symbol

      # Only recognize a few entry point types
      var type = symbol.resolvedType
      if type != .DYNAMIC {
        var argumentTypes = type.argumentTypes

        # The argument list must be empty or one argument of type "List<string>"
        if argumentTypes.count > 1 || argumentTypes.count == 1 && argumentTypes.first != _cache.createListType(_cache.stringType) {
          _log.semanticErrorInvalidEntryPointArguments(Range.span(symbol.arguments.first.range, symbol.arguments.last.type.range), symbol.name)
        }

        # The return type must be nothing or "int"
        else if type.returnType != null && type.returnType != _cache.intType {
          _log.semanticErrorInvalidEntryPointReturnType(symbol.returnType.range, symbol.name)
        }
      }
    }

    def _resolveDefines(symbol VariableSymbol) {
      var key = symbol.fullName
      var define = _defines.get(key, null)

      if define == null {
        return
      }

      # Remove the define so we can tell what defines weren't used later on
      _defines.remove(key)

      var type = symbol.resolvedType
      var range = define.value
      var value = range.toString
      var node Node = null

      # Special-case booleans
      if type == _cache.boolType {
        if value == "true" || value == "false" {
          node = Node.createBool(value == "true")
        }
      }

      # Special-case doubles
      else if type == _cache.doubleType {
        var number = Parsing.parseDoubleLiteral(value)
        if !number.isNaN {
          node = Node.createDouble(number)
        }
      }

      # Special-case strings
      else if type == _cache.stringType {
        node = Node.createString(value)
      }

      # Special-case enums
      else if type.isEnum {
        node = Node.createDot(null, value)
      }

      # Integers can also apply to doubles
      if node == null && _cache.isNumeric(type) {
        var box = Parsing.parseIntLiteral(_log, range)
        if box != null {
          node = Node.createInt(box.value)
        }
      }

      # Stop if anything failed above
      if node == null {
        _log.semanticErrorInvalidDefine(range, value, type, key)
        return
      }

      _resolveAsParameterizedExpressionWithConversion(node.withRange(range), _global.scope, type)
      symbol.value = node
    }

    def _resolveAnnotations(symbol Symbol) {
      var parent = symbol.parent
      var annotations = symbol.annotations

      # The import/export annotations are inherited, except import isn't inherited for implemented functions
      if parent != null {
        symbol.flags |= parent.flags & (symbol.kind.isFunction && symbol.asFunctionSymbol.block != null ? Symbol.IS_EXPORTED : Symbol.IS_IMPORTED | Symbol.IS_EXPORTED)
      }

      # Resolve annotations on this symbol after annotation inheritance. Don't
      # use removeIf() since this annotation list may be shared elsewhere.
      if annotations != null {
        symbol.annotations = annotations.filter(annotation => _resolveAnnotation(annotation, symbol))
      }

      # Protected access used to be an annotation. It's now indicated with just
      # a leading underscore.
      if symbol.name.startsWith("_") && !symbol.kind.isLocal {
        symbol.flags |= Symbol.IS_PROTECTED
      }
    }

    def _resolveParameters(parameters List<ParameterSymbol>) {
      if parameters != null {
        for parameter in parameters {
          _resolveParameter(parameter)
        }
      }
    }

    def _initializeParameter(symbol ParameterSymbol) {
      if symbol.resolvedType == null {
        symbol.resolvedType = Type.new(.SYMBOL, symbol)
      }

      _resolveAnnotations(symbol)
    }

    def _resolveParameter(symbol ParameterSymbol) {
      _initializeSymbol(symbol)
    }

    def _initializeObject(symbol ObjectSymbol) {
      var kind = symbol.kind
      var extends = symbol.extends
      var implements = symbol.implements

      if symbol.resolvedType == null {
        symbol.resolvedType = Type.new(.SYMBOL, symbol)
      }

      _resolveParameters(symbol.parameters)

      # Resolve the base type (only for classes and wrapped types)
      if extends != null {
        _resolveAsParameterizedType(extends, symbol.scope)
        var baseType = extends.resolvedType
        if kind == .OBJECT_WRAPPED {
          symbol.wrappedType = baseType
          symbol.resolvedType.environment = baseType.environment # Don't lose the type parameters from the base type
        } else if kind != .OBJECT_CLASS || (baseType != .DYNAMIC && (!baseType.isClass || baseType.symbol.isValueType)) {
          _log.semanticErrorInvalidExtends(extends.range, baseType)
        } else if baseType != .DYNAMIC {
          symbol.baseType = baseType
          symbol.baseClass = baseType.symbol.asObjectSymbol
          symbol.resolvedType.environment = baseType.environment # Don't lose the type parameters from the base type

          # Copy members from the base type
          var functions List<FunctionSymbol> = []
          for member in symbol.baseClass.members.values {
            var memberKind = member.kind

            # Separate out functions
            if memberKind.isFunction {
              if memberKind != .FUNCTION_CONSTRUCTOR {
                functions.append(member.asFunctionSymbol)
              }
            }

            # Include overloaded functions individually
            else if memberKind.isOverloadedFunction {
              for function in member.asOverloadedFunctionSymbol.symbols {
                if function.kind != .FUNCTION_CONSTRUCTOR {
                  functions.append(function)
                }
              }
            }

            # Other kinds
            else if !memberKind.isParameter {
              var other = symbol.members.get(member.name, null)
              if other != null {
                _log.semanticErrorBadOverride(other.range, other.name, baseType, member.range)
              } else {
                symbol.members[member.name] = member
              }
            }
          }
          Merging.mergeFunctions(_log, symbol, functions, .INTO_DERIVED_CLASS)
        }
      }

      # Wrapped types without something to wrap don't make sense
      else if kind == .OBJECT_WRAPPED {
        _log.semanticErrorMissingWrappedType(symbol.range, symbol.fullName)
      }

      # Resolve the base interface types
      if implements != null {
        symbol.interfaceTypes = []
        for i in 0..implements.count {
          var type = implements[i]
          _resolveAsParameterizedType(type, symbol.scope)

          # Ignore the dynamic type, which will be from errors and dynamic expressions used for exports
          var interfaceType = type.resolvedType
          if interfaceType == .DYNAMIC {
            continue
          }

          # Only classes can derive from interfaces
          if kind != .OBJECT_CLASS || !interfaceType.isInterface {
            _log.semanticErrorInvalidImplements(type.range, interfaceType)
            continue
          }

          # An interface can only be implemented once
          for j in 0..i {
            var other = implements[j]
            if other.resolvedType == interfaceType {
              _log.semanticErrorDuplicateImplements(type.range, interfaceType, other.range)
              break
            }
          }

          symbol.interfaceTypes.append(interfaceType)
        }
      }

      # Assign values for all enums before they are initialized
      if kind == .OBJECT_ENUM {
        var nextEnumValue = 0
        for variable in symbol.variables {
          if variable.kind == .VARIABLE_ENUM {
            variable.value = Node.createInt(nextEnumValue).withType(symbol.resolvedType).withRange(variable.range)
            nextEnumValue++
          }
        }
        symbol.flags |= Symbol.IS_VALUE_TYPE
      }

      _resolveAnnotations(symbol)

      # Create a default constructor if one doesn't exist
      var constructor = symbol.members.get("new", null)
      if kind == .OBJECT_CLASS && !symbol.isImported && constructor == null {
        var baseConstructor = symbol.baseClass?.members.get("new", null)

        # Unwrap the overload group if present
        if baseConstructor != null && baseConstructor.kind == .OVERLOADED_GLOBAL {
          var overloaded = baseConstructor.asOverloadedFunctionSymbol
          for overload in overloaded.symbols {
            if overload.kind == .FUNCTION_CONSTRUCTOR {
              if baseConstructor.kind == .FUNCTION_CONSTRUCTOR {
                baseConstructor = null # Signal that there isn't a single base constructor
                break
              }
              baseConstructor = overload
            }
          }
        }

        # A default constructor can only be created if the base class has a single constructor
        if symbol.baseClass == null || baseConstructor != null && baseConstructor.kind == .FUNCTION_CONSTRUCTOR {
          var generated = FunctionSymbol.new(.FUNCTION_CONSTRUCTOR, "new")
          generated.scope = FunctionScope.new(symbol.scope, generated)
          generated.flags |= Symbol.IS_AUTOMATICALLY_GENERATED
          generated.parent = symbol
          generated.range = symbol.range
          generated.overridden = baseConstructor?.asFunctionSymbol
          symbol.functions.append(generated)
          symbol.members[generated.name] = generated
        }
      }

      # Create a default toString if one doesn't exist
      if kind == .OBJECT_ENUM && !symbol.isImported && !("toString" in symbol.members) {
        var generated = FunctionSymbol.new(.FUNCTION_INSTANCE, "toString")
        generated.scope = FunctionScope.new(symbol.scope, generated)
        generated.flags |= Symbol.IS_AUTOMATICALLY_GENERATED
        generated.parent = symbol
        generated.range = symbol.range
        symbol.functions.append(generated)
        symbol.members[generated.name] = generated
      }
    }

    def _checkInterfacesAndAbstractStatus(object ObjectSymbol, function FunctionSymbol) {
      assert(function.kind == .FUNCTION_INSTANCE)
      assert(function.state == .INITIALIZED)

      if !object.isAbstract && !function.isImported && !function.isObsolete && function.block == null {
        object.isAbstractBecauseOf = function
      }
    }

    def _checkInterfacesAndAbstractStatus(symbol ObjectSymbol) {
      assert(symbol.state == .INITIALIZED)

      if symbol.hasCheckedInterfacesAndAbstractStatus || symbol.kind != .OBJECT_CLASS {
        return
      }

      symbol.hasCheckedInterfacesAndAbstractStatus = true

      # Check to see if this class is abstract (as unimplemented members)
      for member in symbol.members.values {
        if member.kind == .OVERLOADED_INSTANCE {
          _initializeSymbol(member)
          for function in member.asOverloadedFunctionSymbol.symbols {
            _checkInterfacesAndAbstractStatus(symbol, function)
          }
        } else if member.kind == .FUNCTION_INSTANCE {
          _initializeSymbol(member)
          _checkInterfacesAndAbstractStatus(symbol, member.asFunctionSymbol)
        }
        if symbol.isAbstract {
          break
        }
      }

      # Check interfaces for missing implementations
      if symbol.interfaceTypes != null {
        for interfaceType in symbol.interfaceTypes {
          for function in interfaceType.symbol.asObjectSymbol.functions {
            if function.kind != .FUNCTION_INSTANCE || function.block != null {
              continue
            }
            _initializeSymbol(function)

            var member = symbol.members.get(function.name, null)
            var match FunctionSymbol = null

            # Search for a matching function
            if member != null {
              if member.kind == .OVERLOADED_INSTANCE {
                for other in member.asOverloadedFunctionSymbol.symbols {
                  if other.argumentOnlyType == function.argumentOnlyType {
                    match = other
                    break
                  }
                }
              } else if member.kind == .FUNCTION_INSTANCE {
                if member.asFunctionSymbol.argumentOnlyType == function.argumentOnlyType {
                  match = member.asFunctionSymbol
                }
              }
            }

            # Validate use of the interface
            if match == null {
              _log.semanticErrorBadInterfaceImplementation(symbol.range, symbol.resolvedType, interfaceType, function.name, function.range)
            } else if function.resolvedType.returnType != match.resolvedType.returnType {
              _log.semanticErrorBadInterfaceImplementationReturnType(match.range, match.name, interfaceType, function.range)
            } else {
              if function.implementations == null {
                function.implementations = []
              }
              function.implementations.append(match)
            }
          }
        }
      }
    }

    def _initializeGlobals {
      _initializeSymbol(_cache.boolType.symbol)
      _initializeSymbol(_cache.doubleType.symbol)
      _initializeSymbol(_cache.intMapType.symbol)
      _initializeSymbol(_cache.intType.symbol)
      _initializeSymbol(_cache.listType.symbol)
      _initializeSymbol(_cache.stringMapType.symbol)
      _initializeSymbol(_cache.stringType.symbol)
    }

    def _resolveGlobal {
      _resolveObject(_global)
      _scanLocalVariables
      _convertForeachLoops
      _discardUnusedDefines
    }

    # An obsolete function is one without an implementation that was dropped in
    # favor of one with an implementation:
    #
    #   namespace Foo {
    #     def foo {}
    #
    #     # This will be marked as obsolete
    #     def foo
    #   }
    #
    def _removeObsoleteFunctions(symbol ObjectSymbol) {
      for object in symbol.objects {
        _removeObsoleteFunctions(object)
      }
      symbol.functions.removeIf(function => function.isObsolete)
    }

    def _iterativelyMergeGuards {
      var guards List<Guard>

      # Iterate until a fixed point is reached
      while true {
        guards = []
        _scanForGuards(_global, guards)
        if guards.isEmpty {
          break
        }

        # Each iteration must remove at least one guard to continue
        if !_processGuards(guards) {
          break
        }
      }

      _isMergingGuards = false

      # All remaining guards are errors
      for guard in guards {
        var count = _log.errorCount
        _resolveAsParameterizedExpressionWithConversion(guard.test, guard.parent.scope, _cache.boolType)
        if _log.errorCount == count {
          _log.semanticErrorExpectedConstant(guard.test.range)
        }
      }
    }

    def _scanForGuards(symbol ObjectSymbol, guards List<Guard>) {
      if symbol.guards != null {
        guards.append(symbol.guards)
      }

      for object in symbol.objects {
        _scanForGuards(object, guards)
      }
    }

    if TARGET == .CSHARP {
      class GuardMergingFailure : dynamic.System.Exception {
      }
    }

    else {
      class GuardMergingFailure {
      }
    }

    def _reportGuardMergingFailure(node Node) {
      if _isMergingGuards {
        throw GuardMergingFailure.new
      }
    }

    def _attemptToResolveGuardConstant(node Node, scope Scope) bool {
      assert(scope != null)
      try {
        _resolveAsParameterizedExpressionWithConversion(node, scope, _cache.boolType)
        _constantFolder.foldConstants(node)
        return true
      } catch failure GuardMergingFailure {
      }
      return false
    }

    def _processGuards(guards List<Guard>) bool {
      var wasGuardRemoved = false

      for guard in guards {
        var test = guard.test
        var parent = guard.parent

        # If it's not a constant, we'll just try again in the next iteration
        if !_attemptToResolveGuardConstant(test, parent.scope) {
          continue
        }

        if test.isBool {
          parent.guards.removeOne(guard)
          wasGuardRemoved = true

          if test.isTrue {
            _mergeGuardIntoObject(guard, parent)
          } else {
            var elseGuard = guard.elseGuard
            if elseGuard != null {
              if elseGuard.test != null {
                elseGuard.parent = parent
                parent.guards.append(elseGuard)
              } else {
                _mergeGuardIntoObject(elseGuard, parent)
              }
            }
          }
        }
      }

      return wasGuardRemoved
    }

    def _mergeGuardIntoObject(guard Guard, object ObjectSymbol) {
      var symbol = guard.contents
      Merging.mergeObjects(_log, object, symbol.objects)
      Merging.mergeFunctions(_log, object, symbol.functions, .NORMAL)
      Merging.mergeVariables(_log, object, symbol.variables)
      object.objects.append(symbol.objects)
      object.functions.append(symbol.functions)
      object.variables.append(symbol.variables)

      # Handle nested guard clauses like this:
      #
      #   if true {
      #     if true {
      #       var foo = 0
      #     }
      #   }
      #
      if symbol.guards != null {
        for nested in symbol.guards {
          object.guards.append(nested)
          for g = nested; g != null; g = g.elseGuard {
            g.parent = object
            g.contents.parent = object
          }
        }
      }
    }

    # Foreach loops are converted to for loops after everything is resolved
    # because that process needs to generate symbol names and it's much easier
    # to generate non-conflicting symbol names after all local variables have
    # been defined.
    def _convertForeachLoops {
      for node in _foreachLoops {
        var symbol = node.symbol.asVariableSymbol
        var scope = symbol.scope.findEnclosingFunctionOrLambda # Generate names at the function level to avoid conflicts with local scopes
        var value = node.foreachValue
        var block = node.foreachBlock

        # Handle "for i in 0..10"
        if value.kind == .PAIR {
          var first = value.firstValue
          var second = value.secondValue
          symbol.flags &= ~Symbol.IS_CONST
          symbol.value = first.remove
          var setup = Node.createVariables.appendChild(Node.createVariable(symbol))
          var symbolName = Node.createSymbolReference(symbol)
          var update = Node.createUnary(.INCREMENT, symbolName)
          var test Node

          # Special-case constant iteration limits to generate simpler code
          if second.kind == .CONSTANT || second.kind == .NAME && second.symbol != null && second.symbol.isConst {
            test = Node.createBinary(.LESS_THAN, symbolName.clone, second.remove)
          }

          # Otherwise, save the iteration limit in case it changes during iteration
          else {
            var count = VariableSymbol.new(.VARIABLE_LOCAL, scope.generateName("count"))
            count.resolvedType = _cache.intType
            count.value = second.remove
            count.state = .INITIALIZED
            setup.appendChild(Node.createVariable(count))
            test = Node.createBinary(.LESS_THAN, symbolName.clone, Node.createSymbolReference(count))
          }

          # Use a C-style for loop to implement this foreach loop
          node.become(Node.createFor(setup, test, update, block.remove).withComments(node.comments).withRange(node.range))

          # Make sure the new expressions are resolved
          _resolveNode(test, symbol.scope, null)
          _resolveNode(update, symbol.scope, null)
        }

        else if _cache.isList(value.resolvedType) && !_options.target.supportsListForeach {
          # Create the index variable
          var index = VariableSymbol.new(.VARIABLE_LOCAL, scope.generateName("i"))
          index.resolvedType = _cache.intType
          index.value = Node.createInt(0).withType(_cache.intType)
          index.state = .INITIALIZED
          var setup = Node.createVariables.appendChild(Node.createVariable(index))
          var indexName = Node.createSymbolReference(index)

          # Create the list variable
          var list VariableSymbol = null
          if value.kind == .NAME && value.symbol != null && value.symbol.kind.isVariable && value.symbol.isConst {
            list = value.symbol.asVariableSymbol
          } else {
            list = VariableSymbol.new(.VARIABLE_LOCAL, scope.generateName("list"))
            list.resolvedType = value.resolvedType
            list.value = value.remove
            list.state = .INITIALIZED
            setup.appendChild(Node.createVariable(list))
          }
          var listName = Node.createSymbolReference(list)

          # Create the count variable
          var count = VariableSymbol.new(.VARIABLE_LOCAL, scope.generateName("count"))
          count.resolvedType = _cache.intType
          count.value = Node.createDot(listName, "count")
          count.state = .INITIALIZED
          setup.appendChild(Node.createVariable(count))
          var countName = Node.createSymbolReference(count)

          # Move the loop variable into the loop body
          symbol.value = Node.createIndex(listName.clone, indexName)
          block.prependChild(Node.createVariables.appendChild(Node.createVariable(symbol)))

          # Use a C-style for loop to implement this foreach loop
          var test = Node.createBinary(.LESS_THAN, indexName.clone, countName)
          var update = Node.createUnary(.INCREMENT, indexName.clone)
          node.become(Node.createFor(setup, test, update, block.remove).withComments(node.comments).withRange(node.range))

          # Make sure the new expressions are resolved
          _resolveNode(symbol.value, symbol.scope, null)
          _resolveNode(count.value, symbol.scope, null)
          _resolveNode(test, symbol.scope, null)
          _resolveNode(update, symbol.scope, null)
        }
      }
    }

    def _scanLocalVariables {
      for info in _localVariableStatistics.values {
        var symbol = info.symbol

        # Variables that are never re-assigned can safely be considered constants for constant folding
        if info.writeCount == 0 && _options.foldAllConstants {
          symbol.flags |= Symbol.IS_CONST
        }

        # Unused local variables can safely be removed, but don't warn about "for i in 0..10 {}"
        if info.readCount == 0 && !symbol.isLoopVariable && symbol.kind == .VARIABLE_LOCAL {
          _log.semanticWarningUnreadLocalVariable(symbol.range, symbol.name)
        }

        # Rename local variables that conflict
        var scope = symbol.scope
        while scope.kind == .LOCAL {
          scope = scope.parent
        }
        if scope.used != null && scope.used.get(symbol.name, null) != symbol {
          symbol.name = scope.generateName(symbol.name)
        }
      }
    }

    def _discardUnusedDefines {
      for key in _defines.keys {
        _log.semanticErrorInvalidDefine(_defines[key].name, key)
      }
    }

    def _resolveObject(symbol ObjectSymbol) {
      _initializeSymbol(symbol)

      for object in symbol.objects {
        _resolveObject(object)
      }

      for function in symbol.functions {
        _resolveFunction(function)
      }

      for variable in symbol.variables {
        _resolveVariable(variable)
      }

      _checkInterfacesAndAbstractStatus(symbol)
    }

    def _initializeFunction(symbol FunctionSymbol) {
      if symbol.resolvedType == null {
        symbol.resolvedType = Type.new(.SYMBOL, symbol)
      }

      # Referencing a normal variable instead of a special node kind for "this"
      # makes many things much easier including lambda capture and devirtualization
      if symbol.kind == .FUNCTION_INSTANCE || symbol.kind == .FUNCTION_CONSTRUCTOR {
        symbol.this = VariableSymbol.new(.VARIABLE_ARGUMENT, "self")
        symbol.this.flags |= Symbol.IS_CONST
        symbol.this.resolvedType = _cache.parameterize(symbol.parent.resolvedType)
        symbol.this.state = .INITIALIZED
      }

      # Lazily-initialize automatically generated functions
      if symbol.isAutomaticallyGenerated {
        if symbol.kind == .FUNCTION_CONSTRUCTOR {
          assert(symbol.name == "new")
          _automaticallyGenerateClassConstructor(symbol)
        } else if symbol.kind == .FUNCTION_INSTANCE {
          assert(symbol.name == "toString")
          _automaticallyGenerateEnumToString(symbol)
        }
      }

      _resolveParameters(symbol.parameters)

      # Resolve the argument variables
      symbol.resolvedType.argumentTypes = []
      for argument in symbol.arguments {
        argument.scope = symbol.scope
        _resolveVariable(argument)
        symbol.resolvedType.argumentTypes.append(argument.resolvedType)
      }
      symbol.argumentOnlyType = _cache.createLambdaType(symbol.resolvedType.argumentTypes, null)

      # Resolve the return type if present (no return type means "void")
      var returnType Type = null
      if symbol.returnType != null {
        if symbol.kind == .FUNCTION_CONSTRUCTOR {
          _log.semanticErrorConstructorReturnType(symbol.returnType.range)
        } else {
          _resolveAsParameterizedType(symbol.returnType, symbol.scope)
          returnType = symbol.returnType.resolvedType
        }
      }

      # Constructors always return the type they construct
      if symbol.kind == .FUNCTION_CONSTRUCTOR {
        returnType = _cache.parameterize(symbol.parent.resolvedType)
      }

      # The "<=>" operator must return a numeric value for comparison with zero
      var count = symbol.arguments.count
      if symbol.name == "<=>" {
        if returnType == null || returnType != _cache.intType {
          _log.semanticErrorComparisonOperatorNotInt(symbol.returnType != null ? symbol.returnType.range : symbol.range)
          returnType = .DYNAMIC
        } else if count != 1 {
          _log.semanticErrorWrongArgumentCount(symbol.range, symbol.name, 1)
        }
      }

      # Setters must have one argument
      else if symbol.isSetter && count != 1 {
        _log.semanticErrorWrongArgumentCount(symbol.range, symbol.name, 1)
        symbol.flags &= ~Symbol.IS_SETTER
      }

      # Validate argument count
      else {
        var argumentCount = argumentCountForOperator(symbol.name)

        if argumentCount != null && !(count in argumentCount) {
          _log.semanticErrorWrongArgumentCountRange(symbol.range, symbol.name, argumentCount)
        }

        # Enforce that the initializer constructor operators take lists of
        # values to avoid confusing error messages inside the code generated
        # for initializer expressions
        else if symbol.name == "{new}" || symbol.name == "[new]" {
          for argument in symbol.arguments {
            if argument.resolvedType != .DYNAMIC && !_cache.isList(argument.resolvedType) {
              _log.semanticErrorExpectedList(argument.range, argument.name, argument.resolvedType)
            }
          }
        }
      }

      symbol.resolvedType.returnType = returnType
      _resolveAnnotations(symbol)

      # Validate the entry point after this symbol has a type
      if symbol.isEntryPoint {
        _validateEntryPoint(symbol)
      }
    }

    def _automaticallyGenerateClassConstructor(symbol FunctionSymbol) {
      # Create the function body
      var block = Node.createBlock
      symbol.block = block

      # Mirror the base constructor's arguments
      if symbol.overridden != null {
        _initializeSymbol(symbol.overridden)
        var arguments = symbol.overridden.arguments
        var base = Node.createSuper.withRange(symbol.overridden.range)
        if arguments.isEmpty {
          block.appendChild(Node.createExpression(base))
        } else {
          var call = Node.createCall(base)
          for variable in arguments {
            var argument = VariableSymbol.new(.VARIABLE_ARGUMENT, variable.name)
            argument.resolvedType = variable.resolvedType
            argument.state = .INITIALIZED
            symbol.arguments.append(argument)
            call.appendChild(Node.createSymbolReference(argument))
          }
          block.prependChild(Node.createExpression(call))
        }
      }

      # Add an argument for every uninitialized variable
      var parent = symbol.parent.asObjectSymbol
      _initializeSymbol(parent)
      for variable in parent.variables {
        if variable.kind == .VARIABLE_INSTANCE {
          _initializeSymbol(variable)
          if variable.value == null {
            var argument = VariableSymbol.new(.VARIABLE_ARGUMENT, variable.name)
            argument.resolvedType = variable.resolvedType
            argument.state = .INITIALIZED
            argument.range = variable.range
            symbol.arguments.append(argument)
            block.appendChild(Node.createExpression(Node.createBinary(.ASSIGN,
              Node.createMemberReference(Node.createSymbolReference(symbol.this), variable),
              Node.createSymbolReference(argument)).withRange(variable.range)))
          } else {
            block.appendChild(Node.createExpression(Node.createBinary(.ASSIGN,
              Node.createMemberReference(Node.createSymbolReference(symbol.this), variable),
              variable.value.clone).withRange(variable.range)))
          }
        }
      }

      # Make constructors without arguments into getters
      if symbol.arguments.isEmpty {
        symbol.flags |= Symbol.IS_GETTER
      }
    }

    def _automaticallyGenerateEnumToString(symbol FunctionSymbol) {
      var parent = symbol.parent.asObjectSymbol
      var names = Node.createList
      _initializeSymbol(parent)

      for variable in parent.variables {
        if variable.kind == .VARIABLE_ENUM {
          assert(variable.enumValue == names.childCount)
          names.appendChild(Node.createString(variable.name))
        }
      }

      var strings = VariableSymbol.new(.VARIABLE_GLOBAL, parent.scope.generateName("_strings"))
      strings.value = names
      strings.flags |= Symbol.IS_PROTECTED | Symbol.IS_CONST
      strings.state = .INITIALIZED
      strings.parent = parent
      strings.scope = parent.scope
      strings.resolvedType = _cache.createListType(_cache.stringType)
      parent.variables.append(strings)
      _resolveAsParameterizedExpressionWithConversion(strings.value, strings.scope, strings.resolvedType)

      symbol.returnType = Node.createType(_cache.stringType)
      symbol.block = Node.createBlock.appendChild(Node.createReturn(Node.createIndex(Node.createSymbolReference(strings), Node.createName("self"))))
      symbol.flags |= Symbol.IS_GETTER
    }

    def _resolveFunction(symbol FunctionSymbol) {
      _initializeSymbol(symbol)

      # Validate use of "def" vs "over"
      if !symbol.isObsolete {
        if symbol.overridden != null && symbol.kind == .FUNCTION_INSTANCE {
          if !symbol.isOver {
            _log.semanticErrorModifierMissingOverride(symbol.range, symbol.name, symbol.overridden.range)
          }
        } else {
          if symbol.isOver {
            _log.semanticErrorModifierUnusedOverride(symbol.range, symbol.name)
          }
        }
      }

      var scope = LocalScope.new(symbol.scope, .NORMAL)
      if symbol.this != null {
        scope.define(symbol.this, _log)
      }

      # Default values for argument variables aren't resolved with this local
      # scope since they are evaluated at the call site, not inside the
      # function body, and shouldn't have access to other arguments
      for argument in symbol.arguments {
        scope.define(argument, _log)
        _localVariableStatistics[argument.id] = LocalVariableStatistics.new(argument)
      }

      # The function is considered abstract if the body is missing
      var block = symbol.block
      if block != null {
        var firstStatement = block.firstChild
        if firstStatement != null && firstStatement.isSuperCallStatement {
          firstStatement = firstStatement.nextSibling
        }

        # User-specified constructors have variable initializers automatically inserted
        if symbol.kind == .FUNCTION_CONSTRUCTOR && !symbol.isAutomaticallyGenerated {
          for variable in symbol.parent.asObjectSymbol.variables {
            if variable.kind == .VARIABLE_INSTANCE {
              _resolveVariable(variable)

              # Attempt to create a default value if absent. Right now this
              # avoids the problem of initializing type parameters:
              #
              #   class Foo<T> {
              #     var foo T
              #     def new {}
              #     def use T { return foo }
              #   }
              #
              # This should be fixed at some point.
              if variable.value == null && !variable.resolvedType.isParameter {
                variable.value = _createDefaultValueForType(variable.resolvedType, variable.range)
              }

              if variable.value != null {
                block.insertChildBefore(firstStatement, Node.createExpression(Node.createBinary(.ASSIGN,
                  Node.createMemberReference(Node.createSymbolReference(symbol.this), variable),
                  variable.value.clone)))
              }
            }
          }
        }

        _resolveNode(block, scope, null)

        # Missing a return statement is an error
        if symbol.kind != .FUNCTION_CONSTRUCTOR {
          var returnType = symbol.resolvedType.returnType
          if returnType != null && returnType != .DYNAMIC && block.hasControlFlowAtEnd {
            _log.semanticErrorMissingReturn(symbol.range, symbol.name, returnType)
          }
        }

        # Derived class constructors must start with a call to "super"
        else if symbol.parent.asObjectSymbol.baseClass != null {
          var first = block.firstChild
          if first == null || !first.isSuperCallStatement {
            _log.semanticErrorMissingSuper(firstStatement == null ? symbol.range : firstStatement.range)
          }
        }
      }

      # Global functions can't be abstract
      else if !symbol.isImported && !symbol.isObsolete && (symbol.kind == .FUNCTION_GLOBAL || symbol.kind == .FUNCTION_CONSTRUCTOR) {
        _log.semanticErrorUnimplementedFunction(symbol.range, symbol.name)
      }
    }

    def _recordStatistic(symbol Symbol, statistic SymbolStatistic) {
      if symbol != null && (symbol.kind == .VARIABLE_LOCAL || symbol.kind == .VARIABLE_ARGUMENT) {
        var info = _localVariableStatistics.get(symbol.id, null)
        if info != null {
          switch statistic {
            case .READ { info.readCount++ }
            case .WRITE { info.writeCount++ }
          }
        }
      }
    }

    def _initializeVariable(symbol VariableSymbol) {
      var value = symbol.value

      # Normal variables may omit the initializer if the type is present
      if symbol.type != null {
        _resolveAsParameterizedType(symbol.type, symbol.scope)
        symbol.resolvedType = symbol.type.resolvedType
        symbol.state = .INITIALIZED

        # Resolve the constant now so initialized constants always have a value
        if symbol.isConst && value != null {
          _resolveAsParameterizedExpressionWithConversion(value, symbol.scope, symbol.resolvedType)
        }
      }

      # Enums take their type from their parent
      else if symbol.kind == .VARIABLE_ENUM {
        symbol.resolvedType = symbol.parent.resolvedType
      }

      # Implicitly-typed variables take their type from their initializer
      else if value != null {
        _resolveAsParameterizedExpression(value, symbol.scope)
        var type = value.resolvedType
        symbol.resolvedType = type

        # Forbid certain types
        if !_isValidVariableType(type) {
          _log.semanticErrorBadImplicitVariableType(symbol.range, type)
          symbol.resolvedType = .DYNAMIC
        }
      }

      # Use a different error for constants which must have a type and lambda arguments which cannot have an initializer
      else if symbol.isConst || symbol.scope.kind == .FUNCTION && symbol.scope.asFunctionScope.symbol.kind == .FUNCTION_LOCAL {
        _log.semanticErrorVarMissingType(symbol.range, symbol.name)
        symbol.resolvedType = .DYNAMIC
      }

      # Variables without a type are an error
      else {
        _log.semanticErrorVarMissingValue(symbol.range, symbol.name)
        symbol.resolvedType = .DYNAMIC
      }

      _resolveDefines(symbol)
      _resolveAnnotations(symbol)

      # Run post-annotation checks
      if symbol.resolvedType != .DYNAMIC && symbol.isConst && !symbol.isImported && value == null && symbol.kind != .VARIABLE_ENUM && symbol.kind != .VARIABLE_INSTANCE {
        _log.semanticErrorConstMissingValue(symbol.range, symbol.name)
      }
    }

    def _resolveVariable(symbol VariableSymbol) {
      _initializeSymbol(symbol)

      if symbol.value != null {
        _resolveAsParameterizedExpressionWithConversion(symbol.value, symbol.scope, symbol.resolvedType)
      }

      # Default-initialize variables
      else if symbol.kind != .VARIABLE_ARGUMENT && symbol.kind != .VARIABLE_INSTANCE && symbol.kind != .VARIABLE_ENUM {
        symbol.value = _createDefaultValueForType(symbol.resolvedType, symbol.range)
      }
    }

    def _createDefaultValueForType(type Type, range Range) Node {
      var unwrapped = _cache.unwrappedType(type)

      if unwrapped == _cache.intType {
        return Node.createInt(0).withType(type)
      }

      if unwrapped == _cache.doubleType {
        return Node.createDouble(0).withType(type)
      }

      if unwrapped == _cache.boolType {
        return Node.createBool(false).withType(type)
      }

      if unwrapped.isEnum {
        return Node.createCast(Node.createInt(0).withType(_cache.intType), Node.createType(type)).withType(type)
      }

      if unwrapped.isParameter {
        _log.semanticErrorNoDefaultValue(range, type)
        return null
      }

      assert(unwrapped.isReference)
      return Node.createNull.withType(type)
    }

    def _initializeOverloadedFunction(symbol OverloadedFunctionSymbol) {
      var symbols = symbol.symbols

      if symbol.resolvedType == null {
        symbol.resolvedType = Type.new(.SYMBOL, symbol)
      }

      # Ensure no two overloads have the same argument types
      var i = 0
      while i < symbols.count {
        var function = symbols[i]
        _initializeSymbol(function)
        symbol.flags |= function.flags & Symbol.IS_SETTER

        var equivalence TypeCache.Equivalence = .NOT_EQUIVALENT
        var index = -1
        for j in 0..i {
          equivalence = _cache.areFunctionSymbolsEquivalent(function, symbols[j])
          if equivalence != .NOT_EQUIVALENT {
            index = j
            break
          }
        }

        if index == -1 {
          i++
          continue
        }

        var other = symbols[index]
        var parent = symbol.parent.asObjectSymbol
        var isFromSameObject = function.parent == other.parent
        var areReturnTypesDifferent = equivalence == .EQUIVALENT_EXCEPT_RETURN_TYPE && (isFromSameObject || symbol.kind == .OVERLOADED_INSTANCE)

        # Symbols should be in the base type chain
        assert(parent.isSameOrHasBaseClass(function.parent))
        assert(parent.isSameOrHasBaseClass(other.parent))

        # Forbid overloading by return type
        if !isFromSameObject && areReturnTypesDifferent {
          var derived = function.parent == parent ? function : other
          var base = derived == function ? other : function
          _log.semanticErrorBadOverrideReturnType(derived.range, derived.name, parent.baseType, base.range)
          if isFromSameObject {
            function.flags |= Symbol.IS_OBSOLETE
          }
        }

        # Allow duplicate function declarations with the same type to merge
        # as long as there are not two declarations that provide implementations.
        # Mark the obsolete function as obsolete instead of removing it so it
        # doesn't potentially mess up iteration in a parent call stack.
        else if areReturnTypesDifferent || isFromSameObject && function.block != null && other.block != null {
          _log.semanticErrorDuplicateOverload(function.range, symbol.name, other.range)
          if isFromSameObject {
            function.flags |= Symbol.IS_OBSOLETE
          }
        }

        # Keep "function"
        else if isFromSameObject ? function.block != null : function.parent.asObjectSymbol.hasBaseClass(other.parent) {
          if function.parent == parent && other.parent == parent {
            function.mergeInformationFrom(other)
            function.flags |= function.block != null ? other.flags & ~Symbol.IS_IMPORTED : other.flags
            other.flags |= Symbol.IS_OBSOLETE
          } else if !isFromSameObject {
            function.overridden = other
          }
          symbols[index] = function
        }

        # Keep "other"
        else {
          if function.parent == parent && other.parent == parent {
            other.flags |= other.block != null ? function.flags & ~Symbol.IS_IMPORTED : function.flags
            other.mergeInformationFrom(function)
            function.flags |= Symbol.IS_OBSOLETE
          } else if !isFromSameObject {
            other.overridden = function
          }
        }

        # Remove the symbol after the merge
        symbols.removeAt(i)
      }
    }

    # Put the guts of the function inside another function because V8 doesn't
    # optimize functions with try-catch statements
    def _resolveNodeSwitch(node Node, scope Scope, context Type) {
      switch node.kind {
        case .BLOCK { _resolveBlock(node, scope) }
        case .PAIR { _resolvePair(node, scope) }

        # Statements
        case .BREAK, .CONTINUE { _resolveJump(node, scope) }
        case .EXPRESSION { _resolveExpression(node, scope) }
        case .FOR { _resolveFor(node, scope) }
        case .FOREACH { _resolveForeach(node, scope) }
        case .IF { _resolveIf(node, scope) }
        case .RETURN { _resolveReturn(node, scope) }
        case .SWITCH { _resolveSwitch(node, scope) }
        case .THROW { _resolveThrow(node, scope) }
        case .TRY { _resolveTry(node, scope) }
        case .VARIABLE { _resolveVariable(node, scope) }
        case .VARIABLES { _resolveVariables(node, scope) }
        case .WHILE { _resolveWhile(node, scope) }

        # Expressions
        case .ASSIGN_INDEX { _resolveOperatorOverload(node, scope) }
        case .CALL { _resolveCall(node, scope, context) }
        case .CAST { _resolveCast(node, scope, context) }
        case .COMPLEMENT, .DECREMENT, .INCREMENT, .NEGATIVE, .NOT, .POSITIVE { _resolveOperatorOverload(node, scope) }
        case .CONSTANT { _resolveConstant(node, scope) }
        case .DOT { _resolveDot(node, scope, context) }
        case .HOOK { _resolveHook(node, scope, context) }
        case .INDEX { _resolveOperatorOverload(node, scope) }
        case .INITIALIZER_LIST, .INITIALIZER_MAP { _resolveInitializer(node, scope, context) }
        case .LAMBDA { _resolveLambda(node, scope, context) }
        case .LAMBDA_TYPE { _resolveLambdaType(node, scope) }
        case .NAME { _resolveName(node, scope) }
        case .NULL { node.resolvedType = .NULL }
        case .NULL_DOT { _resolveNullDot(node, scope) }
        case .NULL_JOIN { _resolveNullJoin(node, scope, context) }
        case .PARAMETERIZE { _resolveParameterize(node, scope) }
        case .SEQUENCE { _resolveSequence(node, scope, context) }
        case .SUPER { _resolveSuper(node, scope) }
        case .TYPE {}
        case .TYPE_CHECK { _resolveTypeCheck(node, scope) }

        default {
          if node.kind.isBinary { _resolveBinary(node, scope) }
          else { assert(false) }
        }
      }
    }

    def _resolveNode(node Node, scope Scope, context Type) {
      if node.resolvedType != null {
        return # Only resolve once
      }

      node.resolvedType = .DYNAMIC
      try {
        _resolveNodeSwitch(node, scope, context)
      }

      # If guard merging failed, reset the type so we'll try again next time
      catch failure GuardMergingFailure {
        node.resolvedType = null
        throw failure
      }

      assert(node.resolvedType != null)
    }

    def _resolveAsParameterizedType(node Node, scope Scope) {
      assert(node.kind.isExpression)
      _resolveNode(node, scope, null)
      _checkIsType(node)
      _checkIsParameterized(node)
    }

    def _resolveAsParameterizedExpression(node Node, scope Scope) {
      assert(node.kind.isExpression)
      _resolveNode(node, scope, null)
      _checkIsInstance(node)
      _checkIsParameterized(node)
    }

    def _resolveAsParameterizedExpressionWithTypeContext(node Node, scope Scope, type Type) {
      assert(node.kind.isExpression)
      _resolveNode(node, scope, type)
      _checkIsInstance(node)
      _checkIsParameterized(node)
    }

    def _resolveAsParameterizedExpressionWithConversion(node Node, scope Scope, type Type) {
      _resolveAsParameterizedExpressionWithTypeContext(node, scope, type)
      _checkConversion(node, type, .IMPLICIT)
    }

    def _resolveChildrenAsParameterizedExpressions(node Node, scope Scope) {
      for child = node.firstChild; child != null; child = child.nextSibling {
        _resolveAsParameterizedExpression(child, scope)
      }
    }

    def _checkUnusedExpression(node Node) {
      var kind = node.kind
      if kind == .HOOK {
        _checkUnusedExpression(node.hookTrue)
        _checkUnusedExpression(node.hookFalse)
      } else if node.range != null && node.resolvedType != .DYNAMIC && kind != .CALL && !kind.isBinaryAssign {
        _log.semanticWarningUnusedExpression(node.range)
      }
    }

    def _checkIsInstance(node Node) {
      if node.resolvedType != .DYNAMIC && node.isType {
        _log.semanticErrorUnexpectedType(node.range, node.resolvedType)
        node.resolvedType = .DYNAMIC
      }
    }

    def _checkIsType(node Node) {
      if node.resolvedType != .DYNAMIC && !node.isType {
        _log.semanticErrorUnexpectedExpression(node.range, node.resolvedType)
        node.resolvedType = .DYNAMIC
      }
    }

    def _checkIsParameterized(node Node) {
      if node.resolvedType.parameters != null && !node.resolvedType.isParameterized {
        _log.semanticErrorUnparameterizedType(node.range, node.resolvedType)
        node.resolvedType = .DYNAMIC
      }
    }

    def _checkStorage(node Node, scope Scope) {
      var symbol = node.symbol

      # Only allow storage to variables
      if node.kind != .NAME && node.kind != .DOT && (node.kind != .INDEX || node.resolvedType != .DYNAMIC) || symbol != null && !symbol.kind.isVariable {
        _log.semanticErrorBadStorage(node.range)
      }

      # Forbid storage to constants
      else if symbol != null && symbol.isConst {
        var function = scope.findEnclosingFunction

        # Allow assignments to constants inside constructors
        if function == null || function.symbol.kind != .FUNCTION_CONSTRUCTOR || function.symbol.parent != symbol.parent || symbol.kind != .VARIABLE_INSTANCE {
          _log.semanticErrorStorageToConstSymbol(node.internalRangeOrRange, symbol.name)
        }
      }
    }

    def _checkAccess(node Node, range Range, scope Scope) {
      var symbol = node.symbol
      if symbol == null {
        return
      }

      # Check access control
      if symbol.isProtected {
        while scope != null {
          if scope.kind == .OBJECT {
            var object = scope.asObjectScope.symbol
            if object.isSameOrHasBaseClass(symbol.parent) {
              return
            }
          }
          scope = scope.parent
        }
        _log.semanticErrorAccessViolation(range, symbol.name)
      }

      # Deprecation annotations optionally provide a warning message
      if symbol.isDeprecated {
        for annotation in symbol.annotations {
          if annotation.symbol != null && annotation.symbol.fullName == "@deprecated" {
            var value = annotation.annotationValue
            if value.kind == .CALL && value.hasTwoChildren {
              var last = value.lastChild
              if last.kind == .CONSTANT && last.content.kind == .STRING {
                _log.warning(range, last.content.asString)
                return
              }
            }
          }
        }
        _log.semanticWarningDeprecatedUsage(range, symbol.name)
      }
    }

    def _checkConversion(node Node, to Type, kind ConversionKind) {
      var from = node.resolvedType
      assert(from != null)
      assert(to != null)

      # The "dynamic" type is a hole in the type system
      if from == .DYNAMIC || to == .DYNAMIC {
        return
      }

      # No conversion is needed for identical types
      if from == to {
        return
      }

      # The implicit conversion must be valid
      if kind == .IMPLICIT && !_cache.canImplicitlyConvert(from, to) ||
          kind == .EXPLICIT && !_cache.canExplicitlyConvert(from, to) {
        _log.semanticErrorIncompatibleTypes(node.range, from, to, _cache.canExplicitlyConvert(from, to))
        node.resolvedType = .DYNAMIC
        return
      }

      # Make the implicit conversion explicit for convenience later on
      if kind == .IMPLICIT {
        node.become(Node.createCast(node.cloneAndStealChildren, Node.createType(to)).withType(to).withRange(node.range))
      }
    }

    def _resolveAnnotation(node Node, symbol Symbol) bool {
      var value = node.annotationValue
      var test = node.annotationTest

      _resolveNode(value, symbol.scope, null)
      if test != null {
        _resolveAsParameterizedExpressionWithConversion(test, symbol.scope, _cache.boolType)
      }

      # Terminate early when there were errors
      if value.symbol == null {
        return false
      }

      # Make sure annotations have the arguments they need
      if value.kind != .CALL {
        _log.semanticErrorArgumentCount(value.range, value.symbol.resolvedType.argumentTypes.count, 0, value.symbol.name, value.symbol.range)
        return false
      }

      # Ensure all arguments are constants
      var isValid = true
      for child = value.callValue.nextSibling; child != null; child = child.nextSibling {
        isValid = isValid && _recursivelyResolveAsConstant(child)
      }
      if !isValid {
        return false
      }

      # Only store symbols for annotations with the correct arguments for ease of use
      node.symbol = value.symbol

      # Apply built-in annotation logic
      var flag = _annotationSymbolFlags.get(value.symbol.fullName, 0)
      if flag != 0 {
        switch flag {
          case Symbol.IS_DEPRECATED {}
          case Symbol.IS_ENTRY_POINT { isValid = symbol.kind == .FUNCTION_GLOBAL }
          case Symbol.IS_EXPORTED { isValid = !symbol.isImported }
          case Symbol.IS_IMPORTED { isValid = !symbol.isExported && (!symbol.kind.isFunction || symbol.asFunctionSymbol.block == null) }
          case Symbol.IS_INLINING_FORCED, Symbol.IS_INLINING_PREVENTED, Symbol.IS_PREFERRED { isValid = symbol.kind.isFunction }
          case Symbol.IS_RENAMED {}
          case Symbol.IS_SKIPPED { isValid = symbol.kind.isFunction && symbol.resolvedType.returnType == null }
          case Symbol.SHOULD_SPREAD { isValid = symbol.kind == .FUNCTION_ANNOTATION }
        }
        if flag == Symbol.IS_INLINING_FORCED {
          _options.isAlwaysInlinePresent = true
        }
        if !isValid {
          _log.semanticErrorInvalidAnnotation(value.range, value.symbol.name, symbol.name)
          return false
        }

        # Don't add an annotation when the test expression is false
        if test != null && _recursivelyResolveAsConstant(test) && test.isFalse {
          return false
        }

        # Only warn about duplicate annotations after checking the test expression
        if (symbol.flags & flag) != 0 {
          if (symbol.parent.flags & flag & (Symbol.IS_IMPORTED | Symbol.IS_EXPORTED)) != 0 {
            _log.semanticWarningRedundantAnnotation(value.range, value.symbol.name, symbol.name, symbol.parent.name)
          } else {
            _log.semanticWarningDuplicateAnnotation(value.range, value.symbol.name, symbol.name)
          }
        }

        symbol.flags |= flag

        # Store the new name for later
        if flag == Symbol.IS_RENAMED && value.hasTwoChildren {
          symbol.rename = value.lastChild.asString
        }
      }

      return true
    }

    def _recursivelyResolveAsConstant(node Node) bool {
      _constantFolder.foldConstants(node)

      if node.kind != .CONSTANT {
        _log.semanticErrorExpectedConstant(node.range)
        return false
      }

      return true
    }

    def _resolveBlock(node Node, scope Scope) {
      assert(node.kind == .BLOCK)
      _controlFlow.pushBlock(node)

      for child = node.firstChild, next Node = null; child != null; child = next {
        next = child.nextSibling

        # There is a well-known ambiguity in languages like JavaScript where
        # a return statement followed by a newline and a value can either be
        # parsed as a single return statement with a value or as two
        # statements, a return statement without a value and an expression
        # statement. Luckily, we're better off than JavaScript since we know
        # the type of the function. Parse a single statement in a non-void
        # function but two statements in a void function.
        if child.kind == .RETURN && next != null && child.returnValue == null && next.kind == .EXPRESSION {
          var function = scope.findEnclosingFunctionOrLambda.symbol
          if function.kind != .FUNCTION_CONSTRUCTOR && function.resolvedType.returnType != null {
            child.appendChild(next.remove.expressionValue.remove)
            next = child.nextSibling
            assert(child.returnValue != null)
          }
        }

        _resolveNode(child, scope, null)
        _controlFlow.visitStatementInPostOrder(child)

        # The "@skip" annotation removes function calls after type checking
        if child.kind == .EXPRESSION {
          var value = child.expressionValue
          if value.kind == .CALL && value.symbol != null && value.symbol.isSkipped {
            child.remove
          }
        }
      }

      _controlFlow.popBlock(node)
    }

    def _resolvePair(node Node, scope Scope) {
      _resolveAsParameterizedExpression(node.firstValue, scope)
      _resolveAsParameterizedExpression(node.secondValue, scope)
    }

    def _resolveJump(node Node, scope Scope) {
      if scope.findEnclosingLoop == null {
        _log.semanticErrorBadJump(node.range, node.kind == .BREAK ? "break" : "continue")
      }
    }

    def _resolveExpression(node Node, scope Scope) {
      var value = node.expressionValue
      _resolveAsParameterizedExpression(value, scope)
      _checkUnusedExpression(value)
    }

    def _resolveFor(node Node, scope Scope) {
      var setup = node.forSetup
      var update = node.forUpdate
      scope = LocalScope.new(scope, .LOOP)
      if setup.kind == .VARIABLES {
        _resolveNode(setup, scope, null)

        # All for loop variables must have the same type. This is a requirement
        # for one-to-one code emission in the languages we want to target.
        var type = setup.firstChild.symbol.resolvedType
        for child = setup.firstChild.nextSibling; child != null; child = child.nextSibling {
          var symbol = child.symbol
          if symbol.resolvedType != type {
            _log.semanticErrorForLoopDifferentType(symbol.range, symbol.name, symbol.resolvedType, type)
            break
          }
        }
      } else {
        _resolveAsParameterizedExpression(setup, scope)
      }
      _resolveAsParameterizedExpressionWithConversion(node.forTest, scope, _cache.boolType)
      _resolveAsParameterizedExpression(update, scope)
      if update.kind == .SEQUENCE {
        for child = update.firstChild; child != null; child = child.nextSibling {
          _checkUnusedExpression(child)
        }
      }
      _resolveBlock(node.forBlock, scope)
    }

    def _resolveForeach(node Node, scope Scope) {
      var type Type = .DYNAMIC
      scope = LocalScope.new(scope, .LOOP)

      var value = node.foreachValue
      _resolveAsParameterizedExpression(value, scope)

      # Support "for i in 0..10"
      if value.kind == .PAIR {
        var first = value.firstValue
        var second = value.secondValue
        type = _cache.intType
        _checkConversion(first, _cache.intType, .IMPLICIT)
        _checkConversion(second, _cache.intType, .IMPLICIT)

        # The ".." syntax only counts up, unlike CoffeeScript
        if first.isInt && second.isInt && first.asInt >= second.asInt {
          _log.semanticWarningEmptyRange(value.range)
        }
      }

      # Support "for i in [1, 2, 3]"
      else if _cache.isList(value.resolvedType) {
        type = value.resolvedType.substitutions[0]
      }

      # Anything else is an error
      else if value.resolvedType != .DYNAMIC {
        _log.semanticErrorBadForValue(value.range, value.resolvedType)
      }

      # Special-case symbol initialization with the type
      var symbol = node.symbol.asVariableSymbol
      scope.asLocalScope.define(symbol, _log)
      _localVariableStatistics[symbol.id] = LocalVariableStatistics.new(symbol)
      symbol.resolvedType = type
      symbol.flags |= Symbol.IS_CONST | Symbol.IS_LOOP_VARIABLE
      symbol.state = .INITIALIZED

      _resolveBlock(node.foreachBlock, scope)

      # Collect foreach loops and convert them in another pass
      _foreachLoops.append(node)
    }

    def _resolveIf(node Node, scope Scope) {
      var test = node.ifTest
      var ifFalse = node.ifFalse
      _resolveAsParameterizedExpressionWithConversion(test, scope, _cache.boolType)
      _resolveBlock(node.ifTrue, LocalScope.new(scope, .NORMAL))
      if ifFalse != null {
        _resolveBlock(ifFalse, LocalScope.new(scope, .NORMAL))
      }
    }

    def _resolveReturn(node Node, scope Scope) {
      var value = node.returnValue
      var function = scope.findEnclosingFunctionOrLambda.symbol
      var returnType = function.kind != .FUNCTION_CONSTRUCTOR ? function.resolvedType.returnType : null

      # Check for a returned value
      if value == null {
        if returnType != null && returnType != .DYNAMIC {
          _log.semanticErrorExpectedReturnValue(node.range, returnType)
        }
        return
      }

      # Check the type of the returned value
      if returnType != null {
        _resolveAsParameterizedExpressionWithConversion(value, scope, returnType)
        return
      }

      # If there's no return type, still check for other errors
      _resolveAsParameterizedExpression(value, scope)

      # Lambdas without a return type or an explicit "return" statement get special treatment
      if !node.isImplicitReturn {
        _log.semanticErrorUnexpectedReturnValue(value.range)
        return
      }

      # Check for a return value of type "void"
      if !function.shouldInferReturnType || value.kind == .CALL && value.symbol != null && value.symbol.resolvedType.returnType == null {
        _checkUnusedExpression(value)
        node.kind = .EXPRESSION
        return
      }

      # Check for an invalid return type
      var type = value.resolvedType
      if !_isValidVariableType(type) {
        _log.semanticErrorBadReturnType(value.range, type)
        node.kind = .EXPRESSION
        return
      }

      # Mutate the return type to the type from the returned value
      function.returnType = Node.createType(type)
    }

    def _resolveSwitch(node Node, scope Scope) {
      var duplicateCases IntMap<Range> = {}
      var mustEnsureConstantIntegers = _options.target.requiresIntegerSwitchStatements
      var allValuesAreIntegers = true
      var value = node.switchValue
      _resolveAsParameterizedExpression(value, scope)

      for child = value.nextSibling; child != null; child = child.nextSibling {
        var block = child.caseBlock

        # Resolve all case values
        for caseValue = child.firstChild; caseValue != block; caseValue = caseValue.nextSibling {
          _resolveAsParameterizedExpressionWithConversion(caseValue, scope, value.resolvedType)

          var symbol = caseValue.symbol
          var integer = 0

          # Check for a constant variable, which may just be read-only with a
          # value determined at runtime
          if symbol != null && (mustEnsureConstantIntegers ? symbol.kind == .VARIABLE_ENUM : symbol.kind.isVariable && symbol.isConst) {
            var constant = _constantFolder.constantForSymbol(symbol.asVariableSymbol)
            if constant == null || constant.kind != .INT {
              allValuesAreIntegers = false
              continue
            }
            integer = constant.asInt
          }

          # Fall back to the constant folder only as a last resort because it
          # mutates the syntax tree and harms readability
          else {
            _constantFolder.foldConstants(caseValue)
            if !caseValue.isInt {
              allValuesAreIntegers = false
              continue
            }
            integer = caseValue.asInt
          }

          # Duplicate case detection
          var previous = duplicateCases.get(integer, null)
          if previous != null {
            _log.semanticErrorDuplicateCase(caseValue.range, previous)
          } else {
            duplicateCases[integer] = caseValue.range
          }
        }

        # The default case must be last, makes changing into an if chain easier later
        if child.hasOneChild && child.nextSibling != null {
          _log.semanticErrorDefaultCaseNotLast(child.range)
        }

        _resolveBlock(block, LocalScope.new(scope, .NORMAL))
      }

      # Fall back to an if statement if the case values aren't compile-time
      # integer constants, which is requried by many language targets
      if !allValuesAreIntegers && mustEnsureConstantIntegers {
        _convertSwitchToIfChain(node, scope)
      }
    }

    def _resolveThrow(node Node, scope Scope) {
      var value = node.throwValue
      _resolveAsParameterizedExpression(value, scope)
    }

    def _resolveVariable(node Node, scope Scope) {
      var symbol = node.symbol.asVariableSymbol
      scope.asLocalScope.define(symbol, _log)
      _localVariableStatistics[symbol.id] = LocalVariableStatistics.new(symbol)
      _resolveVariable(symbol)

      # Make sure to parent any created values under the variable node
      if !node.hasChildren && symbol.value != null {
        node.appendChild(symbol.value)
      }
    }

    def _resolveVariables(node Node, scope Scope) {
      for child = node.firstChild; child != null; child = child.nextSibling {
        _resolveVariable(child, scope)
      }
    }

    def _resolveTry(node Node, scope Scope) {
      var tryBlock = node.tryBlock
      var finallyBlock = node.finallyBlock
      _resolveBlock(tryBlock, LocalScope.new(scope, .NORMAL))

      # Bare try statements catch all thrown values
      if node.hasOneChild {
        node.appendChild(Node.createCatch(null, Node.createBlock))
      }

      # Check catch statements
      for child = tryBlock.nextSibling; child != finallyBlock; child = child.nextSibling {
        var childScope = LocalScope.new(scope, .NORMAL)
        if child.symbol != null {
          var symbol = child.symbol.asVariableSymbol
          childScope.define(symbol, _log)
          _resolveVariable(symbol)
        }
        _resolveBlock(child.catchBlock, childScope)
      }

      # Check finally block
      if finallyBlock != null {
        _resolveBlock(finallyBlock, LocalScope.new(scope, .NORMAL))
      }
    }

    def _resolveWhile(node Node, scope Scope) {
      _resolveAsParameterizedExpressionWithConversion(node.whileTest, scope, _cache.boolType)
      _resolveBlock(node.whileBlock, LocalScope.new(scope, .LOOP))
    }

    def _resolveCall(node Node, scope Scope, context Type) {
      if _sinkNullDot(node, scope, context) {
        return
      }

      var value = node.callValue

      # Take argument types from call argument values for immediately-invoked
      # function expressions:
      #
      #   var foo = ((a, b) => a + b)(1, 2)
      #   var bar int = ((a, b) => { return a + b })(1, 2)
      #
      if value.kind == .LAMBDA {
        var symbol = value.symbol.asFunctionSymbol
        var arguments = symbol.arguments
        if node.childCount == arguments.count + 1 {
          var child = value.nextSibling
          for i in 0..arguments.count {
            var argument = arguments[i]
            if argument.type == null {
              _resolveAsParameterizedExpression(child, scope)
              argument.type = Node.createType(child.resolvedType)
            }
            child = child.nextSibling
          }
          if context != null && symbol.returnType == null {
            symbol.returnType = Node.createType(context)
          }
        }
      }

      _resolveAsParameterizedExpression(value, scope)
      var type = value.resolvedType

      switch type.kind {
        # Each function has its own type for simplicity
        case .SYMBOL {
          if _resolveSymbolCall(node, scope, type) {
            return
          }
        }

        # Lambda types look like "fn(int, int) int"
        case .LAMBDA {
          if _resolveFunctionCall(node, scope, type) {
            return
          }
        }

        # Can't call other types (the null type, for example)
        default {
          if type != .DYNAMIC {
            _log.semanticErrorInvalidCall(node.internalRangeOrRange, value.resolvedType)
          }
        }
      }

      # If there was an error, resolve the arguments to check for further
      # errors but use a dynamic type context to avoid introducing errors
      for child = value.nextSibling; child != null; child = child.nextSibling {
        _resolveAsParameterizedExpressionWithConversion(child, scope, .DYNAMIC)
      }
    }

    def _resolveSymbolCall(node Node, scope Scope, type Type) bool {
      var symbol = type.symbol

      # Getters are called implicitly, so explicitly calling one is an error.
      # This error prevents a getter returning a lambda which is then called.
      # To overcome this, wrap the call in parentheses:
      #
      #   def foo fn()
      #
      #   def bar {
      #     foo()   # Error
      #     (foo)() # Correct
      #   }
      #
      if symbol.isGetter && _isCallValue(node) && !node.callValue.isInsideParentheses {
        if symbol.resolvedType.returnType != null && symbol.resolvedType.returnType.kind == .LAMBDA {
          _log.semanticErrorGetterRequiresWrap(node.range, symbol.name, symbol.range)
        } else {
          _log.semanticErrorGetterCalledTwice(node.parent.internalRangeOrRange, symbol.name, symbol.range)
        }
        return false
      }

      # Check for calling a function directly
      if symbol.kind.isFunction {
        return _resolveFunctionCall(node, scope, type)
      }

      # Check for calling a set of functions, must not be ambiguous
      if symbol.kind.isOverloadedFunction {
        return _resolveOverloadedFunctionCall(node, scope, type)
      }

      # Can't call other symbols
      _log.semanticErrorInvalidCall(node.internalRangeOrRange, node.callValue.resolvedType)
      return false
    }

    def _resolveFunctionCall(node Node, scope Scope, type Type) bool {
      var function = type.symbol?.asFunctionSymbol
      var expected = type.argumentTypes.count
      var count = node.childCount - 1
      node.symbol = function

      # Use the return type even if there were errors
      if type.returnType != null {
        node.resolvedType = type.returnType
      }

      # There is no "void" type, so make sure this return value isn't used
      else if _isVoidExpressionUsed(node) {
        if function != null {
          _log.semanticErrorUseOfVoidFunction(node.range, function.name, function.range)
        } else {
          _log.semanticErrorUseOfVoidLambda(node.range)
        }
      }

      # Check argument count
      if expected != count {
        _log.semanticErrorArgumentCount(node.internalRangeOrRange, expected, count, function?.name, function?.range)
        return false
      }

      # Check argument types
      var value = node.firstChild
      var child = value.nextSibling
      for argumentType in type.argumentTypes {
        _resolveAsParameterizedExpressionWithConversion(child, scope, argumentType)
        child = child.nextSibling
      }

      # Forbid constructing an abstract type
      if function != null && function.kind == .FUNCTION_CONSTRUCTOR && value.kind != .SUPER {
        _checkInterfacesAndAbstractStatus(function.parent.asObjectSymbol)
        var reason = function.parent.asObjectSymbol.isAbstractBecauseOf
        if reason != null {
          _log.semanticErrorAbstractNew(node.internalRangeOrRange, function.parent.resolvedType, reason.range, reason.name)
        }
      }

      # Replace overloaded symbols with the chosen overload
      if value.kind == .PARAMETERIZE {
        value = value.parameterizeValue
      }
      if function != null && value.symbol != null && value.symbol.kind.isOverloadedFunction && function in value.symbol.asOverloadedFunctionSymbol.symbols {
        value.symbol = function
      }

      return true
    }

    def _resolveOverloadedFunction(range Range, node Node, scope Scope, symbolType Type) Type {
      var overloaded = symbolType.symbol.asOverloadedFunctionSymbol
      var firstArgument = node.firstChild.nextSibling
      var count = node.childCount - 1
      var candidates List<Type> = []

      # Filter by argument length and substitute using the current type environment
      for symbol in overloaded.symbols {
        if symbol.arguments.count == count || overloaded.symbols.count == 1 {
          candidates.append(_cache.substitute(symbol.resolvedType, symbolType.environment))
        }
      }

      # Check for matches
      if candidates.isEmpty {
        _log.semanticErrorNoMatchingOverload(range, overloaded.name, count, null)
        return null
      }

      # Check for an unambiguous match
      if candidates.count == 1 {
        return candidates[0]
      }

      # First filter by syntactic structure impossibilities. This helps break
      # the chicken-and-egg problem of needing to resolve argument types to
      # get a match and needing a match to resolve argument types. For example,
      # a list literal needs type context to resolve correctly.
      var index = 0
      while index < candidates.count {
        var child = firstArgument
        for type in candidates[index].argumentTypes {
          var kind = child.kind
          if kind == .NULL && !type.isReference ||
              kind == .INITIALIZER_LIST && _findMember(type, "[new]") == null && _findMember(type, "[...]") == null ||
              kind == .INITIALIZER_MAP && _findMember(type, "{new}") == null && _findMember(type, "{...}") == null ||
              kind == .LAMBDA && (type.kind != .LAMBDA || type.argumentTypes.count != child.symbol.asFunctionSymbol.arguments.count) {
            candidates.removeAt(index)
            index--
            break
          }
          child = child.nextSibling
        }
        index++
      }

      # Check for an unambiguous match
      if candidates.count == 1 {
        return candidates[0]
      }

      # If that still didn't work, resolve the arguments without type context
      for child = firstArgument; child != null; child = child.nextSibling {
        _resolveAsParameterizedExpression(child, scope)
      }

      # Try again, this time discarding all implicit conversion failures
      index = 0
      while index < candidates.count {
        var child = firstArgument
        for type in candidates[index].argumentTypes {
          if !_cache.canImplicitlyConvert(child.resolvedType, type) {
            candidates.removeAt(index)
            index--
            break
          }
          child = child.nextSibling
        }
        index++
      }

      # Check for an unambiguous match
      if candidates.count == 1 {
        return candidates[0]
      }

      # Extract argument types for an error if there is one
      var childTypes List<Type> = []
      for child = firstArgument; child != null; child = child.nextSibling {
        childTypes.append(child.resolvedType)
      }

      # Give up without a match
      if candidates.isEmpty {
        _log.semanticErrorNoMatchingOverload(range, overloaded.name, count, childTypes)
        return null
      }

      # If that still didn't work, try type equality
      for type in candidates {
        var isMatch = true
        for i in 0..count {
          if childTypes[i] != type.argumentTypes[i] {
            isMatch = false
            break
          }
        }
        if isMatch {
          return type
        }
      }

      # If that still didn't work, try picking the preferred overload
      var firstPreferred Type = null
      var secondPreferred Type = null
      for type in candidates {
        if type.symbol.isPreferred {
          secondPreferred = firstPreferred
          firstPreferred = type
        }
      }

      # Check for a single preferred overload
      if firstPreferred != null && secondPreferred == null {
        return firstPreferred
      }

      # Give up since the overload is ambiguous
      _log.semanticErrorAmbiguousOverload(range, overloaded.name, count, childTypes)
      return null
    }

    def _resolveOverloadedFunctionCall(node Node, scope Scope, type Type) bool {
      var match = _resolveOverloadedFunction(node.callValue.range, node, scope, type)
      if match != null && _resolveFunctionCall(node, scope, match) {
        _checkAccess(node, node.callValue.internalRangeOrRange, scope)
        return true
      }
      return false
    }

    def _resolveCast(node Node, scope Scope, context Type) {
      var value = node.castValue
      var type = node.castType
      var neededTypeContext = _needsTypeContext(value)

      _resolveAsParameterizedType(type, scope)
      _resolveAsParameterizedExpressionWithTypeContext(value, scope, type.resolvedType)
      _checkConversion(value, type.resolvedType, .EXPLICIT)
      node.resolvedType = type.resolvedType

      # Warn about unnecessary casts
      if type.resolvedType != .DYNAMIC && value.resolvedType != .DYNAMIC && !neededTypeContext && (value.resolvedType == type.resolvedType ||
          context == type.resolvedType && _cache.canImplicitlyConvert(value.resolvedType, type.resolvedType)) {
        _log.semanticWarningExtraCast(Range.span(node.internalRangeOrRange, type.range), value.resolvedType, type.resolvedType)
      }
    }

    def _resolveConstant(node Node, scope Scope) {
      switch node.content.kind {
        case .BOOL { node.resolvedType = _cache.boolType }
        case .DOUBLE { node.resolvedType = _cache.doubleType }
        case .INT { node.resolvedType = _cache.intType }
        case .STRING { node.resolvedType = _cache.stringType }
        default { assert(false) }
      }
    }

    def _findMember(type Type, name string) Symbol {
      if type.kind == .SYMBOL {
        var symbol = type.symbol
        if symbol.kind.isObject {
          var member = symbol.asObjectSymbol.members.get(name, null)
          if member != null {
            _initializeSymbol(member)
            return member
          }
        }
      }
      return null
    }

    def _sinkNullDot(node Node, scope Scope, context Type) bool {
      var target = node

      # Build up a chain of dot accesses and calls
      while true {
        if target.kind == .DOT && target.dotTarget != null {
          target = target.dotTarget
        } else if target.kind == .CALL {
          target = target.callValue
        } else {
          break
        }
      }

      # Stop if this isn't a "?." expression after all
      if target.kind != .NULL_DOT {
        return false
      }

      # Wrap everything in a null check
      var hook = _hookForNullDot(target, scope)
      target.become(hook.hookTrue.clone)
      node.resolvedType = null # This is necessary to trigger the resolve below
      hook.hookTrue.become(node.cloneAndStealChildren)
      node.become(hook)
      _resolveAsParameterizedExpressionWithTypeContext(node, scope, context)
      return true
    }

    def _resolveDot(node Node, scope Scope, context Type) {
      if _sinkNullDot(node, scope, context) {
        return
      }

      var target = node.dotTarget
      var name = node.asString

      # Infer the target from the type context if it's omitted
      if target == null {
        if context == null {
          _log.semanticErrorMissingDotContext(node.range, name)
          return
        }
        target = Node.createType(context)
        node.appendChild(target)
        assert(node.dotTarget == target)
      } else {
        _resolveNode(target, scope, null)
      }

      # Search for a setter first, then search for a normal member
      var symbol Symbol = null
      if _shouldCheckForSetter(node) {
        symbol = _findMember(target.resolvedType, name + "=")
      }
      if symbol == null {
        symbol = _findMember(target.resolvedType, name)
        if symbol == null {
          if target.resolvedType != .DYNAMIC {
            _reportGuardMergingFailure(node)
            _log.semanticErrorUnknownMemberSymbol(node.internalRangeOrRange, name, target.resolvedType)
          }
          if target.kind == .TYPE && target.resolvedType == .DYNAMIC {
            node.kind = .NAME
            node.removeChildren
          }
          return
        }
      }

      # Forbid referencing a base class global or constructor function from a derived class
      if _isBaseGlobalReference(target.resolvedType.symbol, symbol) {
        _log.semanticErrorUnknownMemberSymbol(node.internalRangeOrRange, name, target.resolvedType)
        return
      }

      var isType = target.isType
      var needsType = !symbol.kind.isOnInstances

      # Make sure the global/instance context matches the intended usage
      if isType {
        if !needsType {
          _log.semanticErrorMemberUnexpectedInstance(node.internalRangeOrRange, symbol.name)
        } else if symbol.kind.isFunctionOrOverloadedFunction {
          _checkIsParameterized(target)
        } else if target.resolvedType.isParameterized {
          _log.semanticErrorParameterizedType(target.range, target.resolvedType)
        }
      } else if needsType {
        _log.semanticErrorMemberUnexpectedGlobal(node.internalRangeOrRange, symbol.name)
      }

      # Always access referenced globals directly
      if !_options.stopAfterResolve && symbol.kind.isGlobalReference {
        node.kind = .NAME
        node.removeChildren
      }

      node.symbol = symbol
      node.resolvedType = _cache.substitute(symbol.resolvedType, target.resolvedType.environment)
      _automaticallyCallGetter(node, scope)
    }

    def _resolveHook(node Node, scope Scope, context Type) {
      _resolveAsParameterizedExpressionWithConversion(node.hookTest, scope, _cache.boolType)

      var trueValue = node.hookTrue
      var falseValue = node.hookFalse

      # Use the type context from the parent
      if context != null {
        _resolveAsParameterizedExpressionWithConversion(trueValue, scope, context)
        _resolveAsParameterizedExpressionWithConversion(falseValue, scope, context)
        node.resolvedType = context
      }

      # Find the common type from both branches
      else {
        _resolveAsParameterizedExpression(trueValue, scope)
        _resolveAsParameterizedExpression(falseValue, scope)
        var commonType = _cache.commonImplicitType(trueValue.resolvedType, falseValue.resolvedType)

        # Insert casts if needed since some targets can't perform this type inference
        if commonType != null {
          _checkConversion(trueValue, commonType, .IMPLICIT)
          _checkConversion(falseValue, commonType, .IMPLICIT)
          node.resolvedType = commonType
        } else {
          _log.semanticErrorNoCommonType(Range.span(trueValue.range, falseValue.range), trueValue.resolvedType, falseValue.resolvedType)
        }
      }

      # Check for likely bugs where both branches look the same
      if trueValue.looksTheSameAs(falseValue) {
        _log.semanticWarningIdenticalOperands(Range.span(trueValue.range, falseValue.range), node.wasNullJoin ? "??" : ":")
      }
    }

    def _resolveInitializer(node Node, scope Scope, context Type) {
      # Make sure to resolve the children even if the initializer is invalid
      if context != null {
        if context == .DYNAMIC || !_resolveInitializerWithContext(node, scope, context) {
          for child = node.firstChild; child != null; child = child.nextSibling {
            if child.kind == .PAIR {
              _resolveAsParameterizedExpressionWithConversion(child.firstValue, scope, .DYNAMIC)
              _resolveAsParameterizedExpressionWithConversion(child.secondValue, scope, .DYNAMIC)
            } else {
              _resolveAsParameterizedExpressionWithConversion(child, scope, .DYNAMIC)
            }
          }
        }
        return
      }

      # First pass: only children with type context, second pass: all children
      for pass in 0..2 {
        switch node.kind {
          case .INITIALIZER_LIST {
            var type Type = null

            # Resolve all children for this pass
            for child = node.firstChild; child != null; child = child.nextSibling {
              if pass != 0 || !_needsTypeContext(child) {
                _resolveAsParameterizedExpression(child, scope)
                type = _mergeCommonType(type, child)
              }
            }

            # Resolve remaining children using the type context if valid
            if type != null && _isValidVariableType(type) {
              _resolveInitializerWithContext(node, scope, _cache.createListType(type))
              return
            }
          }

          case .INITIALIZER_MAP {
            var keyType Type = null
            var valueType Type = null

            # Resolve all children for this pass
            for child = node.firstChild; child != null; child = child.nextSibling {
              var key = child.firstValue
              var value = child.secondValue
              if pass != 0 || !_needsTypeContext(key) {
                _resolveAsParameterizedExpression(key, scope)
                keyType = _mergeCommonType(keyType, key)
              }
              if pass != 0 || !_needsTypeContext(value) {
                _resolveAsParameterizedExpression(value, scope)
                valueType = _mergeCommonType(valueType, value)
              }
            }

            # Resolve remaining children using the type context if valid
            if keyType != null && valueType != null && _isValidVariableType(keyType) && _isValidVariableType(valueType) {
              if keyType == _cache.intType {
                _resolveInitializerWithContext(node, scope, _cache.createIntMapType(valueType))
                return
              }
              if keyType == _cache.stringType {
                _resolveInitializerWithContext(node, scope, _cache.createStringMapType(valueType))
                return
              }
            }
          }
        }
      }

      _log.semanticErrorInitializerTypeInferenceFailed(node.range)
    }

    def _resolveInitializerWithContext(node Node, scope Scope, context Type) bool {
      var isList = node.kind == .INITIALIZER_LIST
      var create = _findMember(context, isList ? "[new]" : "{new}")
      var add = _findMember(context, isList ? "[...]" : "{...}")

      # Special-case imported literals to prevent an infinite loop for list literals
      if add != null && add.isImported {
        var function = add.asFunctionSymbol
        if function.arguments.count == (isList ? 1 : 2) {
          var functionType = _cache.substitute(function.resolvedType, context.environment)
          for child = node.firstChild; child != null; child = child.nextSibling {
            if child.kind == .PAIR {
              _resolveAsParameterizedExpressionWithConversion(child.firstValue, scope, functionType.argumentTypes[0])
              _resolveAsParameterizedExpressionWithConversion(child.secondValue, scope, functionType.argumentTypes[1])
            } else {
              _resolveAsParameterizedExpressionWithConversion(child, scope, functionType.argumentTypes[0])
            }
          }
          node.resolvedType = context
          return true
        }
      }

      # Use simple call chaining when there's an add operator present
      if add != null {
        var chain = Node.createDot(Node.createType(context).withRange(node.range), create != null ? create.name : "new").withRange(node.range)
        while node.hasChildren {
          var child = node.firstChild.remove
          var dot = Node.createDot(chain, add.name).withRange(child.range)
          chain = Node.createCall(dot).withRange(child.range)
          if child.kind == .PAIR {
            chain.appendChildrenFrom(child)
          } else {
            chain.appendChild(child)
          }
        }
        node.become(chain)
        _resolveAsParameterizedExpressionWithConversion(node, scope, context)
        return true
      }

      # Make sure there's a constructor to call
      if create == null {
        _log.semanticErrorInitializerTypeInferenceFailed(node.range)
        return false
      }

      var dot = Node.createDot(Node.createType(context).withRange(node.range), create.name).withRange(node.range)

      # Call the initializer constructor
      if node.kind == .INITIALIZER_MAP {
        var firstValues = Node.createList
        var secondValues = Node.createList
        for child = node.firstChild; child != null; child = child.nextSibling {
          var first = child.firstValue
          var second = child.secondValue
          firstValues.appendChild(first.remove)
          secondValues.appendChild(second.remove)
        }
        node.become(Node.createCall(dot).withRange(node.range).appendChild(firstValues).appendChild(secondValues))
      } else {
        node.become(Node.createCall(dot).withRange(node.range).appendChild(Node.createList.appendChildrenFrom(node)))
      }
      _resolveAsParameterizedExpressionWithConversion(node, scope, context)
      return true
    }

    def _mergeCommonType(commonType Type, child Node) Type {
      if commonType == null || child.resolvedType == .DYNAMIC {
        return child.resolvedType
      }

      var result = _cache.commonImplicitType(commonType, child.resolvedType)
      if result != null {
        return result
      }

      _log.semanticErrorNoCommonType(child.range, commonType, child.resolvedType)
      return .DYNAMIC
    }

    def _resolveLambda(node Node, scope Scope, context Type) {
      var symbol = node.symbol.asFunctionSymbol
      symbol.scope = FunctionScope.new(scope, symbol)

      # Use type context to implicitly set missing types
      if context != null && context.kind == .LAMBDA {

        # Copy over the argument types if they line up
        if context.argumentTypes.count == symbol.arguments.count {
          for i in 0..symbol.arguments.count {
            var argument = symbol.arguments[i]
            if argument.type == null {
              argument.type = Node.createType(context.argumentTypes[i])
            }
          }
        }

        # Copy over the return type
        if symbol.returnType == null && context.returnType != null {
          symbol.returnType = Node.createType(context.returnType)
        }
      }

      else {
        # Only infer non-void return types if there's no type context
        if symbol.returnType == null {
          symbol.flags |= Symbol.SHOULD_INFER_RETURN_TYPE
        }

        # If there's dynamic type context, treat all arguments as dynamic
        if context == .DYNAMIC {
          for argument in symbol.arguments {
            if argument.type == null {
              argument.type = Node.createType(.DYNAMIC)
            }
          }
          if symbol.returnType == null {
            symbol.returnType = Node.createType(.DYNAMIC)
          }
        }
      }

      _resolveFunction(symbol)

      # Use a LambdaType instead of a SymbolType for the node
      var argumentTypes List<Type> = []
      var returnType = symbol.returnType
      for argument in symbol.arguments {
        argumentTypes.append(argument.resolvedType)
      }
      node.resolvedType = _cache.createLambdaType(argumentTypes, returnType?.resolvedType)
    }

    def _resolveLambdaType(node Node, scope Scope) {
      var lambdaReturnType = node.lambdaReturnType
      var argumentTypes List<Type> = []
      var returnType Type = null

      for child = node.firstChild; child != lambdaReturnType; child = child.nextSibling {
        _resolveAsParameterizedType(child, scope)
        argumentTypes.append(child.resolvedType)
      }

      # An empty return type is signaled by the type "null"
      if lambdaReturnType.kind != .TYPE || lambdaReturnType.resolvedType != null {
        _resolveAsParameterizedType(lambdaReturnType, scope)
        returnType = lambdaReturnType.resolvedType
      }

      node.resolvedType = _cache.createLambdaType(argumentTypes, returnType)
    }

    def _resolveName(node Node, scope Scope) {
      var enclosingFunction = scope.findEnclosingFunction
      var name = node.asString
      var symbol = scope.find(name, _shouldCheckForSetter(node) ? .ALSO_CHECK_FOR_SETTER : .NORMAL)

      if symbol == null {
        _reportGuardMergingFailure(node)
        if name == "this" && enclosingFunction != null && enclosingFunction.symbol.this != null {
          _log.semanticErrorUndeclaredSelfSymbol(node.range, name)
        } else {
          _log.semanticErrorUndeclaredSymbol(node.range, name)
        }
        return
      }

      _initializeSymbol(symbol)

      # Track reads and writes of local variables for later use
      _recordStatistic(symbol, node.isAssignTarget ? .WRITE : .READ)

      # Forbid referencing a base class global or constructor function from a derived class
      if enclosingFunction != null && _isBaseGlobalReference(enclosingFunction.symbol.parent, symbol) {
        _log.semanticErrorUndeclaredSymbol(node.range, name)
        return
      }

      # Automatically insert "self." before instance symbols
      var resolvedType = symbol.resolvedType
      if symbol.kind.isOnInstances {
        var variable = enclosingFunction?.symbol.this
        if variable != null && enclosingFunction.symbol.parent.asObjectSymbol.isSameOrHasBaseClass(symbol.parent) {
          node.become(Node.createDot(Node.createSymbolReference(variable), name).withRange(node.range))
          resolvedType = _cache.substitute(resolvedType, variable.resolvedType.environment)
        } else {
          _log.semanticErrorMemberUnexpectedInstance(node.range, symbol.name)
        }
      }

      # Type parameters for objects may only be used in certain circumstances
      else if symbol.kind == .PARAMETER_OBJECT {
        var parent = scope
        var isValid = false

        while parent != null {
          switch parent.kind {
            case .OBJECT {
              isValid = parent.asObjectScope.symbol == symbol.parent
              break
            }

            case .FUNCTION {
              var function = parent.asFunctionScope.symbol
              if function.kind != .FUNCTION_LOCAL {
                isValid = function.parent == symbol.parent
                break
              }
            }

            case .VARIABLE {
              var variable = parent.asVariableScope.symbol
              isValid = variable.kind == .VARIABLE_INSTANCE && variable.parent == symbol.parent
              break
            }
          }

          parent = parent.parent
        }

        if !isValid {
          _log.semanticErrorMemberUnexpectedTypeParameter(node.range, symbol.name)
        }
      }

      node.symbol = symbol
      node.resolvedType = resolvedType
      _automaticallyCallGetter(node, scope)
    }

    def _hookForNullDot(node Node, scope Scope) Node {
      var target = node.dotTarget.remove
      _resolveAsParameterizedExpression(target, scope)
      var check = Node.createBinary(.NOT_EQUAL, _extractExpression(target, scope), Node.createNull.withRange(node.internalRange)).withRange(target.range)
      var dot = Node.createDot(target, node.asString).withRange(node.range).withInternalRange(node.internalRange)
      return Node.createHook(check, dot, Node.createNull.withRange(node.internalRangeOrRange)).withRange(node.range)
    }

    def _resolveNullDot(node Node, scope Scope) {
      node.become(_hookForNullDot(node, scope))
      _resolveAsParameterizedExpression(node, scope)
    }

    def _resolveNullJoin(node Node, scope Scope, context Type) {
      var first = node.nullJoinFirst
      var second = node.nullJoinSecond.remove
      _resolveAsParameterizedExpressionWithTypeContext(first.remove, scope, context)
      var check = Node.createBinary(.NOT_EQUAL, _extractExpression(first, scope), Node.createNull).withRange(first.range)
      node.become(Node.createHook(check, first, second).withRange(node.range))
      node.flags |= Node.WAS_NULL_JOIN
      _resolveAsParameterizedExpressionWithTypeContext(node, scope, context)
    }

    def _resolveParameterize(node Node, scope Scope) {
      var value = node.parameterizeValue
      _resolveNode(value, scope, null)

      # Resolve parameter types
      var substitutions List<Type> = []
      var count = 0
      for child = value.nextSibling; child != null; child = child.nextSibling {
        _resolveAsParameterizedType(child, scope)
        substitutions.append(child.resolvedType)
        count++
      }

      var type = value.resolvedType
      var parameters = type.parameters

      # If this is an overloaded symbol, try to pick an overload just using the parameter count
      if parameters == null && type.kind == .SYMBOL && type.symbol.kind.isOverloadedFunction {
        var match FunctionSymbol = null
        for candidate in type.symbol.asOverloadedFunctionSymbol.symbols {
          if candidate.parameters != null && candidate.parameters.count == count {
            if match != null {
              match = null
              break
            }
            match = candidate
          }
        }
        if match != null {
          type = _cache.substitute(match.resolvedType, type.environment)
          parameters = type.parameters
        }
      }

      # Check for type parameters
      if parameters == null || type.isParameterized {
        if type != .DYNAMIC {
          _log.semanticErrorCannotParameterize(node.range, type)
        }
        value.resolvedType = .DYNAMIC
        return
      }

      # Check parameter count
      var expected = parameters.count
      if count != expected {
        _log.semanticErrorParameterCount(node.internalRangeOrRange, expected, count)
        value.resolvedType = .DYNAMIC
        return
      }

      # Make sure all parameters have types
      for parameter in parameters {
        _initializeSymbol(parameter)
      }

      # Include the symbol for use with Node.isType
      node.resolvedType = _cache.substitute(type, _cache.mergeEnvironments(type.environment, _cache.createEnvironment(parameters, substitutions), null))
      node.symbol = value.symbol
    }

    def _resolveSequence(node Node, scope Scope, context Type) {
      for child = node.firstChild; child != null; child = child.nextSibling {
        _resolveAsParameterizedExpressionWithTypeContext(child, scope, child.nextSibling == null ? context : null)
      }
    }

    def _resolveSuper(node Node, scope Scope) {
      var function = scope.findEnclosingFunction
      var symbol = function?.symbol
      var baseType = symbol?.parent.asObjectSymbol.baseType
      var overridden = baseType == null ? null : _findMember(baseType, symbol.name)

      if overridden == null {
        _log.semanticErrorBadSuper(node.range)
        return
      }

      # Calling a static method doesn't need special handling
      if overridden.kind == .FUNCTION_GLOBAL {
        node.kind = .NAME
      }

      node.resolvedType = overridden.resolvedType
      node.symbol = overridden
      _automaticallyCallGetter(node, scope)
    }

    def _resolveTypeCheck(node Node, scope Scope) {
      var value = node.typeCheckValue
      var type = node.typeCheckType

      _resolveAsParameterizedExpression(value, scope)
      _resolveAsParameterizedType(type, scope)
      _checkConversion(value, type.resolvedType, .EXPLICIT)
      node.resolvedType = _cache.boolType

      # Type checks don't work against interfaces
      if type.resolvedType.isInterface {
        _log.semanticWarningBadTypeCheck(type.range, type.resolvedType)
      }

      # Warn about unnecessary type checks
      else if value.resolvedType != .DYNAMIC && _cache.canImplicitlyConvert(value.resolvedType, type.resolvedType) && (type.resolvedType != .DYNAMIC || type.kind == .TYPE) {
        _log.semanticWarningExtraTypeCheck(Range.span(node.internalRangeOrRange, type.range), value.resolvedType, type.resolvedType)
      }
    }

    def _resolveBinary(node Node, scope Scope) {
      var kind = node.kind
      var left = node.binaryLeft
      var right = node.binaryRight

      # Special-case the equality operators
      if kind == .EQUAL || kind == .NOT_EQUAL {
        if _needsTypeContext(left) {
          _resolveAsParameterizedExpression(right, scope)
          _resolveAsParameterizedExpressionWithTypeContext(left, scope, right.resolvedType)
        } else if _needsTypeContext(right) {
          _resolveAsParameterizedExpression(left, scope)
          _resolveAsParameterizedExpressionWithTypeContext(right, scope, left.resolvedType)
        } else {
          _resolveAsParameterizedExpression(left, scope)
          _resolveAsParameterizedExpression(right, scope)
        }

        # Check for likely bugs "x == x" or "x != x", except when this is used to test for NaN
        if left.looksTheSameAs(right) && left.hasNoSideEffects && right.hasNoSideEffects &&
            !_cache.isEquivalentToDouble(left.resolvedType) && left.resolvedType != .DYNAMIC {
          _log.semanticWarningIdenticalOperands(node.range, kind == .EQUAL ? "==" : "!=")
        }

        # The two types must be compatible
        var commonType = _cache.commonImplicitType(left.resolvedType, right.resolvedType)
        if commonType == null {
          _log.semanticErrorNoCommonType(node.range, left.resolvedType, right.resolvedType)
        } else {
          node.resolvedType = _cache.boolType
        }

        return
      }

      # Special-case assignment since it's not overridable
      if kind == .ASSIGN {
        _resolveAsParameterizedExpression(left, scope)

        # Automatically call setters
        if left.symbol != null && left.symbol.isSetter {
          node.become(Node.createCall(left.remove).withRange(node.range).withInternalRange(right.range).appendChild(right.remove))
          _resolveAsParameterizedExpression(node, scope)
        }

        # Resolve the right side using type context from the left side
        else {
          _resolveAsParameterizedExpressionWithConversion(right, scope, left.resolvedType)
          node.resolvedType = left.resolvedType
          _checkStorage(left, scope)

          # Check for likely bugs "x = x"
          if left.looksTheSameAs(right) && left.hasNoSideEffects && right.hasNoSideEffects {
            _log.semanticWarningIdenticalOperands(node.range, "=")
          }
        }

        return
      }

      # Special-case short-circuit logical operators since they aren't overridable
      if kind == .LOGICAL_AND || kind == .LOGICAL_OR {
        _resolveAsParameterizedExpressionWithConversion(left, scope, _cache.boolType)
        _resolveAsParameterizedExpressionWithConversion(right, scope, _cache.boolType)
        node.resolvedType = _cache.boolType

        # Check for likely bugs "x && x" or "x || x"
        if left.looksTheSameAs(right) && left.hasNoSideEffects && right.hasNoSideEffects && (!left.isBool || !right.isBool) {
          _log.semanticWarningIdenticalOperands(node.range, kind == .LOGICAL_AND ? "&&" : "||")
        }
        return
      }

      _resolveOperatorOverload(node, scope)
    }

    def _extractExpression(node Node, scope Scope) Node {
      assert(node.resolvedType != null)

      if node.kind == .NAME || node.kind == .CONSTANT {
        return node.clone
      }

      var enclosingFunction = scope.findEnclosingFunctionOrLambda
      var block = enclosingFunction.symbol.block
      var symbol = VariableSymbol.new(.VARIABLE_LOCAL, enclosingFunction.generateName("ref"))
      var after = block.firstChild
      var type = node.resolvedType

      # Force-initialize the symbol
      symbol.type = Node.createType(type)
      symbol.resolvedType = type
      symbol.state = .INITIALIZED

      # Make sure the call to "super" is still the first statement
      if after.isSuperCallStatement {
        after = after.nextSibling
      }

      # Add the new variable to the top of the function
      block.insertChildBefore(after, Node.createVariables.appendChild(Node.createVariable(symbol)))

      # Replace the original expression with a reference
      var reference = Node.createSymbolReference(symbol).withRange(node.range)
      var setup = node.cloneAndStealChildren
      node.become(reference)
      return Node.createBinary(.ASSIGN, reference, setup).withType(type).withRange(node.range)
    }

    # Expressions with side effects must be stored to temporary variables
    # if they need to be duplicated in an expression. This does the variable
    # allocation and storage and returns a partial assigment.
    #
    # Examples:
    #
    #    "a" stays "a" and returns "a"
    #    "a.b" stays "a.b" and returns "a.b"
    #    "a[0]" stays "a[0]" and returns "a[0]"
    #    "a().b" becomes "ref.b" and returns "(ref = a()).b"
    #    "a()[0]" becomes "ref[0]" and returns "(ref = a())[0]"
    #    "a()[b()]" becomes "ref[ref2]" and returns "(ref = a())[ref2 = b()]"
    #
    def _extractExpressionForAssignment(node Node, scope Scope) Node {
      assert(node.resolvedType != null)

      # Handle dot expressions
      if node.kind == .DOT {
        return Node.createMemberReference(_extractExpression(node.dotTarget, scope), node.symbol).withRange(node.range)
      }

      # Handle index expressions
      if node.kind == .INDEX {
        return Node.createIndex(_extractExpression(node.indexLeft, scope), _extractExpression(node.indexRight, scope)).withRange(node.range)
      }

      # Handle name expressions
      return node.clone
    }

    def _resolveOperatorOverload(node Node, scope Scope) {
      # The order of operands are reversed for the "in" operator
      var kind = node.kind
      var reverseBinaryOrder = kind == .IN
      var first = node.firstChild
      var second = first.nextSibling
      var target = reverseBinaryOrder ? second : first
      var other = kind.isBinary ? reverseBinaryOrder ? first : second : null

      # Allow "foo in [.FOO, .BAR]"
      if kind == .IN && target.kind == .INITIALIZER_LIST && !_needsTypeContext(other) {
        _resolveAsParameterizedExpression(other, scope)
        _resolveAsParameterizedExpressionWithTypeContext(target, scope, other.resolvedType != .DYNAMIC ? _cache.createListType(other.resolvedType) : null)
      }

      # Resolve just the target since the other arguments may need type context from overload resolution
      else {
        _resolveAsParameterizedExpression(target, scope)
      }

      # Warn about shifting by 0 in the original source code, since that doesn't
      # do anything when the arguments are integers and so is likely a mistake
      if kind == .UNSIGNED_SHIFT_RIGHT && _cache.isEquivalentToInt(target.resolvedType) && other.isInt && other.asInt == 0 {
        _log.semanticWarningShiftByZero(node.range)
      }

      # Can't do overload resolution on the dynamic type
      var type = target.resolvedType
      if type == .DYNAMIC {
        if kind.isAssign {
          _checkStorage(target, scope)
        }
        _resolveChildrenAsParameterizedExpressions(node, scope)
        return
      }

      # Check if the operator can be overridden at all
      var info = operatorInfo[kind]
      if info.kind != .OVERRIDABLE {
        _log.semanticErrorUnknownMemberSymbol(node.internalRangeOrRange, info.text, type)
        _resolveChildrenAsParameterizedExpressions(node, scope)
        return
      }

      # Auto-convert int to double and enum to int when it appears as the target
      if other != null && !kind.isBinaryAssign {
        if type == _cache.intType {
          _resolveAsParameterizedExpression(other, scope)
          if other.resolvedType == _cache.doubleType {
            _checkConversion(target, _cache.doubleType, .IMPLICIT)
            type = _cache.doubleType
          }
        } else if type.isEnum {
          _resolveAsParameterizedExpression(other, scope)
          if _cache.isNumeric(other.resolvedType) {
            type = _cache.commonImplicitType(type, other.resolvedType)
            assert(type != null)
            if type.isEnum { type = _cache.intType }
            _checkConversion(other, type, .IMPLICIT)
            _checkConversion(target, type, .IMPLICIT)
          }
        }
      }

      # Find the operator method
      var isComparison = kind.isBinaryComparison
      var name = isComparison ? "<=>" : info.text
      var symbol = _findMember(type, name)
      var extracted Node = null
      if symbol == null && info.assignKind != .NULL {
        symbol = _findMember(type, operatorInfo[info.assignKind].text)
        if symbol != null {
          extracted = _extractExpressionForAssignment(target, scope)
          if kind == .INCREMENT || kind == .DECREMENT {
            node.appendChild(Node.createInt(1).withType(_cache.intType).withRange(node.internalRangeOrRange))
          }
          kind = info.assignKind
          node.kind = kind
        }
      }
      if symbol == null {
        _log.semanticErrorUnknownMemberSymbol(node.internalRangeOrRange, name, type)
        _resolveChildrenAsParameterizedExpressions(node, scope)
        return
      }
      var symbolType = _cache.substitute(symbol.resolvedType, type.environment)

      # Resolve the overload now so the symbol's properties can be inspected
      if symbol.kind.isOverloadedFunction {
        if reverseBinaryOrder {
          first.swapWith(second)
        }
        symbolType = _resolveOverloadedFunction(node.internalRangeOrRange, node, scope, symbolType)
        if reverseBinaryOrder {
          first.swapWith(second)
        }
        if symbolType == null {
          _resolveChildrenAsParameterizedExpressions(node, scope)
          return
        }
        symbol = symbolType.symbol
      }

      var isRawImport = symbol.isImported && !symbol.isRenamed
      node.symbol = symbol
      _checkAccess(node, node.internalRangeOrRange, scope)

      # Check for a valid storage location for imported operators
      if kind.isAssign && symbol.isImported && extracted == null {
        _checkStorage(target, scope)
      }

      # "<", ">", "<=", or ">="
      if isComparison && (isRawImport || type == _cache.intType || type == _cache.doubleType) {
        _resolveChildrenAsParameterizedExpressions(node, scope)
        node.resolvedType = _cache.boolType
        node.symbol = null
      }

      # Don't replace the operator with a call if it's just used for type checking
      else if isRawImport {
        if reverseBinaryOrder {
          first.swapWith(second)
        }
        if !_resolveFunctionCall(node, scope, symbolType) {
          _resolveChildrenAsParameterizedExpressions(node, scope)
        }
        if reverseBinaryOrder {
          first.swapWith(second)
        }
      }

      else {
        # Resolve the method call
        if reverseBinaryOrder {
          first.swapWith(second)
        }
        target = Node.createDot(target.remove, name).withSymbol(symbol).withRange(node.internalRangeOrRange)
        node.prependChild(target)

        # Implement the logic for the "<=>" operator
        if isComparison {
          var call = Node.new(.CALL).appendChildrenFrom(node).withRange(node.range)
          node.appendChild(call)
          node.appendChild(Node.createInt(0).withType(_cache.intType))
          node.resolvedType = _cache.boolType
          _resolveFunctionCall(call, scope, symbolType)
        }

        # All other operators are just normal method calls
        else {
          node.kind = .CALL
          _resolveFunctionCall(node, scope, symbolType)
        }
      }

      if extracted != null {
        # The expression used to initialize the assignment must return a value
        if symbolType.returnType == null {
          _log.semanticErrorUseOfVoidFunction(node.range, symbol.name, symbol.range)
        }

        # Wrap everything in an assignment if the assignment target was extracted
        if extracted.kind == .INDEX {
          extracted.kind = .ASSIGN_INDEX
          extracted.appendChild(node.cloneAndStealChildren)
          node.become(extracted)
        } else {
          node.become(Node.createBinary(.ASSIGN, extracted, node.cloneAndStealChildren))
        }
        _resolveAsParameterizedExpression(node, scope)
      }
    }

    def _automaticallyCallGetter(node Node, scope Scope) bool {
      var symbol = node.symbol
      if symbol == null {
        return false
      }
      var kind = symbol.kind
      var parent = node.parent

      # Never call a getter if type parameters are present
      if parent != null && parent.kind == .PARAMETERIZE && _isCallValue(parent) {
        return false
      }

      # The check for getters is complicated by overloaded functions
      if !symbol.isGetter && kind.isOverloadedFunction && (!_isCallValue(node) || parent.hasOneChild) {
        var overloaded = symbol.asOverloadedFunctionSymbol
        for getter in overloaded.symbols {

          # Just return the first getter assuming errors for duplicate getters
          # were already logged when the overloaded symbol was initialized
          if getter.isGetter {
            node.resolvedType = _cache.substitute(getter.resolvedType, node.resolvedType.environment)
            node.symbol = getter
            symbol = getter
            break
          }
        }
      }

      _checkAccess(node, node.internalRangeOrRange, scope)

      # Automatically wrap the getter in a call expression
      if symbol.isGetter {
        node.become(Node.createCall(node.cloneAndStealChildren).withRange(node.range))
        _resolveAsParameterizedExpression(node, scope)
        return true
      }

      # Forbid bare function references
      if !symbol.isSetter && node.resolvedType != .DYNAMIC && kind.isFunctionOrOverloadedFunction && kind != .FUNCTION_ANNOTATION &&
          !_isCallValue(node) && (parent == null || parent.kind != .PARAMETERIZE || !_isCallValue(parent)) {
        _log.semanticErrorMustCallFunction(node.internalRangeOrRange, symbol.name)
        node.resolvedType = .DYNAMIC
      }

      return false
    }

    def _convertSwitchToIfChain(node Node, scope Scope) {
      var variable = VariableSymbol.new(.VARIABLE_LOCAL, scope.generateName("value"))
      var value = node.switchValue.remove
      var block Node = null

      # Stash the variable being switched over so it's only evaluated once
      variable.resolvedType = value.resolvedType
      variable.value = value
      variable.state = .INITIALIZED
      node.parent.insertChildBefore(node, Node.createVariables.appendChild(Node.createVariable(variable)))

      # Build the chain in reverse starting with the last case
      for child = node.lastChild; child != null; child = child.previousSibling {
        var caseBlock = child.caseBlock.remove
        var test Node = null

        # Combine adjacent cases in a "||" chain
        while child.hasChildren {
          var caseValue = Node.createBinary(.EQUAL, Node.createSymbolReference(variable), child.firstChild.remove).withType(_cache.boolType)
          test = test != null ? Node.createBinary(.LOGICAL_OR, test, caseValue).withType(_cache.boolType) : caseValue
        }

        # Chain if-else statements together
        block = test != null ? Node.createBlock.appendChild(Node.createIf(test, caseBlock, block)) : caseBlock
      }

      # Replace the switch statement with the if chain
      if block != null {
        node.replaceWithChildrenFrom(block)
      } else {
        node.remove
      }
    }
  }

  namespace Resolver {
    const _annotationSymbolFlags = {
      "@alwaysinline": Symbol.IS_INLINING_FORCED,
      "@deprecated": Symbol.IS_DEPRECATED,
      "@entry": Symbol.IS_ENTRY_POINT,
      "@export": Symbol.IS_EXPORTED,
      "@import": Symbol.IS_IMPORTED,
      "@neverinline": Symbol.IS_INLINING_PREVENTED,
      "@prefer": Symbol.IS_PREFERRED,
      "@rename": Symbol.IS_RENAMED,
      "@skip": Symbol.IS_SKIPPED,
      "@spreads": Symbol.SHOULD_SPREAD,
    }

    def _shouldCheckForSetter(node Node) bool {
      return node.parent != null && node.parent.kind == .ASSIGN && node == node.parent.binaryLeft
    }

    def _isVoidExpressionUsed(node Node) bool {
      # Check for a null parent to handle variable initializers
      var parent = node.parent
      return parent == null || parent.kind != .EXPRESSION && !parent.isImplicitReturn &&
        (parent.kind != .ANNOTATION || node != parent.annotationValue) &&
        (parent.kind != .FOR || node != parent.forUpdate) &&
        parent.kind != .SEQUENCE
    }

    def _isValidVariableType(type Type) bool {
      return type != .NULL && (type.kind != .SYMBOL || !type.symbol.kind.isFunctionOrOverloadedFunction)
    }

    def _isBaseGlobalReference(parent Symbol, member Symbol) bool {
      return parent != null && parent.kind == .OBJECT_CLASS && member.kind.isGlobalReference && member.parent != parent &&
        member.parent.kind == .OBJECT_CLASS && parent.asObjectSymbol.hasBaseClass(member.parent)
    }

    def _isCallValue(node Node) bool {
      var parent = node.parent
      return parent != null && parent.kind == .CALL && node == parent.callValue
    }

    def _needsTypeContext(node Node) bool {
      return
        node.kind == .DOT && node.dotTarget == null ||
        node.kind == .HOOK && _needsTypeContext(node.hookTrue) && _needsTypeContext(node.hookFalse) ||
        node.kind.isInitializer
    }

    def _ensureFunctionIsOverloaded(symbol FunctionSymbol) {
      if symbol.overloaded == null {
        var overloaded = OverloadedFunctionSymbol.new(Merging.overloadedKind(symbol.kind), symbol.name, [symbol])
        overloaded.parent = symbol.parent
        overloaded.scope = overloaded.parent.scope
        symbol.overloaded = overloaded
      }
    }
  }
}
